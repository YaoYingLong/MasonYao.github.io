<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2022-07-27T13:45:35.823Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTPs协议</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/HTTPs%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/协议族/HTTPs协议/</id>
    <published>2022-07-25T16:00:00.000Z</published>
    <updated>2022-07-27T13:45:35.823Z</updated>
    
    <content type="html"><![CDATA[<p>虽然HTTP协议具有<strong>相当优秀</strong>和<strong>方便</strong>的一遍，但<strong><code>HTTP</code>协议</strong>可能存在<strong>信息窃听</strong>或<strong>身份伪装</strong>等安全问题，HTTP有如下不足：</p><ul><li>HTTP本身不具备加密功能，<strong>通信使用明文</strong>，内容<strong>可能会被窃听</strong></li><li><strong>不验证通信方的身份</strong>，因此有<strong>可能遭遇伪装</strong></li><li><strong>无法证明报文的完整性</strong>，所以有<strong>可能已遭篡改</strong></li></ul><p>按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视，<strong>即使已经过加密处理的通信</strong>，<strong>也会被窥视到通信内容</strong>，只是说若通信经过加密，就有可能让人无法破解报文信息的含义，但<strong>加密处理后的报文信息本身还是会被看到</strong>。为了防止窃听保护信息，最普及的就是加密技术。</p><p>HTTP协议中的请求和响应<strong>不会对通信方进行确认</strong>，<strong>任何人都可以发起请求</strong>，服务器只要接收到请求，<strong>不管对方是谁都会返回一个响应</strong>，这样就存在如下隐患：</p><ul><li><strong>无法确定</strong>请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器，<strong>可能是已伪装的Web服务器</strong></li><li><strong>无法确定</strong>响应返回到的客户端是否是按真实意图接收响应的那个客户端，<strong>可能是已伪装的客户端</strong></li><li><strong>无法确定</strong>正在<strong>通信的对方是否具备访问权限</strong></li><li>无法判定请求是来自何方、出自谁手</li><li><strong>即使是无意义的请求也会接收</strong>，无法阻止海量请求下的<strong><code>DoS</code>攻击</strong>即<strong><code>Denial of Service</code>拒绝服务攻击</strong></li></ul><p>HTTP协议无法证明通信报文的完整性，没有任何办法确认发出的请求和接收到的响应是前后相同的，像这样请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为<strong><code>Man-in-the-Middle attack</code>中间人攻击</strong>即<strong><code>MITM</code></strong>。  </p><p><img src="../../../../../images/网络/HTTP/MITM.png" alt></p><p>虽然可使用<strong><code>MD5</code></strong>、<strong><code>SHA-1</code></strong>等<strong>散列值校验</strong>的方法或<strong>确认文件的数字签名</strong>，来确定HTTP报文的完整性，但这些方法<strong>并不便捷可靠</strong>，提供文件下载服务的Web网站也会提供相应的以<strong><code>PGP</code></strong>即完美隐私创建的数字签名及MD5算法生成的散列值，不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件，浏览器无法自动帮用户检查，且这些方法依然无法百分百保证确认结果正确，因为若<strong><code>PGP</code></strong>和<strong><code>MD5</code></strong>本身被改写，用户是没有办法意识到的。</p><h4 id="通信加密"><a href="#通信加密" class="headerlink" title="通信加密"></a>通信加密</h4><p><strong>将通信加密</strong>，HTTP协议中没有加密机制，但可通过和<strong><code>Secure Socket Layer</code>安全套接层</strong>即<strong><code>SSL</code></strong>或<strong><code>Transport Layer Security</code>安全层传输协议</strong>即<strong><code>TLS</code></strong>的<strong>组合使用</strong>，从而加密HTTP的通信内容，与<strong><code>SSL</code></strong>组合使用的<strong><code>HTTP</code></strong>被称为<strong><code>HTTPs</code></strong>即<strong><code>HTTP Secure</code>超文本传输安全协议</strong>或<strong><code>HTTP over SSL</code></strong>。</p><p>SSL技术最初是由浏览器开发商<strong>网景通信公司</strong>率先倡导的，开发过<strong><code>SSL3.0</code>之前的版本</strong>，目前主导权已转移到<strong>Internet Engineering Task Force</strong>即<strong><code>IETF</code></strong>的Internet工程任务组，<strong><code>IETF</code></strong>以<strong><code>SSL3.0</code></strong>为基准制定了<strong><code>TLS1.0</code></strong>、 <strong><code>TLS1.1</code></strong>和<strong><code>TLS1.2</code></strong>，<strong><code>TSL</code>是以<code>SSL</code>为原型开发的协议</strong>，有时会统一称该协议为SSL，当前<strong>主流的版本</strong>是<strong><code>SSL3.0</code></strong>和<strong><code>TLS1.0</code></strong>。  </p><p><strong><code>SSL</code></strong>不仅<strong>提供加密处理</strong>，且还使用<strong>证书</strong>手段，<strong>可用于确定通信方</strong>，<strong>证书由值得信任的第三方机构颁发</strong>，用以证明服务器和客户端是实际存在的，伪造证书从技术角度来说是异常困难的一件事。SSL提供<strong>认证</strong>和<strong>加密处理</strong>及<strong>摘要功能</strong>，仅靠HTTP确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。</p><h4 id="内容加密"><a href="#内容加密" class="headerlink" title="内容加密"></a>内容加密</h4><p>将<strong>参与通信的内容本身加密</strong>，客户端需要对HTTP报文进行加密处理后再发送，且也<strong>只能加密报文主体</strong>，不能加密报文首部，为了做到有效的内容加密，前提是要求<strong>客户端和服务器同时具备加密和解密机制</strong>，但还是存在被篡改的风险。</p><h4 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h4><p><strong>数字证书</strong>是为了解决<strong>SSL协议</strong>在给客户端发送真正的公开密钥时，防止公钥被攻击者替换掉，<strong>防止中间人攻击</strong>时重新生成一套秘钥对，使得客户端与伪装服务器通信。</p><p><strong>数字证书认证机构</strong>处于客户端与服务器双方都可信赖的<strong>第三方机构</strong>的立场上，首先<strong>服务器</strong>运营人员向<strong>数字证书认证机构</strong>提出公开密钥的申请，<strong>数字证书认证机构</strong>在判明提出申请者的身份之后，<strong>对已申请的公开密钥做数字签名</strong>，然后<strong>分配该已签名的公开密钥</strong>，并将<strong>该公开密钥放入公钥证书后绑定在一起</strong>；服务器会将这份<strong>由数字证书认证机构颁发的公钥证书发送给客户端</strong>，以进行公开密钥加密方式通信；接到证书的客户端可使用数字证书认证机构的公开密钥， 对那张证书上的数字签名进行验证，一旦验证通过，则客户端便知道<strong>认证服务器的公开密钥的是真实有效的数字证书认证机构</strong>，且<strong>服务器的公开密钥是值得信赖的</strong>。</p><p>认证机关的公开密钥必须安全地转交给客户端，因此多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p><p>证书的一个作用是用来<strong>证明作为通信一方的服务器是否规范</strong>，另外一个作用是可<strong>确认对方服务器背后运营的企业是否真实存在</strong>，拥有该特<br>性的证书就是<strong><code>EV SSL</code></strong>证书即<strong><code>Extended Validation SSL Certificate</code></strong>。持有<strong><code>EV SSL</code></strong>证书的Web网站的浏览器<strong>地址栏处背景色是绿色</strong>的，且地址栏左侧会显示SSL证书中记录的<strong>组织名称</strong>以及<strong>颁发证书的认证机构名称</strong>。</p><h5 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a>客户端证书</h5><p>HTTPS中还可以使用<strong>客户端证书</strong>，以客户端证书进行客户端认证，但想获取证书时用户得自行安装客户端证书，但证书是收费的，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。且客户端证书只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性，即只要获得了安装客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限。</p><p>如果使用OpenSSL这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书，但该服务器证书在互<br>联网上不可作为证书使用。</p><p>独立构建的认证机构叫做<strong>自认证机构</strong>，由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性，值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实性。</p><h5 id="证书验证-1"><a href="#证书验证-1" class="headerlink" title="证书验证"></a>证书验证</h5><p>浏览器在发起HTTPs请求时，服务器会返回网站的SSL证书，浏览器需要对证书做一下验证：</p><ul><li>验证证书上的<strong>域名</strong>、<strong>有效期</strong>等信息是否正确</li><li>判断证书来源是否合法，<strong>每份签发证书</strong>都可以<strong>根据验证链</strong>查找到对应的<strong>根证书</strong>，<strong>操作系统</strong>和<strong>浏览器</strong>会<strong>本地存</strong>储权威机构的<strong>根证书</strong>，<strong>利用根证书可对对应机构签发证书完成来源验证</strong></li><li>与<strong><code>CA</code>服务器</strong>进行校验，<strong>判断证书是否被篡改</strong></li><li>通过<strong><code>CRL</code>证书注销列表</strong>和<strong><code>OCSP</code>在线证书状态协议</strong>，<strong>判断证书是否已吊销</strong></li></ul><h3 id="HTTPs安全通信机制"><a href="#HTTPs安全通信机制" class="headerlink" title="HTTPs安全通信机制"></a>HTTPs安全通信机制</h3><p><strong><code>HTTPs</code></strong>并非应用层的一种新协议，只是<strong><code>HTTP</code>通信接口部分</strong>用<strong><code>SSL</code></strong>和<strong><code>TLS</code></strong>协议代替而已，<strong><code>HTTP</code>是直接和<code>TCP</code>通信</strong>，当使用<strong><code>SSL</code></strong>时，则<strong><code>HTTP</code>先与<code>SSL</code>通信再由<code>SSL</code>与<code>TCP</code>通信</strong>，所谓<strong><code>HTTPs</code>其实就是身披<code>SSL</code>协议外壳的<code>HTTP</code></strong>。</p><p><img src="../../../../../images/网络/HTTP/HTTP与HTTPs.png" alt></p><p><strong><code>SSL</code>是独立于HTTP协议的</strong>，不光是HTTP协议，其他运行在应用层的<strong><code>SMTP</code></strong>和<strong><code>Telnet</code></strong>等协议<strong>均可配合<code>SSL</code>协议</strong>使用，<strong><code>SSL</code></strong>是当今世界上<strong>应用最为广泛的网络安全技术</strong>。  </p><p><strong><code>SSL</code></strong>采用的是<strong>非对称加密</strong>即<strong>公开秘钥加密</strong>，如果使用<strong>对称加密</strong>，必须将秘钥发送给对方，如果通信被监听秘钥可能会别攻击者窃取，也就失去了加密的意义，还得设法安全的保管接收到的秘钥，非对称加密则很好的解决了该问题，因为非对称加密是使用公钥加密，私钥解密，不需要发送用来解密的私钥，不必担心秘钥被攻击者窃取。</p><p>HTTPs采用<strong>对称加密</strong>和<strong>非对称加密</strong>两者<strong>并用</strong>的<strong>混合加密机制</strong>，<strong>非对称加密</strong>处理速度<strong>慢</strong>于<strong>对称加密</strong>，故<strong><code>HTTPs</code></strong>利用两者的优势，在<strong>交换密钥环节</strong>使用<strong>非对称加密方式</strong>，<strong>建立通信交换报文阶段</strong>则使用<strong>对称加密方式</strong>。</p><p><img src="../../../../../images/网络/HTTP/HTTP加密算法.png" alt></p><p>即使如此对称加密还是存在一些问题，即<strong>无法证明公开密钥本身就是货真价实的公开密钥</strong>，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥，或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了，可使用由<strong>数字证书认证机构<code>CA</code></strong>即<strong><code>Certificate Authority</code></strong>和其相关机关颁发的<strong>公开密钥证书</strong>来解决该问题。</p><p>HTTPs之所以使用对称加密传输数据：</p><ul><li><strong>非对称加密</strong>相对于<strong>对称加密</strong>的<strong>加解密效率是非常低</strong></li><li>只有服务端保存了私钥，<strong>一对公私钥只能实现单向的加解密</strong>，否则需要两对秘钥，这就涉及到<strong>客户端证书</strong>问题</li></ul><h5 id="HTTPs通信步骤"><a href="#HTTPs通信步骤" class="headerlink" title="HTTPs通信步骤"></a>HTTPs通信步骤</h5><p><img src="../../../../../images/网络/HTTP/HTTPs安全通信机制.png" alt></p><p>首先<strong>客户端</strong>发送一个<strong><code>ClientHello</code></strong>消息给<strong>服务端</strong>，<strong>发起建立<code>SSL</code>会话</strong>的请求，并告诉服务端自己<strong>支持</strong>的<strong><code>Cipher Suite</code>加密组件列表</strong>包括所使用的<strong>加密算法</strong>及<strong>秘钥长度</strong>、<strong><code>SSL</code>指定的版本</strong>，且产生一个随机数，用于以后<strong>生成对称密钥</strong>，发送给服务端。</p><p>服务端首次响应会<strong>确定</strong>加密协议<strong><code>SSL</code>版本</strong>以及从接收的客户端加密组件中赛选出的<strong>加密组件</strong>，也会生成一个<strong>随机数</strong>响应给客户端，以<strong><code>ServerHello</code></strong>报文作为响应。</p><p>服务端把自己的<strong><code>Certificate</code>证书</strong>及<strong>公钥</strong>发送给客户端，让客户端进行校验，且<strong>公钥</strong>被用于加密后面握手过程中生成的<strong>对称密钥</strong>。</p><p>服务器发送<strong><code>ServerHelloDone</code></strong>报文通知客户端，告知<strong>最初阶段的<code>SSL</code>握手协商部分结束</strong>。</p><p><strong><code>SSL</code></strong>第一次握手结束之后，客户端以<strong><code>Client Key Exchange</code></strong>报文作为回应，<strong>通知服务器此消息以后客户端会以加密方式发送数据</strong>，是使用的一种被称为<strong><code>Pre-master secret</code></strong>的<strong>随机密码串</strong>进行对称加密。</p><p>接着客户端继续发送<strong><code>Change Cipher Spec</code></strong>报文，且通知服务端<strong>此报文之后</strong>的通信会采用<strong><code>Pre-master secret</code></strong>密钥加密，即使用上面的<strong>随机密码串</strong>做对称加密。</p><p>客户端发送<strong><code>Finished</code></strong>报文，该报文包含连<strong>接至今全部报文的整体校验值</strong>，若<strong>服务器是否能够正确解密该报文作</strong>，则说明本次握手协商成功。</p><p>服务器同样发送<strong><code>Change Cipher Spec</code></strong>报文，<strong>通知客户端此消息以后服务器会以加密方式发送数据</strong>。</p><p>服务端发送<strong><code>Finished</code></strong>报文阶段，且服务端使用<strong>对称秘钥加密</strong>之前发送的<strong>所有握手消息的hash值</strong>给客户端，让客户端校验。</p><p><strong>服务器</strong>和<strong>客户端</strong>的<strong><code>Finished</code></strong>报文<strong>交换完毕</strong>后，<strong><code>SSL</code>连接就算建立完成</strong>，然后进行应用层协议通信即发送HTTP响应。</p><p>最后<strong>由客户端断开连接</strong>，断开连接时发送<strong><code>close_notify</code></strong>报文，然后再发送<strong><code>TCP FIN</code></strong>报文来关闭与TCP的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做<strong><code>MAC</code></strong>即<strong><code>Message Authentication Code</code></strong>的<strong>报文摘要</strong>，MAC能够<strong>查知报文是否被篡改</strong>，从而保护报文的完整性。  </p><p><img src="../../../../../images/网络/HTTP/HTTPs建立通信过程.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然HTTP协议具有&lt;strong&gt;相当优秀&lt;/strong&gt;和&lt;strong&gt;方便&lt;/strong&gt;的一遍，但&lt;strong&gt;&lt;code&gt;HTTP&lt;/code&gt;协议&lt;/strong&gt;可能存在&lt;strong&gt;信息窃听&lt;/strong&gt;或&lt;strong&gt;身份伪装&lt;/stron
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="协议族" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="网络" scheme="https://yaoyinglong.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/协议族/HTTP协议/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2022-07-26T14:14:35.989Z</updated>
    
    <content type="html"><![CDATA[<p>由<strong>欧洲孩子研究组织CERN</strong>的<strong>蒂姆伯纳斯李</strong>博士提出的一种能让远隔两地的研究者们共享知识的设想，最初设想的基本理念是，<strong>借助多文档之间的相互关联形成的超文本</strong>，连成可相互参阅的WWW万维网。</p><p>WWW万维网的三项构建技术：把标准通用标记语言<strong><code>SGML</code></strong>作为页面的文本标记语言的<strong><code>HTML</code>超文本标记语言</strong>；作为文档传输协议的<strong><code>HTTP</code></strong>；指定文档所在地址的<strong>统一资源定位符<code>URL</code></strong>。</p><p><img src="../../../../../images/网络/协议.png" alt></p><p>为了更快地处理大量事务，确保协议的可伸缩性，HTTP协议是一种无状态协议，其自身不对请求和响应之间的通信状态进行保存，为了实现期望的保持状态功能，引入了<strong><code>Cookie</code></strong>技术。Cookie技术通过在<strong>请求</strong>和<strong>响应</strong>报文中<strong>写入Cookie信息来控制客户端的状态</strong>，Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往服务端发送请求时，会自动在请求报文中加入Cookie值后发送出去；服务端接收到Cookie后，会检查对比服务器上的记录，得到之前的状态信息。</p><p>两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端是服务端。且是先从客户端开始建立通信。</p><p><strong>请求报文</strong>是由<strong>请求方法</strong>、<strong>请求URI</strong>、<strong>协议版本号</strong>、可选的<strong>请求首部字段</strong>和<strong>内容实体</strong>构成。</p><p><strong>响应报文</strong>是由<strong>协议版本</strong>、<strong>状态码</strong>、用于<strong>解释状态码的原因短语</strong>、可选的<strong>响应首部字段</strong>以及<strong>实体主体</strong>构成。</p><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>URI统一资源标识符，<strong>由某个协议方案表示的资源的定位标识符</strong>，<strong>协议方案</strong>是指访<strong>问资源</strong>所使用的<strong>协议类型名称</strong>，如采用HTTP协议时，协议方案就是HTTP。URI用字符串标识某一互联网资源。常见的几种URI：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ftp://ftp.is.co.za/rfc/rfc1808.txt</span></span><br><span class="line"><span class="attribute">http://www.ietf.org/rfc/rfc2396.txt</span></span><br><span class="line">ldap://[2001:db8::7]/c=GB?objectClass?one</span><br><span class="line"><span class="attribute">mailto:John.Doe@example.com</span></span><br><span class="line"><span class="attribute">news:comp.infosystems.www.servers.unix</span></span><br><span class="line"><span class="attribute">tel:+1-816-555-1212</span></span><br><span class="line"><span class="attribute">telnet://192.0.2.16:80/</span></span><br><span class="line"><span class="attribute">urn:oasis:names:specification:docbook:dtd:xml:4.1.2</span></span><br></pre></td></tr></table></figure><p>绝对URI格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</span><br></pre></td></tr></table></figure><p><strong><code>http:</code></strong>为协议名<strong>不区分大小写</strong>最后附一个冒号，<strong><code>user:pass</code></strong>为登录认证信息即用户名和密码，<strong><code>www.example.jp</code></strong>为服务地址也可以是<strong><code>IPv4</code></strong>地址或<strong><code>IPv6</code></strong>地址，<strong><code>80</code></strong>为端口号<strong>若省略自动使用默认端口号</strong>，<strong><code>dir/index.htm</code></strong>带层次的文件路径<strong>来定位特指的资源</strong>，<strong><code>uid=1</code></strong>查询字符串<strong>可选</strong>，<strong><code>ch1</code></strong>为片段标识符即<strong>文档内某个位置</strong>；</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL统一资源定位符，<strong>表示资源的地点</strong>，URL<strong>是URI的子集</strong>。</p><h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>为了更符合人类的记忆习惯，故用字母配合数字的表示形式来指定计算机名，但这种方式计算机理解不了，故通过<strong>DNS协议提供通过域名查找IP地址</strong>，或<strong>逆向从IP地址反查域名的服务</strong>。</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>向请求URI指定的资源发送请求报文时，采用称为方法的命令，方法的作用在于，可以<strong>指定请求的资源按期望产生某种行为</strong>，且区分大小写，注意使用大写。</p><table><thead><tr><th>方法</th><th>说明</th><th>支持的HTTP协议版本</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td><td>1.0、1.1</td></tr><tr><td>POST</td><td>传输实体主体</td><td>1.0、1.1</td></tr><tr><td>PUT</td><td>传输文件</td><td>1.0、1.1</td></tr><tr><td>HEAD</td><td>获取报文首部</td><td>1.0、1.1</td></tr><tr><td>DELETE</td><td>删除文件</td><td>1.0、1.1</td></tr><tr><td>OPTIONS</td><td>询问支持的方法</td><td>1.1</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>1.1</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td><td>1.1</td></tr><tr><td>LINK</td><td>建立和资源之间的联系</td><td>1.0</td></tr><tr><td>UNLINK</td><td>断开连接关系</td><td>1.0</td></tr></tbody></table><h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>GET是用来<strong>获取资源</strong>，<strong>用来请求访问已经被URI识别的资源</strong>，如果请求的资源是文本则原样返回，若是通用网关接口那样的程序，则返回执行后的输出结果。</p><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>POST是<strong>用来传输实体的主体</strong>，虽然GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是使用POST方法，虽然POST功能与GET相似，但<strong>POST的主要目的并不是获取响应的主体内容</strong>。</p><h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><p>PUT用于<strong>传输文件</strong>，像FTP协议的文件上传一样，要求在<strong>请求报文的主体中包含文件内容</strong>，然后<strong>保存到请求URI指定的位置</strong>，但是鉴于<strong><code>HTTP/1.1</code></strong>的PUT方法<strong>自身不带验证机制</strong>，任何人都可以上传文件，<strong>存在安全问题</strong>，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST表征状态转移标准的同类Web网站，就可能会开放使用PUT方法。</p><h5 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h5><p>HEAD方法和GET方法一样，只是<strong>不返回报文主体部分</strong>，用于<strong>确认URI的有效性</strong>、通信状态及<strong>资源更新的日期时间</strong>等</p><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>DELETE方法用于<strong>删除文件</strong>，与PUT方法相反，DELETE方法<strong>按请求URI删除指定的资源</strong>，一样<strong>不带验证机制</strong>。</p><h5 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h5><p>OPTIONS方法用于<strong>询问支持的方法</strong>，用来<strong>查询针对请求URI指定的资源支持的方法</strong>。</p><h5 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h5><p>TRACE用于<strong>追踪路径</strong>，让Web服务器<strong>将之前的请求通信返回给客户端的方法</strong>。发送请求在<strong><code>Max-Forwards</code>首部字段</strong>中填入数值，每经过一个服务器端，就将该<strong>数字减一</strong>，当数值<strong>刚好减到0时</strong>，就<strong>停止继续传输</strong>，<strong>最后接收到请求的服务器端则返回状态码200 OK的响应</strong>。客户端可以通过TRACE方法查询发送出去的请求时怎样被加工修改的，因为请求想要链接到源目标服务器可能会通过代理中转，<strong><code>TRACE</code></strong>方法就是<strong>用来确认连接过程中发生的一系列操作</strong>。<strong>容易引发<code>XST</code>跨站追踪</strong>。</p><h5 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h5><p>CONNECT方法<strong>要求在与代理服务器通信时建立隧道</strong>，<strong>实现用隧道协议进行TCP通信</strong>，主要使用<strong><code>SSL</code>安全套接层</strong>和<strong><code>TLS</code>传输安全层</strong>协议吧通信<strong>内容加密后经过网络隧道传输</strong>。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP协议<strong>初始版本</strong>中，<strong>每进行一次HTTP通信就要断开一次TCP连接</strong>，使用浏览器浏览一个包含多个张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源，<strong>每次请求都会造成无所谓的TCP连接建立和断开</strong>。 </p><p>为了解决TCP连接问题，<strong><code>HTTP/1.1</code></strong>和一<strong>部分<code>HTTP/1.0</code></strong>想出了<strong>持久连接</strong>即<strong><code>HTTP keep-alive</code></strong>或<strong><code>HTTP connection reuse</code></strong>的方法，<strong>任意一端</strong>没有<strong>明确提出断开连接</strong>，则<strong>保持连接状态</strong>。</p><p>持<strong>久连接</strong>减少了<strong>TCP连接</strong>的<strong>重复建立</strong>和<strong>断开</strong>所造成的额外开销，<strong>减轻了服务器端的负载</strong>，减少开销的那部分时间，<strong>使HTTP请求和响应能更早的结束</strong>，使Web页面的显示速度也得以提高。<strong><code>HTTP/1.1</code></strong>中<strong>所有连接默认都是持久连接</strong>，但<strong><code>HTTP/1.0</code></strong>内并未标准化。虽然一部分服务器通过非标准手段实现了持久连接，但服务器不一定能支持持久连接，且还需要客户端也支持持久连接。</p><p><strong>持久连接</strong>使得<strong>多数请求以管线化方式发送成为可能</strong>，管线化技术出现后，<strong>不用等待响应亦可直接发送下一个请求</strong>。</p><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文是HTTP协议交互的信息，由<strong>多行数据</strong>构成的<strong>字符串文本</strong>， 且<strong>以<code>CR</code>（回车）+ <code>LF</code>（换行） 作换行符</strong>，分为<strong>请求报文</strong>和<strong>响应报文</strong>。 HTTP报文分为<strong>首部</strong>和<strong>主体</strong>两块，两者由<strong>首个<code>CR+LF</code>分割</strong>。</p><p><img src="../../../../../images/网络/HTTP/请求报文和响应报文结构.png" alt="请求报文和响应报文结构"></p><p><strong>请求报文首部</strong>含有<strong>请求行</strong>、<strong>请求首部字段</strong>、<strong>通用首部字段</strong>、<strong>实体首部字段</strong>、<strong>其他</strong>；</p><p><img src="../../../../../images/网络/HTTP/请求报文实例.png" alt></p><p><strong>响应报文首部</strong>含有<strong>状态行</strong>、<strong>响应首部字段</strong>、<strong>通用首部字段</strong>、<strong>实体首部字段</strong>、<strong>其他</strong>。</p><p><img src="../../../../../images/网络/HTTP/响应报文实例.png" alt></p><p><strong>请求行</strong>包含用户<strong>请求的方法</strong>、<strong>请求URI</strong>、<strong>HTTP版本</strong>；<strong>状态行</strong>包含表明响应结果的<strong>状态码</strong>、<strong>原因短语</strong>、<strong>HTTP版本</strong>。</p><p><strong>首部字段</strong>包含表示<strong>请求</strong>和<strong>响应</strong>的<strong>各种条件</strong>和<strong>属性</strong>的<strong>各类首部</strong>，一般包含<strong><code>4</code>类</strong>首部，分别是<strong>通用首部</strong>、<strong>请求首部</strong>、<strong>响应首部</strong>和<strong>实体首部</strong>、<strong>其他</strong>可能包含<strong>HTTP的RFC里未定义的首部</strong>，如<strong><code>Cookie</code></strong>等。</p><h5 id="编码提示传输效率"><a href="#编码提示传输效率" class="headerlink" title="编码提示传输效率"></a>编码提示传输效率</h5><p>HTTP在传输数据时<strong>可按照数据原貌直接传输</strong>，也可在传输过程中<strong>通过编码提升传输速率</strong>，通过在传输时编码，能有效地处理大量<br>访问请求，但编码操作需要计算机来完成，因此会消耗更多CPU等资源。  </p><p>HTTP协议中有一种被称为<strong>内容编码</strong>的功能，内容编码<strong>指明应用在实体内容上的编码格式</strong>，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码。常用内容编码有以下几种：</p><ul><li><strong><code>gzip</code></strong>：GNU zip</li><li><strong><code>compress</code></strong>：UNIX 系统的标准压缩</li><li><strong><code>deflate</code></strong>：zlib</li><li><strong><code>identity</code></strong>：不进行编码</li></ul><p>HTTP通信过程中，请求编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，在传输大容量数据时，通过把数据分割<br>成多块，能够让浏览器逐步显示页面，这种把<strong>实体主体分块</strong>的功能称为<strong>分块传输编码<code>Chunked Transfer Coding</code></strong>，每一块都会用<br><strong>十六进制来标记块的大小</strong>，而实体主体的最后一块会使用<strong><code>0(CR+LF)</code></strong>来标记；<strong><code>HTTP/1.1</code></strong>中存在一种称为<strong>传输编码<code>Transfer Coding</code></strong>的机制，可<strong>在通信时按某种编码方式传输</strong>，但<strong>只定义作用于分块传输编码中</strong>。  </p><h5 id="发送多种数据"><a href="#发送多种数据" class="headerlink" title="发送多种数据"></a>发送多种数据</h5><p>发送邮件时可在邮件里写入文字并添加多份附件，  因为采用了<strong><code>MIME</code></strong>即<strong><code>Multipurpose Internet Mail Extensions</code>多用途因特网邮件扩展机制</strong>，它允许邮件处理文本、图片、视频等多个不同类型的数据。在MIME扩展中会使用一种称为<strong>多部分对象集合<code>Multipart</code></strong>的方法来容纳多份不同类型的数据。   </p><p>HTTP协议中也采纳了多部分对象集合，发送报文主体内可含多种类型实体，通常是在图片、文本、文件等上传时使用，多部分对象集合包含的对象如下：</p><ul><li><strong><code>multipart/form-data</code></strong>：Web表单<strong>文件上传</strong>时使用</li><li><strong><code>multipart/byteranges</code></strong>：状态码206即Partial Content部分内容，<strong>响应报文包含了多个范围的内容</strong>时使用</li></ul><p>HTTP报文中使用多部分对象集合时，需在首部字段里加上<strong><code>Content-type</code></strong>，且使用<strong><code>boundary</code></strong>字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入<strong><code>--</code>标记</strong>，如–AaB03x、–THIS_STRING_SEPARATES等，在多部分对象集合对应的字符串的<strong>最后插入<code>--</code>标记</strong>，如： –AaB03x–、 –THIS_STRING_SEPARATES–等<strong>作为结束</strong>。多部分对象集合的每个部分类型中，都可含有首部字段，<strong>可在某个部分中嵌套使用多部分对象集合</strong>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=AaB03x</span><br><span class="line">--AaB03x</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="field1"</span><br><span class="line">Joe Blow</span><br><span class="line">--AaB03x</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="pics"; filename="file1.txt"</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br><span class="line">...（file1.txt的数据）...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Date</span>: Fri, 13 Jul 2012 02:45:26 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span>: Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/byteranges; boundary=THIS_STRING_SEPARATES</span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line"><span class="attribute">Content-Type</span>: application/pdf</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 500-999/8000</span><br><span class="line">...（范围指定的数据）...</span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line"><span class="attribute">Content-Type</span>: application/pdf</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 7000-7999/8000</span><br><span class="line">...（范围指定的数据）...</span><br><span class="line">--THIS_STRING_SEPARATES--</span><br></pre></td></tr></table></figure><h5 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h5><p>指定范围发送的请求叫做<strong>范围请求<code>Range Request</code></strong>，  对一份10000字节大小的资源，若使用范围请求，可只请求5001~10000字节内的资源。执行范围请求时会用到首部字段<strong><code>Range</code></strong>来指定资源的byte范围：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 5001~10000字节</span><br><span class="line"><span class="attribute">Range</span>: bytes=5001-10000</span><br><span class="line"># 从5001字节之后全部的</span><br><span class="line"><span class="attribute">Range</span>: bytes=5001-</span><br><span class="line"># 从一开始到3000字节和5000~7000字节的多重范围</span><br><span class="line"><span class="attribute">Range</span>: bytes=-3000, 5000-7000</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/tip.jpg</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.usagidesign.jp</span><br><span class="line"><span class="attribute">Range</span>: bytes =5001-10000</span><br></pre></td></tr></table></figure><p>针对范围请求，响应会返回<strong>状态码</strong>为<strong><code>206 Partial Content</code></strong>的响应报文，对于<strong>多重范围的范围请求</strong>，响应会在<strong>首部字段<code>Content-Type</code>标明<code>multipart/byteranges</code></strong>后返回响应报文。若<strong>服务端无法响应范围请求</strong>， 则会<strong>返回状态码<code>200 OK</code></strong>和<strong>完整的实体内容</strong>。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Date</span>: Fri, 13 Jul 2012 04:39:17 GMT</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</span><br><span class="line"><span class="attribute">Content-Length</span>: 5000</span><br><span class="line"><span class="attribute">Content-Type</span>: image/jpeg</span><br></pre></td></tr></table></figure><h5 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h5><p>同一Web网站可能存在着<strong>多份内容相同</strong>但使用<strong>语言不同</strong>的页面，如英语版和中文版的Web页面，当浏览器默认语言为英语或中文， 访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面。</p><p><strong>内容协商机制</strong>是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，内容协商会以响应资源的<strong>语言</strong>、<strong>字符集</strong>、<strong>编码方式</strong>等作为判断的基准，在请求报文中的以下首部字段就是判断的基准：</p><ul><li><strong><code>Accept</code></strong></li><li><strong><code>Accept-Charset</code></strong></li><li><strong><code>Accept-Encoding</code></strong></li><li><strong><code>Accept-Language</code></strong></li><li><strong><code>Content-Language</code></strong></li></ul><p>内容协商技术有：<strong>服务器驱动协商</strong>、<strong>客户端驱动协商</strong>、<strong>透明协商</strong>三种类型</p><ul><li><strong>服务器驱动协商</strong>：以请求首部字段为参考，在服务器端自动处理</li><li><strong>客户端驱动协商</strong>：用户从浏览器显示的可选项列表中手动选择，也可利用JS脚本在Web页面上自动选择，如PC版与手机版的选择</li><li><strong>透明协商</strong>：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法</li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><strong>状态码</strong>以<strong>3位数字</strong>和<strong>原因短语</strong>组成，数字中的<strong>第一位指定了响应类别</strong>后两位无分类，响应类别有以下5种：</p><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td><strong><code>1XX</code></strong></td><td>Informational（<strong>信息性</strong>状态码）</td><td><strong>接收的请求正在处理</strong></td></tr><tr><td><strong><code>2XX</code></strong></td><td>Success（<strong>成功</strong>状态码）</td><td><strong>请求正常处理完毕</strong></td></tr><tr><td><strong><code>3XX</code></strong></td><td>Redirection（<strong>重定向</strong>状态码）</td><td><strong>需要进行附加操作以完成请求</strong></td></tr><tr><td><strong><code>4XX</code></strong></td><td>Client Error（<strong>客户端错误</strong>状态码）</td><td><strong>服务器无法处理请求</strong></td></tr><tr><td><strong><code>5XX</code></strong></td><td>Server Error（<strong>服务器错误</strong>状态码）</td><td><strong>服务器处理请求出错</strong></td></tr></tbody></table><h4 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h4><p><strong><code>2XX</code></strong>的响应结果表明请求被正常处理了，在响应报文内， 随状态码一起返回的信息会因<strong>方法的不同</strong>而发生改变。如使用GET方法时，对应请求资源的实体会作为响应返回；使用HEAD方法时，对应请求资源的实体首部不随报文主体作为响应返回。</p><h5 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h5><p>服务器接收的请求<strong>已成功处理</strong>，但在返回的<strong>响应报文</strong>中<strong>不含实体的主体部分</strong>，也<strong>不允许</strong>返回任何<strong>实体的主体</strong>，当从浏览器发出请求处理后， 返回204响应则浏览器显示页面不发生更新；一般在<strong>只需要从客户端往服务器发送信息</strong>， 而对<strong>客户端不需要发送新信息内容</strong>的情况下使用。</p><h5 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h5><p>表示<strong>客户端进行了范围请求</strong>，而服务器成功执行了这部分GET请求，响应报文中包含由<strong><code>Content-Range</code></strong>指定范围的实体内容。</p><h4 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h4><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求</p><h5 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h5><p><strong>永久性重定向</strong>，表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI，若已经把资源对应的URI保存为书签，这时应按Location首部字段提示的URI重新保存。</p><h5 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h5><p><strong>临时性重定向</strong>，表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问，代表的资源不是被永久移动， 只是临时性质的。 已移动的资源对应的URI将来还有可能发生改变，用户把URI保存成书签， 但不会像301状态码那样去更新书签， 而是仍旧保留返回 302状态码的页面对应的URI。</p><h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><p>表示由于<strong>请求对应的资源存在着另一个URI</strong>，应使用GET方法定向获取请求的资源，303状态码和302状态码有着相同的功能，但<strong>303状态码明确表示客户端应当采用GET方法获取资源</strong>。</p><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><p>表示<strong>客户端发送附带条件的请求时</strong>，如GET方法请求报文中包含<strong><code>If-Match</code></strong>、<strong><code>If-ModifiedSince</code></strong>、<strong><code>If-None-Match</code></strong>、<strong><code>If-Range</code></strong>、<strong><code>If-Unmodified-Since</code></strong>中任一首部，服务器端允许请求访问资源，但<strong>未满足条件</strong>的情况，<strong>返回不包含任何响应的主体部分</strong>，和重定向没有关系。</p><h5 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h5><p><strong>临时重定向</strong>，<strong>与<code>302</code>有着相同的含义</strong>，尽管<strong><code>302</code>标准禁止<code>POST</code>变换成<code>GET</code></strong>，但实际使用时大家并不遵守，<strong><code>307</code>会遵照浏览器标准</strong>，不会从POST变成GET，但对于处理响应时的行为，每种浏览器有可能出现不同的情况。  </p><h4 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h4><p>4XX响应结果表明<strong>客户端是发生错误的原因所在</strong></p><h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><p>表示<strong>请求报文中存在语法错误</strong>，需修改请求的内容后再次发送请求，浏览器会像200 OK一样对待该状态码。</p><h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><p>表示<strong>发送的请求需要有通过<code>HTTP</code>认证</strong>，如<strong><code>BASIC</code></strong>认证、<strong><code>DIGEST</code></strong>认证等认证信息，若<strong>之前已进行过1次请求，则表示用户认证失败</strong>，返回含有401的响应<strong>必须包含一个适用于被请求资源</strong>的<strong><code>WWW-Authenticate</code></strong>首部用以<strong>质询用户信息</strong>。当<strong>浏览器初次接收到<code>401</code>响应</strong>，会<strong>弹出认证对话窗口</strong>。  </p><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>表示对<strong>请求资源的访问被服务器拒绝</strong>，服务器端没有必要给出拒绝的详细理由，也可在实体的主体部分对原因进行描述，如<strong>未获得文件系统的访问授权</strong>， <strong>访问权限出现某些问题</strong>等情况。</p><p>404 Not Found</p><p>表示<strong>服务器上无法找到请求的资源</strong>，也可在<strong>服务器端拒绝请求且不想说明理由时使用</strong>。</p><h4 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h4><p>5XX的响应结果表示<strong>服务器本身发生错误</strong></p><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>表示服务器端在<strong>执行请求时发生了错误</strong>，也可能是Web应用存在的bug或某些临时的故障</p><h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p><strong>服务器暂时处于超负载或正在进行停机维护</strong>，现在无法处理请求，若事先得知<strong>解除以上状况需要的时间</strong>，最好写入<strong><code>Retry-After</code></strong>首部字段再返回给客户端。  </p><h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><p>使用首部字段是为了给浏览器和服务器提供<strong>报文主体大小</strong>、 <strong>使用的语言</strong>、<strong>认证信息等内容</strong>，HTTP首部字段是由<strong>首部字段名</strong>和<strong>字段值</strong>构成的，中间用<strong>冒号<code>:</code>分隔</strong>，对于重复的HTTP首部字段，在规范内尚未明确，不同的浏览器内部处理逻辑不同；<strong>字段值</strong>对应单个HTTP首部字段<strong>可有多个值</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Keep-Alive</span>: timeout=15, max=100</span><br></pre></td></tr></table></figure><p>HTTP首部字段根据<strong>实际用途</strong>被分为以下<strong><code>4</code>种</strong>类型：</p><ul><li><strong>通用首部字段</strong>：请求报文和响应报文两方都会使用的首部</li><li><strong>请求首部字段</strong>：从客户端向服务器端发送请求报文时使用的首部，补充了请求附加内容、客户端信息、响应内容相关优先级等信息</li><li><strong>响应首部字段</strong>：从服务器端向客户端返回响应报文时使用的首部，补充了响应附加内容，也会要求客户端附加额外的内容信息</li><li><strong>实体首部字段</strong>：针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息</li></ul><p>HTTP首部字段将定义成<strong>缓存代理</strong>和<strong>非缓存代理</strong>的行为，分成2种类型：</p><ul><li><strong>端到端首部</strong>：此类别中的首部会转发给<strong>请求</strong>或<strong>响应</strong>对应<strong>最终接收目标</strong>，且<strong>必须保存在由缓存生成的响应中</strong>，且规定它必须被转发</li><li><strong>逐跳首部</strong>：此类别中的首部<strong>只对单次转发有效</strong>，会因通过缓存或代理而不再转发，HTTP/1.1和之后版本，若要使用逐跳首部需提供 Connection首部字段，只有以下8个字段属于逐跳首部：<ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade  </li></ul></li></ul><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><p>请求报文和响应报文双方都会使用的首部</p><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">控制缓存的行为</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Connection</td><td style="text-align:center">逐跳首部、连接的管理</td><td style="text-align:center">逐跳首部</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">创建报文的日期时间</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">报文指令</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Trailer</td><td style="text-align:center">报文末端的首部一览</td><td style="text-align:center">逐跳首部</td></tr><tr><td style="text-align:center">Transfer-Encoding</td><td style="text-align:center">指定报文主体的传输编码方式</td><td style="text-align:center">逐跳首部</td></tr><tr><td style="text-align:center">Upgrade</td><td style="text-align:center">升级为其他协议</td><td style="text-align:center">逐跳首部</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">代理服务器的相关信息</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">错误通知</td></tr></tbody></table><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>操作缓存的工作机制，多个指令之间通过<strong>逗号<code>,</code>分隔</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: private, max-age=0, no-cache</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">缓存请求指令</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">no-cache</td><td style="text-align:center">无</td><td style="text-align:center">强制向源服务器再次验证</td></tr><tr><td style="text-align:center">no-store</td><td style="text-align:center">无</td><td style="text-align:center">不缓存请求或响应的任何内容</td></tr><tr><td style="text-align:center">max-age = [ 秒]</td><td style="text-align:center">必需</td><td style="text-align:center">响应的最大Age值</td></tr><tr><td style="text-align:center">max-stale( = [ 秒])</td><td style="text-align:center">可省略</td><td style="text-align:center">接收已过期的响应</td></tr><tr><td style="text-align:center">min-fresh = [ 秒]</td><td style="text-align:center">必需</td><td style="text-align:center">期望在指定时间内的响应仍有效</td></tr><tr><td style="text-align:center">no-transform</td><td style="text-align:center">无</td><td style="text-align:center">代理不可更改媒体类型</td></tr><tr><td style="text-align:center">only-if-cached</td><td style="text-align:center">无</td><td style="text-align:center">从缓存获取资源</td></tr><tr><td style="text-align:center">cache-extension</td><td style="text-align:center">-</td><td style="text-align:center">新指令标记（token）</td></tr></tbody></table><table><thead><tr><th style="text-align:center">缓存响应指令</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">无</td><td style="text-align:center">可向任意方提供响应的缓存</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">可省略</td><td style="text-align:center">仅向特定用户返回响应</td></tr><tr><td style="text-align:center">no-cache</td><td style="text-align:center">可省略</td><td style="text-align:center">缓存前必须先确认其有效性</td></tr><tr><td style="text-align:center">no-store</td><td style="text-align:center">无</td><td style="text-align:center">不缓存请求或响应的任何内容</td></tr><tr><td style="text-align:center">no-transform</td><td style="text-align:center">无</td><td style="text-align:center">代理不可更改媒体类型</td></tr><tr><td style="text-align:center">must-revalidate</td><td style="text-align:center">无</td><td style="text-align:center">可缓存但必须再向源服务器进行确认</td></tr><tr><td style="text-align:center">proxy-revalidate</td><td style="text-align:center">无</td><td style="text-align:center">要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td style="text-align:center">max-age = [ 秒]</td><td style="text-align:center">必需</td><td style="text-align:center">响应的最大Age值</td></tr><tr><td style="text-align:center">s-maxage = [ 秒]</td><td style="text-align:center">必需</td><td style="text-align:center">公共缓存服务器响应的最大Age值</td></tr><tr><td style="text-align:center">cache-extension</td><td style="text-align:center">-</td><td style="text-align:center">新指令标记（token）</td></tr></tbody></table><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 使用public指令时，明确表明其他用户也可利用缓存</span><br><span class="line"><span class="attribute">Cache-Control</span>: public</span><br><span class="line"># 当指定private指令后，响应只以特定的用户作为对象，缓存服务器会对该特定用户提供资源缓存服务，对于其他用户发送的请求，代理服务器不会返回缓存</span><br><span class="line"><span class="attribute">Cache-Control</span>: private</span><br><span class="line"># no-cache指令的目的是为了防止从缓存中返回过期的资源，客户端将不会接收缓存过的响应，缓存服务器必须把客户端请求转发</span><br><span class="line">给源服务器，服务器返回响应中包含no-cache指令，则缓存服务器不能对资源进行缓存</span><br><span class="line"># 不缓存过期资源</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"># 由服务器返回的响应中，若对no-cache字段名具体指定参数值，客户端在接收到该被指定参数值的首部字段对应的响应报文后不能使用缓存，无参数值的首部字段可使用缓存，且只能在响应指令中指定该参数</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache=Location</span><br><span class="line"># 暗示请求或响应中包含机密信息，该指令规定缓存不能在本地存储请求或响应的任一部分，真正的不进行缓存</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"># 当客户端发送请求包含max-age指令时，若判定缓存资源的缓存时间数值比指定时间的数值更小，则客户端接收缓存的资源，当指定max-age值为0则缓存服务器通常需要将请求转发给源服务器</span><br><span class="line"># 当服务器返回响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长时间</span><br><span class="line"># HTTP/1.1在同时存在Expires首部字段时，会优先处理max-age指令，而忽略Expires首部字段，HTTP/1.0相反</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=604800（单位 ：秒）</span><br><span class="line"># 和max-age指令相同，s-maxage指令只适用于供多位用户使用的公共缓存服务器，使用s-maxage指令后，则直接忽略对Expires首部字段及</span><br><span class="line"><span class="attribute">max-age指令的处理</span></span><br><span class="line"><span class="attribute">Cache-Control</span>: s-maxage=604800（单位 ：秒）</span><br><span class="line"># 要求缓存服务器返回至少还未过指定时间的缓存资源，若min-fresh=60秒，则60秒后的资源无法作为响应返回</span><br><span class="line"><span class="attribute">Cache-Control</span>: min-fresh=60（单位 ：秒）</span><br><span class="line"># 指示缓存资源即使过期也照常接收，未指定参数值表示无论经过多久客户端都会接收响应，若指定了具体数值即使过期，只要仍处于max-stale指定时间内，仍旧会被客户端接收</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-stale=3600（单位 ：秒）</span><br><span class="line"># 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性</span><br><span class="line"># 若发生请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout</span><br><span class="line"><span class="attribute">Cache-Control</span>: only-if-cached</span><br><span class="line"># 代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效，若代理无法连通源服务器再次获取有效资源，则缓存必须给客户端一条 504状态码，且会忽略请求max-stale指令</span><br><span class="line"><span class="attribute">Cache-Control</span>: must-revalidate</span><br><span class="line"># 所有缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性</span><br><span class="line"><span class="attribute">Cache-Control</span>: proxy-revalidate</span><br><span class="line"># 无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型，可防止缓存或代理压缩图片等类似操作</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-transform</span><br><span class="line"># 通过cache-extension标记（token），可扩展Cache-Control首部字段内的指令，若缓存服务器不能理解community这个新指令，则会直接忽略，extension tokens仅对能理解它的缓存服务器有意义</span><br><span class="line"><span class="attribute">Cache-Control</span>: private, community="UCI"</span><br></pre></td></tr></table></figure><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p>Connection首部字段具备：<strong>控制不再转发给代理的首部字段</strong>，<strong>管理持久连接</strong>，<strong><code>HTTP/1.1</code></strong>版本的<strong>默认连接都是持久连接</strong>  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段</span><br><span class="line"><span class="attribute">Connection</span>: 不再转发的首部字段名</span><br><span class="line"># HTTP/1.1版本的默认连接都是持久连接，当服务器端想明确断开连接时，则指定Connection首部字段的值为Close</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"># HTTP/1.1之前的HTTP版本的默认连接都是非持久连接，若旧版本HTTP协议上维持持续连接，则需要指定Connection首部字段的值为Keep-Alive</span><br><span class="line"># 服务端加上首部字段Keep-Alive及首部字段Connection后返回响应</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br></pre></td></tr></table></figure><p><img src="../../../../../images/网络/HTTP/Connection_delete.png" alt></p><p><img src="../../../../../images/网络/HTTP/Connection_keep_alive.png" alt></p><h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><p>表明<strong>创建<code>HTTP</code>报文的日期和时间</strong>，HTTP/1.1协议使用在RFC1123中规定的日期时间的格式，之前的HTTP协议版本中使用在RFC850中定义的格式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HTTP/1.1</span><br><span class="line"><span class="attribute">Date</span>: Tue, 03 Jul 2012 04:40:59 GMT</span><br><span class="line"># 之前的HTTP协议版本</span><br><span class="line"><span class="attribute">Date</span>: Tue, 03-Jul-12 04:40:59 GMT</span><br><span class="line"># 还有一种格式，它与C标准库内的asctime()函数的输出格式一致</span><br><span class="line"><span class="attribute">Date</span>: Tue Jul 03 04:40:59 2012</span><br></pre></td></tr></table></figure><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma属于<strong>通用首部字段</strong>，只用在客户端发送的请求中，是<strong><code>HTTP/1.1</code></strong>之前版本的历史遗留字段，仅作为与HTTP/1.0的<strong>向后兼容而定义</strong>，<strong>客户端会要求所有的中间服务器不返回缓存的资源</strong>。</p><p>所有中间服务器若都能以HTTP/1.1为基准，那直接采用Cache-Control: no-cache指定缓存的处理方式即可，但要整体掌握全部中间服务器使用的HTTP协议版本是不现实的，因此发送的请求会同时含有下面两个首部字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><h5 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h5><p>事先说明<strong>在报文主体后记录了哪些首部字段</strong>，该首部字段可应用在<strong><code>HTTP/1.1</code></strong>版本<strong>分块传输编码时</strong>，如下指定首部字段Trailer的值为Expires，在报文主体之后即分块长度0之后出现了首部字段Expires：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Tue, 03 Jul 2012 04:40:56 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Trailer</span>: Expires</span><br><span class="line">...(报文主体)...</span><br><span class="line"><span class="attribute">0</span></span><br><span class="line"><span class="attribute">Expires</span>: Tue, 28 Sep 2004 23:59:59 GMT</span><br></pre></td></tr></table></figure><h5 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h5><p>规定了<strong>传输报文主体时采用的编码方式</strong>，<strong><code>HTTP/1.1</code></strong>的传输编码方式<strong>仅对分块传输编码有效</strong></p><h5 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h5><p><strong>用于检测HTTP协议及其他协议是否可使用更高的版本进行通信</strong>，其参数值<strong>可用来指定一个完全不同的通信协议</strong>，如下Connection的值被指定为Upgrade，则产生作用的Upgrade对象仅限于客户端和邻接服务器，使用Upgrade时还需额外指定<strong><code>Connection:Upgrade</code></strong>，对于附有Upgrade的请求，服务器可用<strong><code>101 Switching Protocols</code></strong>状态码作为响应返回：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.htm</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Upgrade</span>: TLS/1.0</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br></pre></td></tr></table></figure><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><p>用于<strong>追踪客户端与服务器之间</strong>请求和响应<strong>报文的传输路径</strong>，报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发，<strong>还可避免请求回环</strong>，也可增加1个新的Via首部写入服务器信息，<strong>经常会和<code>TRACE</code>方法一起使用</strong>，代理服务器接收到由TRACE方法发送过来的请求，当Max-Forwards为0时，代理服务器会将自身的信息附加到Via首部后，返回该请求的响应。</p><p><img src="../../../../../images/网络/HTTP/Via.png" alt></p><h5 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h5><p>HTTP/1.1的Warning首部是从HTTP/1.0的响应首部Retry-After演变过来的，该首部通常<strong>会告知用户一些与缓存相关的问题的警告</strong>，HTTP/1.1中定义了7种警告，且警告码具备扩展性</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 时间部分可省略</span><br><span class="line"><span class="attribute">Warning</span>: 113 gw.hackr.jp:8080 "Heuristic expiration" Tue, 03 Jul 2012 05:09:44 GMT</span><br><span class="line"><span class="attribute">Warning</span>: [警告码][警告的主机:端口号]"[警告内容]" ([日期时间])</span><br></pre></td></tr></table></figure><table><thead><tr><th>警告码</th><th>警告内容</th><th>说明</th></tr></thead><tbody><tr><td>110</td><td>Response is stale（响应已过期）</td><td>代理返回已过期的资源</td></tr><tr><td>111</td><td>Revalidation failed（再验证失败）</td><td>代理再验证资源有效性时失败（服务器无法到达等原因）</td></tr><tr><td>112</td><td>Disconnection operation（断开连接 操作）</td><td>代理与互联网连接被故意切断</td></tr><tr><td>113</td><td>Heuristic expiration（试探性过期）</td><td>响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</td></tr><tr><td>199</td><td>Miscellaneous warning（杂项警告）</td><td>任意的警告内容</td></tr><tr><td>214</td><td>Transformation applied（使用了转换）</td><td>代理对内容编码或媒体类型等执行了某些处理时</td></tr><tr><td>299</td><td>Miscellaneous persistent warning（持久杂项警告）</td><td>任意的警告内容</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><p>客户端往服务器端发送请求报文中所使用的字段，用于补充请求的<strong>附加信息</strong>、<strong>客户端信息</strong>、<strong>对响应内容相关的优先级</strong>等内容</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td><td></td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td><td></td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td><td></td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td><td></td></tr><tr><td>Authorization</td><td>Web认证信息</td><td></td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td><td></td></tr><tr><td>From</td><td>用户的电子邮箱地址</td><td></td></tr><tr><td>Host</td><td>请求资源所在服务器</td><td></td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td><td></td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td><td></td></tr><tr><td>If-None-Match</td><td>比较实体标记（与If-Match相反）</td><td></td></tr><tr><td>If-Range</td><td>资源未更新时发送实体Byte的范围请求</td><td></td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间（与If-Modified-Since相反）</td><td></td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td><td></td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td><td>逐跳首部</td></tr><tr><td>Range</td><td>实体的字节范围请求</td><td></td></tr><tr><td>Referer</td><td>对请求中URI的原始获取方</td><td></td></tr><tr><td>TE</td><td>传输编码的优先级</td><td>逐跳首部</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p>可通知服务器用户代理<strong>能够处理的媒体类型及媒体类型的相对优先级</strong>。 可使用<strong><code>type/subtype</code></strong>这种形式，一次指定多种媒体类型，若想要给显示的媒体类型增加优先级，则使用<strong><code>q=</code></strong>来额外表示<strong>权重</strong>值，用<strong>分号<code>;</code></strong>进行分隔，权重值<code>q</code>的范围是<strong><code>0~1</code></strong>，可精确到<strong>小数点后<code>3</code>位</strong>，<strong>默认权重为<code>q=1.0</code></strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure><ul><li>文本文件：text/html、text/plain、text/css等、application/xhtml+xml、application/xml等</li><li>图片文件：image/jpeg、image/gif、image/png等</li><li>视频文件：video/mpeg、video/quicktime等</li><li>应用程序使用的二进制文件：application/octet-stream、application/zip等</li></ul><h5 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h5><p>用来通知服务器用户代理支持的<strong>字符集</strong>及字符集的相对<strong>优先顺序</strong>，<strong>可一次性指定多种字符集</strong>，可用<strong>权重q值</strong>来表示<strong>相对优先级</strong>，该首部字段应用于<strong>内容协商机制</strong>的服务器驱动协商。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Charset</span>: iso-8859-5, unicode-1-1;q=0.8</span><br></pre></td></tr></table></figure><h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><p>用来告知服务器<strong>用户代理支持的内容编码及内容编码的优先级顺序</strong>，<strong>可一次性指定多种内容编码</strong>，采用<strong>权重q</strong>值来表示<strong>相对优先级</strong>，也可使用<strong>星号<code>*</code>作为通配符</strong>，指定<strong>任意</strong>的编码格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br></pre></td></tr></table></figure><ul><li><strong><code>gzip</code></strong>：由<strong>文件压缩程序<code>gzip</code>即<code>GNU zip</code></strong>生成的编码格式</li><li><strong><code>compress</code></strong>：由UNIX文件压缩程序<strong><code>compress</code></strong>生成的编码格式</li><li><strong><code>deflate</code></strong>：组合使用<strong><code>zlib</code></strong>格式及由<strong><code>deflate</code>压缩算法</strong>生成的编码格式</li><li><strong><code>identity</code></strong>：<strong>不执行压缩</strong>或<strong>不会变化的默认编码格式</strong></li></ul><h5 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h5><p>告知服务器用户代理<strong>能够处理</strong>的<strong>自然语言集</strong>，指中文或英文等，以及自然语言集的<strong>相对优先级</strong>，可一次指定多种自然语言集，按权重值q表示相对优先级</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Language</span>: zh-cn,zh;q=0.7,en-us,en;q=0.3</span><br></pre></td></tr></table></figure><h5 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h5><p>告知服务器用户代理的认证信息（证书值），通常想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Basic dWVub3NlbjpwYXNzd29yZA==</span><br></pre></td></tr></table></figure><p><img src="../../../../../images/网络/HTTP/Authorization.png" alt></p><h5 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h5><p>客户端使用Expect首部字段来告知服务器，<strong>期望出现的某种特定行为</strong>，因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码<strong><code>417 Expectation Failed</code></strong>，客户端可利用该首部字段，写明所期望的扩展</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 等待状态码100响应的客户端在发生请求时，需要指定</span><br><span class="line"><span class="attribute">Expect</span>: 100-continue</span><br></pre></td></tr></table></figure><h5 id="From"><a href="#From" class="headerlink" title="From"></a>From</h5><p>告知服务器使用用户代理的用户的电子邮件地址，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式，使用代理时，应尽可能包含From首部字段</p><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><p>告知服务器请求的资源所处的互联网主机名和端口号，Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段，Host和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，请求被发送至服务器时，请求中的主机名会用IP地址直接替换解决，相同的IP地址下部署运行着多个域名，则服务器无法理解是哪个域名对应的请求。则需要使用首部字段Host来明确指出请求的主机名，若服务器<strong>未设定主机名</strong>，则直接发送一个空值即可：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host:</span></span><br></pre></td></tr></table></figure><h5 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h5><p>形如<strong><code>If-xxx</code></strong>这种样式的请求首部字段，都可称为<strong>条件请求</strong>，服务器接收到附带条件的请求后，只有<strong>判断指定条件为真时</strong>才会执行请求，告知服务器匹配资源所用的<strong>实体标记<code>ETag</code></strong>值，此时服务器<strong>无法使用弱<code>ETag</code>值</strong>，服务器会比对If-Match字段值和资源ETag值，仅当两者一致才会执行请求，否则返回状态码<strong><code>412 Precondition Failed</code></strong>，还可用<strong>星号<code>*</code></strong>指定If-Match的字段值，此时服务器将会<strong>忽略<code>ETag</code>值</strong>，只要资源存在就处理请求。</p><p><img src="../../../../../images/网络/HTTP/If-Match.png" alt></p><h5 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h5><p><strong>用于确认代理或客户端拥有的本地资源的有效性</strong>，获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定，在If-Modified-Since字段指定的日期时间后资源发生了更新，服务器会接受请求，告知服务器<strong>若<code>If-Modified-Since</code>字段值早于资源的更新时间</strong>， 则希望能处理该请求，若在指定If-Modified-Since字段值的日期时间之后请求的资源都没有过更新，则返回状态码<strong><code>304 Not Modified</code></strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Modified-Since</span>: Thu, 15 Apr 2004 00:00:00 GMT</span><br></pre></td></tr></table></figure><h5 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h5><p><strong>与首部字段<code>If-Match</code>作用相反</strong>，用于指定If-None-Match字段值的实体标记ETag值与请求资源的ETag不一致时告知服务器处理该请求，在GET或HEAD方法中使用首部字段If-None-Match可获取最新的资源，这与使用首部字段<strong><code>If-Modified-Since</code></strong>时有些类似</p><h5 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h5><p>告知服务器若指定的If-Range字段值ETag值或者时间和请求资源的ETag值或时间一致时，则作为范围请求处理，反之则返回全体资源</p><h5 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h5><p>与首部字段If-Modified-Since的作用相反，告知服务器指定的请求资源只有在字段值内<strong>指定的日期时间之后未发生更新</strong>的情况下，才能处理请求，若在指定日期时间后发生了更新，则返回状态码<strong><code>412 Precondition Failed</code></strong>  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Unmodified-Since</span>: Thu, 03 Jul 2012 00:00:00 GMT</span><br></pre></td></tr></table></figure><h5 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h5><p><img src="../../../../../images/网络/HTTP/Max-Forwards.png" alt></p><p>通过TRACE方法或OPTIONS方 法，发送包含首部字段MaxForwards的请求时，该字段以十进制整数形式指定<strong>可经过的服务器最大数目</strong>，服务器在往下一个服务器转发请求之前<strong><code>Max-Forwards</code>值减<code>1</code>后重新赋值</strong>，当服务器接收到<strong>Max-Forwards值为<code>0</code></strong>的请求时，则不再进行转发，而是直接返回响应</p><h5 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h5><p>接收到从<strong>代理服务器</strong>发来的认证质询时，<strong>客户端</strong>会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息，该行为与客户端和服务器之间HTTP访问认证类似</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authorization</span>: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure><h5 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h5><p>只需获取部分资源的范围请求，告知服务器资源的指定范围，接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码为<strong><code>206 Partial Content</code></strong>，无法处理该范围请求时，则会返回状态码<strong><code>200 OK</code></strong>及<strong>全部资源</strong>。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Range</span>: bytes=5001-10000</span><br></pre></td></tr></table></figure><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><p>告知服务器请求的原始资源的URI，客户端一般都会发送Referer首部字段给服务器，但当直接在浏览器地址栏输入URI或出于安全性的考虑时，也可不发送该首部字段，因为原始资源的URI中查询字符串可能含有ID和密码等保密信息，写进Referer转发给其他服务器，可能导致保密信息泄露。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Referer</span>: http://www.hackr.jp/index.htm</span><br></pre></td></tr></table></figure><h5 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h5><p>告知服务器客户端能够处理响应的<strong>传输编码方式及相对优先级</strong>，与<strong>首部字段<code>Accept-Encoding</code>功能相似</strong>，但用于<strong>传输编码</strong>，还可指定伴随<strong><code>trailer</code>字段的分块传输编码的方式</strong>，应用后者时只需把trailers赋值给该字段值  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">TE</span>: gzip, deflate;q=0.5</span><br><span class="line"><span class="attribute">TE</span>: trailers</span><br></pre></td></tr></table></figure><h5 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h5><p>将创建请求的<strong>浏览器</strong>和<strong>用户代理名称</strong>等信息传达给服务器</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1</span><br></pre></td></tr></table></figure><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的<strong>附加信息</strong>、<strong>服务器信息</strong>，以及<strong>对客户端的附加要求</strong>等信息</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td><td></td></tr><tr><td>Age</td><td>推算资源创建经过时间</td><td></td></tr><tr><td>ETag</td><td>资源的匹配信息</td><td></td></tr><tr><td>Location</td><td>令客户端重定向至指定URI</td><td></td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td><td>逐跳首部</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td><td></td></tr><tr><td>Server</td><td>HTTP服务器的安装信息</td><td></td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td><td></td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h5 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h5><p><strong>告知客户端服务器是否能处理范围请求</strong>，以指定获取服务器端某个部分的资源</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 不能处理范围请求时</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: none</span><br><span class="line"># 能处理范围请求时</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br></pre></td></tr></table></figure><h5 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h5><p><strong>告知客户端源服务器在多久前创建了响应</strong>，若创建该响应的服务器是缓存服务器，则Age值是指缓存后的响应再次发起认证到认证完成的时间值，代理创建响应时必须加上首部字段Age</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 单位为秒</span><br><span class="line"><span class="attribute">Age</span>: 600</span><br></pre></td></tr></table></figure><h5 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h5><p><strong>告知客户端实体标识</strong>，它是一种可将资源以字符串形式做唯一性标识的方式，服务器会为每份资源分配对应的ETag值，当资源更新时ETag值也需要更新，生成ETag值时并没有统一算法规则，而仅仅是由服务器来分配</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: "82e22293907ce725faf67773957acd12"</span><br><span class="line"><span class="attribute">ETag</span>: W/"usagi-1234"</span><br></pre></td></tr></table></figure><p>资源被缓存时，就会被分配唯一标识，对于同一URI资源中文版和英文版对应资源是不同的，但两者的URI相同仅凭URI指定缓存资源相当困难，若下载过程中出现连接中断、再连接的情况，都会依照ETag值来指定资源，且<strong><code>ETag</code>值有强弱之分</strong>，<strong>强<code>ETag</code>值</strong>不论实体发生多么细微的变化都会改变其值，<strong>弱<code>ETag</code>值</strong>只用于提示资源是否相同，只有资源发生了根本改变，产生差异时才会改变ETag值，此时会在字段值最开始处附加<strong><code>W/</code></strong>。</p><h5 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h5><p><strong>将响应接收方引导至某个与请求URI位置不同的资源</strong>，该字段会配合<strong><code>3xx：Redirection</code></strong>响应提供重定向URI，几乎所有浏览器在接收到包含Location首部字段的响应后，都会强制性地尝试对已提示的重定向资源的访问</p><p><img src="../../../../../images/网络/HTTP/Location.png" alt></p><h5 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h5><p><strong>把由代理服务器所要求的认证信息发送给客户端</strong>，与客户端和服务器之间的HTTP访问认证行为相似，不同之处在于其认证行为是在客户端与代理之间进行的，客户端与服务器之间进行认证时，首部字段WWW-Authorization有着相同的作用</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authenticate</span>: Basic realm="Usagidesign Auth"</span><br></pre></td></tr></table></figure><h5 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h5><p><strong>告知客户端应该在多久之后再次发送请求</strong>，主要配合状态码<strong><code>503 Service Unavailable</code></strong>、<strong><code>3xx Redirec</code></strong>t响应一起使用</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 120秒后再发起请求</span><br><span class="line"><span class="attribute">Retry-After</span>: 120</span><br><span class="line"># 指定为具体的日期时间</span><br><span class="line"><span class="attribute">Retry-After</span>: Wed,04 Jul 2022 06:34:24 GMT</span><br></pre></td></tr></table></figure><h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p>告知客户端当前服务器上安装的HTTP服务器应用程序的信息，还有可能包括版本号和安装时启用的可选项</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Server</span>: Apache/2.2.17 (Unix)</span><br></pre></td></tr></table></figure><h5 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h5><p><strong>可对缓存进行控制</strong>，源服务器会向代理服务器传达关于本地缓存使用方法的命令，从代理服务器接收到源服务器返回包含Vary指定项的响应后，若再要进行缓存，仅对请求中含有相同Vary指定首部字段的请求返回缓存，即使对相同资源发起请求，但由于Vary指定的首部字段不相同，也必须要从源服务器重新获取资源</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Vary</span>: Accept-Language</span><br></pre></td></tr></table></figure><p><img src="../../../../../images/网络/HTTP/Vary.png" alt></p><h5 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h5><p>用于HTTP访问认证，告知客户端适用于访问请求URI所指定资源的认证方案如<strong><code>Basic</code></strong>、<strong><code>Digest</code></strong>、带参数提示的质询<strong><code>challenge</code></strong>等，状态码<strong><code>401 Unauthorized</code></strong>响应中肯定带有首部字段<strong><code>WWW-Authenticate</code></strong>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># realm字段的字符串是为了辨别请求URI指定资源所受到的保护策略</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm="Usagidesign Auth"</span><br></pre></td></tr></table></figure><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><p>包含在<strong>请求报文</strong>和<strong>响应报文</strong>中的<strong>实体部分</strong>所使用的首部，用于补充<strong>内容的更新时间</strong>等与实体相关的信息</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的HTTP方法</td><td></td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td><td></td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td><td></td></tr><tr><td>Content-Length</td><td>实体主体的大小（单位 ：字节）</td><td></td></tr><tr><td>Content-Location</td><td>替代对应资源的URI</td><td></td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td><td></td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td><td></td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td><td></td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td><td></td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h5 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h5><p>用于通知客户端能够支持Request-URI指定资源的所有HTTP方法，当服务器接收到不支持的HTTP方法时，会以状态码<strong><code>405 Method Not Allowed</code></strong>作为响应返回，同时把所有能支持的HTTP方法写入首部字段Allow后返回</p><p><img src="../../../../../images/网络/HTTP/Allow.png" alt></p><h5 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h5><p>告知客户端服务器<strong>对实体的主体部分选用的内容编码方式</strong>，指在不丢失实体信息的前提下所进行的压缩，支持的四种编码方式：<strong><code>gzip</code></strong>、<strong><code>compress</code></strong>、<strong><code>deflate</code></strong>、<strong><code>identity</code></strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br></pre></td></tr></table></figure><h5 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h5><p>告知客户端<strong>实体主体使用的自然语言</strong>，如中文、英语等</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Language</span>: zh-CN</span><br></pre></td></tr></table></figure><h5 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h5><p><strong>表明实体主体部分的大小</strong>，单位是<strong>字节</strong>，对实体主体进行内<strong>容编码传输时</strong>，<strong>不能</strong>再使用<strong><code>Content-Length</code></strong>首部字段，因为实体主体大小的<strong>计算方法略微复杂</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span>: 15000</span><br></pre></td></tr></table></figure><h5 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h5><p>给出与<strong>报文主体部分相对应的URI</strong>，和首部字段Location不同，Content-Location表示的是报文主体返回资源对应的URI，如使用<strong><code>Accept-Language</code></strong>的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段<strong><code>Content-Location</code></strong>内会写明URI</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Location</span>: http://www.hackr.jp/index-ja.html</span><br></pre></td></tr></table></figure><h5 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h5><p>客户端会对接收的报文主体执行相同的MD5算法，然后与首部字段Content-MD5的字段值比较，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 对报文主体执行MD5算法获得的128位二进制数，再通过Base64编码后将结果写入Content-MD5字段值</span><br><span class="line"><span class="attribute">Content-MD5</span>: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure><h5 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h5><p><strong>针对范围请求</strong>返回响应时使用的首部字段Content-Range告知客户端作为响应返回的实体的哪个部分符合范围请求，<strong>单位字节</strong>，表示<strong>当前发送部分及整个实体大小</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p>说明<strong>实体主体内对象的媒体类型</strong>，和首部字段Accept一样，字段值用type/subtype形式赋值，charset使用iso-8859-1或euc-jp等字符集进行赋值</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><strong>将资源失效的日期告知客户端</strong>，Expires字段值指定的时间之前，响应的副本会一直被缓存服务器保存，当超过指定时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。源服务器<strong>不希望缓存服务器对资源缓存</strong>时，最好<strong>在Expires字段内写入与首部字段Date相同的时间值</strong>，当首部字段<strong><code>Cache-Control</code></strong>有指定<strong><code>max-age</code></strong>指令时，会<strong>优先处理<code>max-age</code>指令</strong>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><h5 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h5><p><strong>指明资源最终修改的时间</strong>，一般该值是Request-URI指定资源被修改的时间，但类似使用CGI脚本进行动态数据处理时，该值可能会变成数据最终修改时的时间</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span>: Wed, 23 May 2012 09:59:55 GMT</span><br></pre></td></tr></table></figure><h5 id="Cookie首部字段"><a href="#Cookie首部字段" class="headerlink" title="Cookie首部字段"></a>Cookie首部字段</h5><p>Cookie的工作机制是<strong>用户识别及状态管理</strong>，Web 网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内，当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie，调用Cookie时，可校验Cookie的有效期、发送方的域、路径、协议等信息</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的Cookie信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的Cookie信息</td><td>请求首部字段</td></tr></tbody></table><h5 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h5><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息，一旦Cookie从服务器端发送至客户端，服务器端就不存在可显式删除Cookie的方法，但可通过覆盖已过期Cookie实现对客户端Cookie的实质性删除操作</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;</span><br><span class="line"><span class="attribute">Set-Cookie</span>: name=value; secure</span><br><span class="line"><span class="attribute">Set-Cookie</span>: name=value; HttpOnly</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予Cookie的名称和其值（必需项）</td><td></td></tr><tr><td>expires=DATE</td><td>Cookie的有效期（若不明确指定则<strong>默认为浏览器关闭前为止</strong>）</td><td>浏览器可发送Cookie的有效期</td></tr><tr><td>path=PATH</td><td>将<strong>服务器上的文件目录</strong>作为Cookie的适用对象（若不指定则<strong>默认为文档所在的文件目录</strong>）</td><td>用于限制指定Cookie发送范围的文件目录</td></tr><tr><td>domain=域名</td><td>作为Cookie适用对象的域名 （若不指定则<strong>默认为创建Cookie的服务器的域名</strong>）</td><td>不指定domain属性显得更安全</td></tr><tr><td>Secure</td><td><strong>仅在HTTPS安全通信时才会发送Cookie</strong></td><td></td></tr><tr><td>HttpOnly</td><td>加以限制，<strong>使Cookie不能被JavaScript脚本访问</strong></td><td>为防止跨站脚本攻击对Cookie信息窃取</td></tr></tbody></table><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>告知服务器当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie，接收到多个Cookie时，同样可以多个Cookie形式发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: status=enable</span><br></pre></td></tr></table></figure><h4 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h4><h5 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h5><p>属于HTTP响应首部，<strong>用于控制网站内容在其他Web网站的<code>Frame</code>标签内的显示问题</strong>，其主要目的是为了<strong>防止点击劫持<code>clickjacking</code>攻击</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># DENY：拒绝</span><br><span class="line"><span class="attribute">X-Frame-Options</span>: DENY</span><br><span class="line"># SAMEORIGIN：仅同源域名下的页面匹配时许可</span><br><span class="line"><span class="attribute">X-Frame-Options</span>: SAMEORIGIN</span><br></pre></td></tr></table></figure><h5 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h5><p>属于HTTP响应首部，<strong>针对跨站脚本攻击<code>XSS</code>的一种对策</strong>，用于控制浏览器XSS防护机制的开关</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 0：将XSS过滤设置成无效状态</span><br><span class="line"># 1：将XSS过滤设置成有效状态</span><br><span class="line"><span class="attribute">X-XSS-Protection</span>: 1</span><br></pre></td></tr></table></figure><h5 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h5><p>属于HTTP请求首部，<strong>拒绝个人信息被收集</strong>，是表示拒绝被精准广告追踪的一种方法</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 0：同意被追踪；1：拒绝被追踪</span><br><span class="line"><span class="attribute">DNT</span>: 1</span><br></pre></td></tr></table></figure><h5 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h5><p>属于HTTP响应首部，通过利用P3P在线隐私偏好平台技术，让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私目的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P3P</span>: CP="CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND UNI COM NAV INT"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由&lt;strong&gt;欧洲孩子研究组织CERN&lt;/strong&gt;的&lt;strong&gt;蒂姆伯纳斯李&lt;/strong&gt;博士提出的一种能让远隔两地的研究者们共享知识的设想，最初设想的基本理念是，&lt;strong&gt;借助多文档之间的相互关联形成的超文本&lt;/strong&gt;，连成可相互参阅的WW
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="协议族" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="网络" scheme="https://yaoyinglong.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Nacos问题总结</title>
    <link href="https://yaoyinglong.github.io/Blog/Cloud/Nacos/Nacos%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Cloud/Nacos/Nacos问题总结/</id>
    <published>2022-05-15T16:00:00.000Z</published>
    <updated>2022-05-17T13:20:18.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务启动注册成功隔段时间被踢掉"><a href="#服务启动注册成功隔段时间被踢掉" class="headerlink" title="服务启动注册成功隔段时间被踢掉"></a>服务启动注册成功隔段时间被踢掉</h3><p>使用的Nacos版本为1.2.1，服务启动时能正常注册到Nacos上，说明服务是能连上Nacos的，隔段时间被踢掉，很明显是因为Nacos的心跳机制，说明Nacos服务端未收到客户端发送的心跳</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nacos客户端心跳任务的创建是通过服务启动时，调用<strong><code>NamingService</code></strong>的<strong><code>registerInstance</code></strong>注册服务时调用BeatReactor的addBeatInfo方法完成的心跳任务创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosNamingService</span> <span class="keyword">implements</span> <span class="title">NamingService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            BeatInfo beatInfo = <span class="keyword">new</span> BeatInfo();</span><br><span class="line">            beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));</span><br><span class="line">            beatInfo.setIp(instance.getIp());</span><br><span class="line">            beatInfo.setPort(instance.getPort());</span><br><span class="line">            beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">            beatInfo.setWeight(instance.getWeight());</span><br><span class="line">            beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">            beatInfo.setScheduled(<span class="keyword">false</span>);</span><br><span class="line">            beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line">            <span class="keyword">this</span>.beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.serverProxy.registerService(NamingUtils.getGroupedName(serviceName, groupName), groupName, instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeatReactor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeatInfo</span><span class="params">(String serviceName, BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">        LogUtils.NAMING_LOGGER.info(<span class="string">"[BEAT] adding beat: &#123;&#125; to beat map."</span>, beatInfo);</span><br><span class="line">        String key = <span class="keyword">this</span>.buildKey(serviceName, beatInfo.getIp(), beatInfo.getPort());</span><br><span class="line">        BeatInfo existBeat = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((existBeat = (BeatInfo)<span class="keyword">this</span>.dom2Beat.remove(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            existBeat.setStopped(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dom2Beat.put(key, beatInfo);</span><br><span class="line">        <span class="keyword">this</span>.executorService.schedule(<span class="keyword">new</span> BeatReactor.BeatTask(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">        MetricsMonitor.getDom2BeatSizeMonitor().set((<span class="keyword">double</span>)<span class="keyword">this</span>.dom2Beat.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终周期执行BeatTask心跳任务从而完成客户端向Nacos服务端发送心跳任务，该问题是因为在解析服务端响应的心跳内容时报错了，是由于这里使用的<strong><code>FastJson</code></strong>报错从而导致的该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeatReactor</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        BeatInfo beatInfo;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BeatTask</span><span class="params">(BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beatInfo = beatInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.beatInfo.isStopped()) &#123;</span><br><span class="line">                <span class="keyword">long</span> nextTime = <span class="keyword">this</span>.beatInfo.getPeriod();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    JSONObject result = BeatReactor.<span class="keyword">this</span>.serverProxy.sendBeat(<span class="keyword">this</span>.beatInfo, BeatReactor.<span class="keyword">this</span>.lightBeatEnabled);</span><br><span class="line">                    <span class="keyword">long</span> interval = (<span class="keyword">long</span>)result.getIntValue(<span class="string">"clientBeatInterval"</span>);</span><br><span class="line">                    <span class="keyword">boolean</span> lightBeatEnabled = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (result.containsKey(<span class="string">"lightBeatEnabled"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 报错行</span></span><br><span class="line">                        lightBeatEnabled = result.getBooleanValue(<span class="string">"lightBeatEnabled"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeatReactor.<span class="keyword">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">                    <span class="keyword">if</span> (interval &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                        nextTime = interval;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> code = <span class="number">10200</span>;</span><br><span class="line">                    <span class="keyword">if</span> (result.containsKey(<span class="string">"code"</span>)) &#123;</span><br><span class="line">                        code = result.getIntValue(<span class="string">"code"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (code == <span class="number">20404</span>) &#123;</span><br><span class="line">                        Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                        instance.setPort(<span class="keyword">this</span>.beatInfo.getPort());</span><br><span class="line">                        instance.setIp(<span class="keyword">this</span>.beatInfo.getIp());</span><br><span class="line">                        instance.setWeight(<span class="keyword">this</span>.beatInfo.getWeight());</span><br><span class="line">                        instance.setMetadata(<span class="keyword">this</span>.beatInfo.getMetadata());</span><br><span class="line">                        instance.setClusterName(<span class="keyword">this</span>.beatInfo.getCluster());</span><br><span class="line">                        instance.setServiceName(<span class="keyword">this</span>.beatInfo.getServiceName());</span><br><span class="line">                        instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                        instance.setEphemeral(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            BeatReactor.<span class="keyword">this</span>.serverProxy.registerService(<span class="keyword">this</span>.beatInfo.getServiceName(), NamingUtils.getGroupName(<span class="keyword">this</span>.beatInfo.getServiceName()), instance);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException var11) &#123;</span><br><span class="line">                    LogUtils.NAMING_LOGGER.error(<span class="string">"[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;"</span>, <span class="keyword">new</span> Object[]&#123;JSON.toJSONString(<span class="keyword">this</span>.beatInfo), var11.getErrCode(), var11.getErrMsg()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                BeatReactor.<span class="keyword">this</span>.executorService.schedule(BeatReactor.<span class="keyword">this</span>.<span class="keyword">new</span> BeatTask(<span class="keyword">this</span>.beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Debug可以很明显的看到是因为FastJson在初始化的时候找不到<strong><code>IdentityHashMap</code></strong>类导致的</p><p><img src="../../../../../images/Cloud/Nacos/Nacos问题-FastJson导致的心跳异常.png" alt="FastJson导致的心跳异常"></p><p>经排查发现，由于<strong><code>IdentityHashMap</code></strong>存在漏洞，在FastJson高版本中将该类移除掉了，这里使用的是<strong><code>FastJson 2.0.2</code></strong>版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决办法：一可以<strong>降低FastJson的版本</strong>，二<strong>升级Nacos版本</strong>，在<strong><code>Nacos 1.3.1</code></strong>及之后的版本中为了解决该bug，在心跳检测任务这里未再使用<strong><code>FastJson</code></strong>，而是使用的而<strong><code>jackson</code></strong>，从而避免了该bug的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeatReactor</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        BeatInfo beatInfo;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BeatTask</span><span class="params">(BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beatInfo = beatInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> nextTime = beatInfo.getPeriod();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JsonNode result = serverProxy.sendBeat(beatInfo, BeatReactor.<span class="keyword">this</span>.lightBeatEnabled);</span><br><span class="line">                <span class="keyword">long</span> interval = result.get(<span class="string">"clientBeatInterval"</span>).asLong();</span><br><span class="line">                <span class="keyword">boolean</span> lightBeatEnabled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                    lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">                &#125;</span><br><span class="line">                BeatReactor.<span class="keyword">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">                <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nextTime = interval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> code = NamingResponseCode.OK;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                    code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                    Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                    instance.setPort(beatInfo.getPort());</span><br><span class="line">                    instance.setIp(beatInfo.getIp());</span><br><span class="line">                    instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                    instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                    instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                    instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                    instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                    instance.setEphemeral(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                                                    NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">"[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;"</span>,</span><br><span class="line">                                    JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line">            &#125;</span><br><span class="line">            executorService.schedule(<span class="keyword">new</span> BeatTask(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务启动注册成功隔段时间被踢掉&quot;&gt;&lt;a href=&quot;#服务启动注册成功隔段时间被踢掉&quot; class=&quot;headerlink&quot; title=&quot;服务启动注册成功隔段时间被踢掉&quot;&gt;&lt;/a&gt;服务启动注册成功隔段时间被踢掉&lt;/h3&gt;&lt;p&gt;使用的Nacos版本为1.2.1，服
      
    
    </summary>
    
      <category term="Cloud" scheme="https://yaoyinglong.github.io/categories/Cloud/"/>
    
      <category term="Nacos" scheme="https://yaoyinglong.github.io/categories/Cloud/Nacos/"/>
    
    
      <category term="SpringCloud" scheme="https://yaoyinglong.github.io/tags/SpringCloud/"/>
    
      <category term="Nacos" scheme="https://yaoyinglong.github.io/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>面试要点精简</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E7%B2%BE%E7%AE%80/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/面试要点精简/</id>
    <published>2022-03-31T16:00:00.000Z</published>
    <updated>2022-04-01T15:29:05.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><strong>快</strong>：完全基于内存操作，C语言实现对几种基础数据结构做了大量的优化，使用单线程无上下文的切换成本，基于非阻塞的IO多路复用机制，内存预分配，渐进式rehash，记录长度<br><strong>单线程</strong>：网络IO和键值对读写，耗时的指令如keys可能会导致Redis卡顿<br><strong>多线程</strong>：持久化、异步删除、集群数据同步<br><strong>IO多路复用</strong>：连接信息和事件，依次放到文件事件分派器，再将事件分发给事件处理器<br><strong><code>6.0+</code></strong>：多线程来处理数据读写和协议解析，性能瓶颈在于网络IO而非CPU<br><strong>应用场景</strong>：计数器、分布式ID生成、海量数据统计、Session共享、分布式队列、阻塞队列、分布式锁、热点数据存储、社交需求（共同好友、好友推荐）、排行榜、ZSet延迟队列</p><p>RedisDB、dict、dictht、dictEntity、redisObject<br><strong>动态简单字符串SDS</strong>：记录长度、内存预分配两倍扩容（&lt;1M）、兼容\0</p><p><strong>字符串</strong>：int（利用redisObject ptr指针）、embstr（利用缓存行64-16-4=44）、row（普通SDS）<br><strong>list</strong>：quicklist双向无环链表结构（节点为ziplist、单个ziplist节点最大能存储8kb，超过将分裂）<br><strong>hash</strong>：ziplist（个数&lt;255，单个小于64byte）、hashtable<br><strong>set</strong>：intset（能用int表示，且个数小于512）、hashtable<br><strong>zset</strong>：ziplist（个数小于128，单个小于64byte）、skiplist（头结点ziplist、zskiplistNode跳表节点）；不用红黑树因为跳表实现更简单、红黑树插入删除时需要rebalance，红黑树在查找区间元素的效率没有跳表高<br>GeoHash、BitMap</p><p><strong>持久化</strong>：RDB快照、AOF、混合持久化<br><strong>RDB快照</strong>：N秒内数据集至少有M个改动，可手动bgsave或save、体积小、恢复快、容易丢数据<br><strong>AOF</strong>：修改的每一条指令、appendonly yes开启AOF、appendfsync（always每次、everysec每秒）,可配置达到64M重写或增长100%重写，从节点和主节点间会建立Socket长连接</p><p>min-replicas-to-write 1 写数据成功最少同步的slave数量<br>maxclients 10000 最大连接数<br>maxmemory 0 最大可使用内存值byte，默认0不限制</p><p><strong>maxmemory_policy noeviction</strong> 当达到maxmemory时的淘汰策略<br><strong>volatile-lru</strong>：从已设置过期时间的key中，移出最久未被使用的key进行淘汰<br><strong>volatile-ttl</strong>：从已设置过期时间的key中，根据过期时间的先后进行删除，越早过期的越先被删除<br><strong>volatile-random</strong>：从已设置过期时间的key中，随机选择key淘汰<br><strong>volatile-lfu</strong>：设置了过期时间的键值对删除最近一段时间被访问次数最少的数据<br><strong>allkeys-lru</strong>：从所有key中选择最近最少使用的进行淘汰<br><strong>allkeys-random</strong>：从所有key中随机选择key进行淘汰<br><strong>allkeys-lfu</strong>：所有数据中进行筛选删除最近一段时间被访问次数最少的数据<br><strong>noeviction</strong>：当内存达到阈值的时候，新写入操作报错</p><p><strong>缓存击穿</strong>：空对象，缓存空对象或Bloom过滤器+白名单+黑名单<br><strong>缓存失效</strong>：大批量缓存在同一时间失效，在一个基础时间上加一个随机时间<br><strong>缓存雪崩</strong>：事前：保证缓存层服务高可用性、事中：后端限流熔断并降级，事后：开启Redis持久化机制</p><p><strong>红锁</strong>：一般5个</p><p><strong>哨兵</strong>：监控redis实例节点，client第一次从哨兵找出redis的主节点，后续直接访问主节点，主节点发生变化将新的redis主节点通知给client端，但有一定延时，性能和高可用性等各方面表现一般，主从切换瞬间存在访问瞬断情况</p><p><strong>集群</strong>：复制、高可用和分片特性，至少三个master主节点，没有中心节点可水平扩展，性能和高可用性均优于哨兵模式，16384个slots槽位，槽位的信息可能存在客户端与服务器不一致跳转重定向，key前面加上{XX}</p><p><strong>数据丢失</strong>：min-replicas-to-write 1 写数据成功最少同步的slave数量</p><p>若master收到了多个slave从节点并发连接请求，它只会进行一次持久化，master中缓存队列，缓存最近一段时间的数据，主节点和它所有从节点都维护了复制数据下标offset和master进程id，当网络连接断开后，slave从节点会请求master主节点从所记录的数据下标开始继续进行未完成的复制。若master主节点进程id变化，或slave从节点数据下标offset太旧超出master主节点缓存队列，则将进行一次全量数据复制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;快&lt;/strong&gt;：完全基于内存操作，C语言实现对几种基础数据结构做了大量的优化，使用单线程无上下
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>经典算法-动态规划</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/经典算法-动态规划/</id>
    <published>2022-03-28T16:00:00.000Z</published>
    <updated>2022-03-29T11:07:48.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p>非负整数数组nums，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度，使用最少的跳跃次数到达数组的最后一个位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxPosition = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        maxPosition = Math.max(maxPosition, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            end = maxPosition;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>整数数组coins表示不同面额的硬币，整数amount表示总金额，计算并返回可凑成总金额所需最少的硬币个数，若没有任何一种硬币组合能组成总金额返回-1，可认为每种硬币的数量是无限的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>], prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        prevMax = Math.max(nums[i], prevMax + nums[i]);</span><br><span class="line">        max = Math.max(max, prevMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><h5 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> leftIndex = <span class="number">1</span>, rightIndex = height.length - <span class="number">2</span>; leftIndex &lt; height.length &amp;&amp; rightIndex &gt; -<span class="number">1</span>; leftIndex++, rightIndex--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[leftIndex]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = left + <span class="number">1</span>; k &lt; leftIndex; k++) &#123;</span><br><span class="line">                res += height[left] - height[k];</span><br><span class="line">            &#125;</span><br><span class="line">            left = leftIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height[right] &lt; height[rightIndex]) &#123; <span class="comment">// 等于的情况只能有一个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = right - <span class="number">1</span>; k &gt; rightIndex; k--) &#123;</span><br><span class="line">                res += height[right] - height[k];</span><br><span class="line">            &#125;</span><br><span class="line">            right = rightIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap2</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    rightMax[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">1</span>, right = len - <span class="number">2</span>; left &lt; len || right &gt; -<span class="number">1</span>; left++, right--) &#123;</span><br><span class="line">        leftMax[left] = Math.max(leftMax[left - <span class="number">1</span>], height[left]);</span><br><span class="line">        rightMax[right] = Math.max(rightMax[right + <span class="number">1</span>], height[right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap3</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            res += leftMax - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += rightMax - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h3><p>未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度</p><h5 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, i - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] minF = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] maxF = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    minF[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    maxF[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        maxF[i] = Math.max(maxF[i - <span class="number">1</span>] * nums[i], Math.max(minF[i - <span class="number">1</span>] * nums[i], nums[i]));</span><br><span class="line">        minF[i] = Math.min(minF[i - <span class="number">1</span>] * nums[i], Math.min(maxF[i - <span class="number">1</span>] * nums[i], nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        max = Math.max(maxF[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;跳跃游戏&quot;&gt;&lt;a href=&quot;#跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;跳跃游戏&quot;&gt;&lt;/a&gt;跳跃游戏&lt;/h3&gt;&lt;p&gt;非负整数数组nums，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度，使用最少的跳跃次数到达数组的
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法-栈</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E6%A0%88/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/经典算法-栈/</id>
    <published>2022-03-28T16:00:00.000Z</published>
    <updated>2022-03-29T06:09:47.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h5 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h5><p>给定整数数组temperatures表示每天温度，返回一个数组answer，answer[i]是指在第i天之后，才会有更高的温度。若气温在这之后都不会升高，则在该位置用0来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temperature = temperatures[i];</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">            res[prevIndex] = i - prevIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, i - stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单调栈&quot;&gt;&lt;a href=&quot;#单调栈&quot; class=&quot;headerlink&quot; title=&quot;单调栈&quot;&gt;&lt;/a&gt;单调栈&lt;/h3&gt;&lt;h5 id=&quot;每日温度&quot;&gt;&lt;a href=&quot;#每日温度&quot; class=&quot;headerlink&quot; title=&quot;每日温度&quot;&gt;&lt;/a&gt;每日温
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法-链表</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/经典算法-链表/</id>
    <published>2022-03-28T16:00:00.000Z</published>
    <updated>2022-03-29T06:06:56.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pA = headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123; <span class="comment">// 链表遍历两次长度是一样的</span></span><br><span class="line">        pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表两辆交换"><a href="#链表两辆交换" class="headerlink" title="链表两辆交换"></a>链表两辆交换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode preHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), curr = preHead;</span><br><span class="line">    preHead.next = head;</span><br><span class="line">    <span class="keyword">while</span> (curr.next != <span class="keyword">null</span> &amp;&amp; curr.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node1 = curr.next;</span><br><span class="line">        ListNode node2 = curr.next.next;</span><br><span class="line">        curr.next = node2;</span><br><span class="line">        node1.next = node2.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        curr = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairsV2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = head.next;</span><br><span class="line">    head.next = swapPairsV2(newHead.next);</span><br><span class="line">    newHead.next = head;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表倒数第N个节点"><a href="#删除链表倒数第N个节点" class="headerlink" title="删除链表倒数第N个节点"></a>删除链表倒数第N个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    ListNode ans = dummy.next;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nth = removeNthFromEndDfs(head, head.next, n);</span><br><span class="line">    <span class="keyword">return</span> nth &gt; <span class="number">1</span> ? head.next : head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeNthFromEndDfs</span><span class="params">(ListNode before, ListNode curr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nth = removeNthFromEndDfs(curr, curr.next, n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nth == <span class="number">1</span>) &#123;</span><br><span class="line">        before.next = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">iterate</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>, curr, next;</span><br><span class="line">    curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = curr.next; <span class="comment">// 将下一个节点指针保存到next变量 next = curr.next</span></span><br><span class="line">        curr.next = prev; <span class="comment">// 将下一个节点的指针指向prev，curr.next = prev</span></span><br><span class="line">        prev = curr;<span class="comment">// 准备处理下一个节点，将curr赋值给prev</span></span><br><span class="line">        curr = next;<span class="comment">// 将下一个节点赋值为curr，处理一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">recursion</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为了保证链不断，必须从最后一个元素开始</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = recursion(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>判断链表中是否有环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; seen = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!seen.add(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相交链表&quot;&gt;&lt;a href=&quot;#相交链表&quot; class=&quot;headerlink&quot; title=&quot;相交链表&quot;&gt;&lt;/a&gt;相交链表&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/经典算法/</id>
    <published>2022-02-25T16:00:00.000Z</published>
    <updated>2022-03-29T06:11:05.076Z</updated>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>给定一个字符串<code>s</code> 、一个字符串<code>t</code>，返回<code>s</code>中涵盖<code>t</code>所有字符的最小子串，若<code>s</code>中不存在涵盖<code>t</code>所有字符的子串，则返回空字符串<code>&quot;&quot;</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;Character, Integer&gt; has = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        need.put(t.charAt(i), need.getOrDefault(t.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ansLen = Integer.MAX_VALUE, ansL = -<span class="number">1</span>, ansR = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; s.length() &amp;&amp; need.containsKey(s.charAt(r))) &#123;</span><br><span class="line">            has.put(s.charAt(r), has.getOrDefault(s.charAt(r), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; ansLen) &#123;</span><br><span class="line">                ansLen = r - l + <span class="number">1</span>;</span><br><span class="line">                ansL = l;</span><br><span class="line">                ansR = l + ansLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(s.charAt(l))) &#123;</span><br><span class="line">                has.put(s.charAt(l), has.getOrDefault(s.charAt(l), <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansL == -<span class="number">1</span> ? <span class="string">""</span> : s.substring(ansL, ansR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Character key : need.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (has.getOrDefault(key, <span class="number">0</span>) &lt; need.get(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h3><p>对于一个长度为N的数组，其中没有出现的最小正整数只能在1到N+1中，若1到N都出现了则答案是N+1，否则答案在1到N中，首先对数组进行遍历，将出现过的且在1到N范围内的数全部打上标记，<strong>这里打的标记是将其置为负数</strong>，若全部被打过标记了最终返回N + 1，否则返回第一个未出现负数的下标加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123; <span class="comment">// 将数组中小于0的数走置为N + 1</span></span><br><span class="line">            nums[i] = len + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 将出现过的数标记为负数</span></span><br><span class="line">        <span class="keyword">int</span> num = Math.abs(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= len) &#123;</span><br><span class="line">            nums[num - <span class="number">1</span>] = -Math.abs(nums[num - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 找出第一个不为负数的数的下标，即为未出现的数</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>数字<code>n</code>代表生成括号的对数，生成所有可能的并且<strong>有效的</strong>括号组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(res, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sb.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">        sb.append(<span class="string">"("</span>);</span><br><span class="line">        backtrack(res, sb, open + <span class="number">1</span>, close, max);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">        sb.append(<span class="string">")"</span>);</span><br><span class="line">        backtrack(res, sb, open, close + <span class="number">1</span>, max);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>给定一个不含重复数字的数组<code>nums</code> ，返回其所有可能的全排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; markList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        markList.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(nums.length, res, markList, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; markList, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(markList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">        Collections.swap(markList, first, i);</span><br><span class="line">        backtrack(n, res, markList, first + <span class="number">1</span>);</span><br><span class="line">        Collections.swap(markList, first, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><h5 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i若能被x整除，则x/i肯定能被x整除，因此只需判断i和根号x之中较小的即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eratosthenes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">// false表示是一个素数，true表示合数</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPrime[i]) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 将合数标记为true，j = i * i 从 2 * i 优化而来，系数2会随着遍历递增（j += i，相当于递增了系数2），</span></span><br><span class="line">            <span class="comment">// 每一个合数都会有两个比本身要小的因子(0,1除外)，2 * i必然会遍历到这两个因子，当2递增到大于根号n时，</span></span><br><span class="line">            <span class="comment">// 其实后面的已经无需再判断（或者只需判断后面一段），而2到根号n、实际上在 i 递增的过程中已经计算过了，i实际上就相当于根</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                isPrime[j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除有序数组中重复项"><a href="#删除有序数组中重复项" class="headerlink" title="删除有序数组中重复项"></a>删除有序数组中重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的中心索引"><a href="#数组的中心索引" class="headerlink" title="数组的中心索引"></a>数组的中心索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中某一个下标，左右两边的元素之和相等，该下标即为中心索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum1 = Arrays.stream(nums).sum();</span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum2 += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum1 == sum2) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum1 = sum1 - nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h3><p>不使用<strong><code>sqrt(x)</code></strong>函数的情况下，得到x的平方根的整数部分</p><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = x, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &lt;= x) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h5><p>假设平方根为<strong><code>i</code></strong>，则i和<strong><code>x/i</code></strong>必然都是<strong><code>x</code></strong>的因子，而<strong><code>x/i</code></strong>必然等于<strong><code>i</code></strong> ，推导出<strong><code>i + x / i = 2 * i</code></strong>，得出<strong><code>i = (i + x / i) / 2</code></strong>，由此得出解法，<strong><code>i</code></strong>可以任选一个值，只要上述公式成立，<strong><code>i</code></strong>必然就是x的平方根，若不成立<strong><code>(i + x / i) / 2</code></strong>得出的值进行递归，直至得出正确解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">newton</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) sqrts(x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrts</span><span class="params">(<span class="keyword">double</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = (i + x / i) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (res == i) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrts(res, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三个数的最大乘积"><a href="#三个数的最大乘积" class="headerlink" title="三个数的最大乘积"></a>三个数的最大乘积</h3><p>一个整型数组nums ，在数组中找出由三个数字组成的最大乘积，分三种情况，<strong>最大的三个正数相乘、最小的两个负数和最大的一个正数相乘</strong></p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[n - <span class="number">1</span>], nums[n - <span class="number">3</span>] * nums[n - <span class="number">2</span>] * nums[n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小的和第二小的</span></span><br><span class="line">    <span class="keyword">int</span> min1 = <span class="number">0</span>, min2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最大的、第二大的和第三大的</span></span><br><span class="line">    <span class="keyword">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>, max3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; min1) &#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; min2) &#123;</span><br><span class="line">            min2 = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; max1) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = max1;</span><br><span class="line">            max1 = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max2) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max3) &#123;</span><br><span class="line">            max3 = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(min1 * min2 * max1, max1 * max2 * max3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>从数组中找出两个数满足相加之和等于目标数target</p><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分查找（有序）"><a href="#二分查找（有序）" class="headerlink" title="二分查找（有序）"></a>二分查找（有序）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSearch(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = i, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, mid&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针（有序）"><a href="#双指针（有序）" class="headerlink" title="双指针（有序）"></a>双指针（有序）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoPoint(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序硬币"><a href="#排序硬币" class="headerlink" title="排序硬币"></a>排序硬币</h3><p>总共有n枚硬币，将它们摆成一个阶梯形状，第k行必须正好有k枚硬币，找出可形成完整阶梯行的总行数</p><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        n = n - i;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">int</span> cost = ((mid + <span class="number">1</span>) * mid) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cost == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cost &gt; n) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="牛顿迭代-1"><a href="#牛顿迭代-1" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h5><p>使用牛顿迭代求平方根<strong><code>(x + n/x)/2</code></strong>，<strong><code>1 + 2 + 3 + ...+ x = n</code></strong>即<strong><code>x(x+1)/2 = n</code></strong>推导出<strong><code>x = 2n - x</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrts</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = (x + (<span class="number">2</span> * n - x) / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (res == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrts(res, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并有序数组"><a href="#合并有序数组" class="headerlink" title="合并有序数组"></a>合并有序数组</h3><h5 id="合并后排序"><a href="#合并后排序" class="headerlink" title="合并后排序"></a>合并后排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, m, n);</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针（从前往后）"><a href="#双指针（从前往后）" class="headerlink" title="双指针（从前往后）"></a>双指针（从前往后）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums1_copy = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    System.arraycopy(nums1, <span class="number">0</span>, nums1_copy, <span class="number">0</span>, m); <span class="comment">//拷贝数组1</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>; <span class="comment">// 指向数组1的拷贝</span></span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>; <span class="comment">// 指向数组2</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">// 指向数组1</span></span><br><span class="line">    <span class="comment">// 将数组1当成空数组，比较数组1的拷贝和数组2，将较小的放入空数组</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &lt; m) &amp;&amp; (p2 &lt; n))</span><br><span class="line">        nums1[p++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];</span><br><span class="line">    <span class="comment">// 数组2和数组1不等长，将多出的元素拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; m) System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">    <span class="keyword">if</span> (p2 &lt; n) System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针（从后往前）"><a href="#双指针（从后往前）" class="headerlink" title="双指针（从后往前）"></a>双指针（从后往前）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge3</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>))</span><br><span class="line">        nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子数组最大平均数（滑动窗口）"><a href="#子数组最大平均数（滑动窗口）" class="headerlink" title="子数组最大平均数（滑动窗口）"></a>子数组最大平均数（滑动窗口）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">        sum = sum - nums[i - k] + nums[i];</span><br><span class="line">        maxSum = Math.max(maxSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * maxSum / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找零"><a href="#找零" class="headerlink" title="找零"></a>找零</h3><p>每位顾客只买一杯柠檬水，向你付5元、10元或20元，必须给每个顾客正确找零，每一杯柠檬水的售价为5元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> bill : bills) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bill == <span class="number">5</span>) &#123;</span><br><span class="line">            five++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (five == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            five--;</span><br><span class="line">            ten++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                five--;</span><br><span class="line">                ten--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                five -= <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三角形最大周长"><a href="#三角形最大周长" class="headerlink" title="三角形最大周长"></a>三角形最大周长</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复最长子串"><a href="#无重复最长子串" class="headerlink" title="无重复最长子串"></a>无重复最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>, rightIndex = -<span class="number">1</span>;</span><br><span class="line">    Set&lt;Character&gt; window = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            window.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightIndex + <span class="number">1</span> &lt; s.length() &amp;&amp; !window.contains(s.charAt(rightIndex + <span class="number">1</span>))) &#123;</span><br><span class="line">            window.add(s.charAt(rightIndex + <span class="number">1</span>));</span><br><span class="line">            rightIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(rightIndex - i + <span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>一个包含n个整数的数组nums，判断nums中是否存在三个元素<strong><code>a，b，c</code></strong> ，使得<strong><code>a + b + c = 0</code></strong>，找出所有和为0且不重复的三元组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">// 枚举 a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">        <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">        <span class="keyword">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = -nums[first];</span><br><span class="line">        <span class="comment">// 枚举 b</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                --third;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">            <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                list.add(nums[first]);</span><br><span class="line">                list.add(nums[second]);</span><br><span class="line">                list.add(nums[third]);</span><br><span class="line">                ans.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h3&gt;&lt;p&gt;给定一个字符串&lt;code&gt;s&lt;/code&gt; 、一个字符串&lt;code&gt;t&lt;/code&gt;，返回&lt;code&gt;s&lt;/code&gt;中涵盖
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker搭建Prometheus&amp;Grafana</title>
    <link href="https://yaoyinglong.github.io/Blog/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker%E6%90%AD%E5%BB%BAPrometheus&amp;Grafana/"/>
    <id>https://yaoyinglong.github.io/Blog/云原生/Docker搭建Prometheus&amp;Grafana/</id>
    <published>2022-02-14T16:00:00.000Z</published>
    <updated>2022-02-15T11:00:47.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p><strong><code>Prometheus</code></strong>集成了数据的<strong>采集</strong>，<strong>处理</strong>，<strong>存储</strong>，<strong>展示</strong>，<strong>告警</strong>一系列流程，存储数据是使用<strong>多维数据模型</strong>即<strong>由度量名称和键值对标识的时间序列数据</strong>，通过灵活的查询语言<strong><code>PromSQL</code></strong>利用多维数据完成<strong>复杂查询</strong>，<strong>不依赖分布式存储</strong>，单个服务器节点可直接工作，基于<strong><code>HTTP</code></strong>的<strong><code>pull</code>方式</strong>釆集时间序列数据，通过<strong><code>PushGateway</code></strong>组件支持<strong>推送时间序列数据</strong>，通过<strong>服务发现</strong>或<strong>静态配罝发现目标</strong>，通过<strong><code>Grafana</code></strong>支持<strong>多种图形模式及仪表盘</strong>。</p><p><img src="../../../../images/云原生/Docker/Prometheus组成与架构.png" alt></p><p><strong><code>Prometheus Server</code></strong>主要功能是<strong>收集指标</strong>和<strong>存储时间序列数据</strong>到<strong><code>TSDB</code></strong>，并提供查询接口，通过<strong><code>PushGateway</code></strong>短期存储<strong>指标数据</strong>用于<strong>临时性任务</strong>，<strong><code>Exporters</code></strong>采集已有的<strong>三方服务监控指标</strong>并暴露metrics，<strong><code>Alertmanager</code></strong>提供<strong>告警</strong>支持，<strong><code>Web UI</code></strong>提供简单的WEB控制台。</p><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>Prometheus将所有数据存储为<strong>时间序列</strong>，具有<strong>相同度量名称</strong>和<strong>标签</strong>属于同一<strong>指标</strong>，即Prometheus从数据源拿到数据后会存到内置的<strong><code>TSDB</code></strong>中，<strong><code>TSDB</code></strong>中存储的就是<strong>时间序列数据</strong>，它存储的数据会有一个度量名称，如监控一个nginx首先得起个名字，该名称即度量名，还会有N个标签，可理解<strong>名称为表名标签为字段</strong>，每个时间序列都由<strong>度量标准名称</strong>和一组键值对即<strong>标签</strong>唯一标识。</p><p>时间序列的格式<strong><code>&lt;metricename&gt; {&lt;labelname&gt;=&lt;labelvalue&gt;, ...}</code></strong>，<strong><code>metricename</code></strong>为度量标准名称，<strong><code>labelname</code></strong>为标签名，该标签可有多个，如<strong><code>jvm_memory_max_bytes{area=&quot;heap&quot;,id=&quot;Eden Space&quot;,}</code></strong>，还可以继续指定标签，<strong>指定的标签越多查询的维度就越多</strong>。</p><h4 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h4><table><thead><tr><th><strong>类型名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Counter</td><td>递增计数器，适合收集接口请求次数</td></tr><tr><td>Guage</td><td>可任意变化的数值，适用CPU使用率</td></tr><tr><td>Histogram</td><td>对一段时间内数据进行采集，并对有所数值求和用于统计数量</td></tr><tr><td>Summary</td><td>与Histogram类型类似</td></tr></tbody></table><h4 id="任务-amp-实例"><a href="#任务-amp-实例" class="headerlink" title="任务&amp;实例"></a>任务&amp;实例</h4><p><strong>实例</strong>即可抓取的目标target，会在Prometheus配置文件中体现，<strong>任务是具有相同目标的实例集合</strong>，可理解为一个组，如订单服务多台实例机器，可放入一个任务中，分多个实例target抓取。</p><h4 id="Prometheus部署"><a href="#Prometheus部署" class="headerlink" title="Prometheus部署"></a>Prometheus部署</h4><p>对于<strong><code>SpringBoot</code></strong>项目需要开启SpringBoot监控和增加<strong><code>Prometheus</code></strong>整合，添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启springboot的应用监控 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 增加prometheus整合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还需要在具体的服务配置文件中增加开启SpringBoot Admin监控的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span> <span class="comment"># 开启SpringBoot Admin的监控</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">promethus:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>通过Docker来安装，新建目录<strong><code>/data/docker/docker-prometheus</code></strong>，在里面创建文件<strong><code>docker-compose-app.yml</code></strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus:v2.4.3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 映射prometheus的配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/docker/docker-prometheus/prometheus/:/etc/prometheus/</span></span><br><span class="line">      <span class="comment"># 同步容器与宿主机的时间，非常重要，若时间不一致，会导致prometheus抓不到数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'9090:9090'</span></span><br></pre></td></tr></table></figure><p>创建Prometheus配置文件<strong><code>/data/docker/docker-prometheus/prometheus/prometheus.yml</code></strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span>  <span class="comment"># 全局配置</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span>  <span class="comment"># 全局定时任务抓取性能数据间隔</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span>  <span class="comment"># 抓取性能数据任务配置</span></span><br><span class="line">  <span class="comment"># 抓取订单服务性能指标数据任务，一个job下可以配置多个抓取的targets，如订单服务多个实例机器</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'mall-order'</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">10s</span>  <span class="comment">#每10s抓取一次</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">'/actuator/prometheus'</span>  <span class="comment"># 抓取的数据url</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.0.180:8011']</span>   <span class="comment"># 抓取的服务器地址</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">application:</span> <span class="string">'mall-order-label1'</span> <span class="comment"># 抓取任务标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.0.180:8012']</span>   <span class="comment"># 抓取的服务器地址</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">application:</span> <span class="string">'mall-order-label2'</span> <span class="comment"># 抓取任务标签</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 抓取prometheus自身性能指标数据任务</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动prometheus</span><br><span class="line">docker-compose -f docker-compose-app.yml up -d</span><br></pre></td></tr></table></figure><h4 id="Grafana部署"><a href="#Grafana部署" class="headerlink" title="Grafana部署"></a>Grafana部署</h4><p>在上面的docker-compose-app.yml配置文件中加入Grafana的安装配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus:v2.4.3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 映射prometheus的配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/docker/docker-prometheus/prometheus/:/etc/prometheus/</span></span><br><span class="line">      <span class="comment"># 同步容器与宿主机的时间，非常重要，若时间不一致，会导致prometheus抓不到数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'9090:9090'</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:5.2.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">'grafana'</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'3000:3000'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># grafana报警邮件配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./grafana/config/grafana.ini:/etc/grafana/grafana.ini</span></span><br><span class="line">      <span class="comment"># 配置grafana的prometheus数据源</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./grafana/provisioning/:/etc/grafana/provisioning/</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./grafana/config.monitoring</span>  <span class="comment"># grafana登录配置</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">prometheus</span>  <span class="comment"># grafana需要在prometheus之后启动</span></span><br></pre></td></tr></table></figure><p>在<strong><code>docker-prometheus</code></strong>目录下新增<strong><code>grafana</code></strong>目录，在<strong><code>grafana</code></strong>目录中创建<strong><code>config.monitoring</code></strong>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># grafana管理界面的登录用户密码，用户名是admin</span><br><span class="line">GF_SECURITY_ADMIN_PASSWORD=password</span><br><span class="line"># grafana管理界面是否允许注册，默认不允许</span><br><span class="line">GF_USERS_ALLOW_SIGN_UP=false</span><br></pre></td></tr></table></figure><p>在<strong><code>grafana</code></strong>目录下创建<strong><code>provisioning</code></strong>目录，在<strong><code>provisioning</code></strong>目录中创建<strong><code>datasources</code></strong>目录，在<strong><code>datasources</code></strong>目录中新建<strong><code>datasource.yml</code></strong>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config file version</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deleteDatasources:</span>  <span class="comment"># 若之前存在name为Prometheus，orgId为1的数据源先删除</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Prometheus</span></span><br><span class="line">    <span class="attr">orgId:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">datasources:</span>  <span class="comment"># 配置Prometheus的数据源</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Prometheus</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">access:</span> <span class="string">proxy</span></span><br><span class="line">    <span class="attr">orgId:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://prometheus:9090</span>  <span class="comment"># 在相同的docker compose下，可直接用prometheus服务名直接访问</span></span><br><span class="line">    <span class="attr">basicAuth:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">isDefault:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">editable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在<strong><code>grafana</code></strong>目录下创建<strong><code>config</code></strong>目录，在<strong><code>config</code></strong>目录中创建<strong><code>grafana.ini</code></strong>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#################################### SMTP / Emailing ##########################</span><br><span class="line"># 配置邮件服务器</span><br><span class="line">[smtp]</span><br><span class="line">enabled = true</span><br><span class="line"># 发件服务器</span><br><span class="line">host = smtp.qq.com:465</span><br><span class="line"># smtp账号</span><br><span class="line">user = 906271196@qq.com</span><br><span class="line"># smtp 授权码</span><br><span class="line">password = test123</span><br><span class="line"># 发信邮箱</span><br><span class="line">from_address = 906271196@qq.com</span><br><span class="line"># 发信人</span><br><span class="line">from_name = eleven</span><br></pre></td></tr></table></figure><h4 id="监控MySQL性能指标"><a href="#监控MySQL性能指标" class="headerlink" title="监控MySQL性能指标"></a>监控MySQL性能指标</h4><p>在<strong><code>prometheus.yml</code></strong>文件末尾追加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'mysql'</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.0.180:9104']</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">instance:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载mysql客户端的exporter镜像</span><br><span class="line">docker pull prom/mysqld-exporter</span><br><span class="line"><span class="meta">#</span> 启动监控的数据库连接，容器创建时需指定</span><br><span class="line">docker run -d -p 9104:9104 -e DATA_SOURCE_NAME="root:password@(mysql服务器ip:3306)/databaseName" prom/mysqld-exporter</span><br><span class="line"><span class="meta">#</span> 重新启动Prometheus镜像</span><br><span class="line">docker-compose up --force-recreate -d</span><br></pre></td></tr></table></figure><p>导入Prometheus模板，添加mysql-dashboard.json格式模板，模板文件可到<a href="https://grafana.com/grafana/dashboards/" rel="external nofollow noopener noreferrer" target="_blank">Grafana官网</a>或<a href="https://github.com/percona/grafana-dashboards" rel="external nofollow noopener noreferrer" target="_blank">github</a>上下载</p><h4 id="监控Redis性能指标"><a href="#监控Redis性能指标" class="headerlink" title="监控Redis性能指标"></a>监控Redis性能指标</h4><p>在<strong><code>prometheus.yml</code></strong>文件末尾追加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'redis'</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.0.180:9121']</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">instance:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载redis客户端的exporter镜像</span><br><span class="line">docker pull oliver006/redis_exporter</span><br><span class="line"><span class="meta">#</span> 启动监控的数据库连接，容器创建时需指定</span><br><span class="line">docker run -d -p 9121:9121 oliver006/redis_exporter --redis.addr redis://redis连接IP:6379</span><br><span class="line"><span class="meta">#</span> 重新启动Prometheus镜像</span><br><span class="line">docker-compose up --force-recreate -d</span><br></pre></td></tr></table></figure><p>导入Prometheus模板，添加redis-dashboard.json格式模板，模板文件可到<a href="https://grafana.com/grafana/dashboards/" rel="external nofollow noopener noreferrer" target="_blank">Grafana官网</a>或<a href="https://github.com/percona/grafana-dashboards" rel="external nofollow noopener noreferrer" target="_blank">github</a>上下载</p><h4 id="监控Linux服务器性能指标"><a href="#监控Linux服务器性能指标" class="headerlink" title="监控Linux服务器性能指标"></a>监控Linux服务器性能指标</h4><p>在<strong><code>prometheus.yml</code></strong>文件末尾追加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">linux</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.0.180:9100']</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">instance:</span> <span class="string">linux-180</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.0.181:9100']</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">instance:</span> <span class="string">linux-181</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.0.182:9100']</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">instance:</span> <span class="string">linux-182</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.0.183:9100']</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">instance:</span> <span class="string">linux-183</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载linux监控的exporter镜像</span><br><span class="line">docker pull prom/node-exporter</span><br><span class="line"><span class="meta">#</span> 启动监控的数据库连接，容器创建时需指定</span><br><span class="line">docker run -d -p 9100:9100 prom/node-exporter</span><br><span class="line"><span class="meta">#</span> 重新启动Prometheus镜像</span><br><span class="line">docker-compose up --force-recreate -d</span><br></pre></td></tr></table></figure><p>导入Prometheus模板，添加linux-dashboard.json格式模板，模板文件可到<a href="https://grafana.com/grafana/dashboards/" rel="external nofollow noopener noreferrer" target="_blank">Grafana官网</a>或<a href="https://github.com/percona/grafana-dashboards" rel="external nofollow noopener noreferrer" target="_blank">github</a>上下载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Prometheus&quot;&gt;&lt;a href=&quot;#Prometheus&quot; class=&quot;headerlink&quot; title=&quot;Prometheus&quot;&gt;&lt;/a&gt;Prometheus&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Prometheus&lt;/code&gt;&lt;/stron
      
    
    </summary>
    
      <category term="云原生" scheme="https://yaoyinglong.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
      <category term="Docker" scheme="https://yaoyinglong.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/云原生/Kubernetes基础/</id>
    <published>2022-02-14T16:00:00.000Z</published>
    <updated>2022-02-17T13:43:40.603Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://kubernetes.io/zh/docs/home/" rel="external nofollow noopener noreferrer" target="_blank">Kubernetes</a>简称K8S，用于<strong>自动部署</strong>、<strong>扩展</strong>和<strong>管理容器化应用程序</strong>的开源系统。 核心特点;</p><ul><li><strong>服务发现与负载均衡</strong>：无需修改应用程序即可使用陌生的服务发现机制</li><li><strong>存储编排</strong>：自动挂载所选存储系统，包括本地存储</li><li><strong>Secret和配置管理</strong>：部署更新Secrets和应用程序的配置时不必重新构建容器镜像，且不必将软件堆栈配置中的秘密信息暴露出来</li><li><strong>批量执行</strong>：除了服务外，Kubernetes还可管理批处理和CI工作负载，在期望时替换掉失效的容器</li><li><strong>水平扩缩</strong>：使用一个简单的命令、一个UI或基于CPU使用情况自动对应用程序进行扩缩</li><li><strong>自动化上线和回滚</strong>：Kubernetes会分步骤地将针对应用或其配置的更改上线，同时监视应用程序运行状况以确保不会同时终止所有实例</li><li><strong>自动装箱</strong>：根据资源需求和其他约束自动放置容器，同时避免影响可用性</li><li><strong>自我修复</strong>：重新启动失败的容器，在节点死亡时替换并重新调度容器，杀死不响应用户定义的健康检查的容器 </li></ul><h3 id="K8S核心架构原理"><a href="#K8S核心架构原理" class="headerlink" title="K8S核心架构原理"></a>K8S核心架构原理</h3><p><img src="../../../../images/云原生/k8s/k8s核心架构图.png" alt></p><p>K8S属于<strong>主从设备模型</strong>即Master-Slave架构，<strong>Master节点</strong>负责<strong>核心调度</strong>、<strong>管理</strong>和<strong>运维</strong>，<strong>Slave节点</strong>则<strong>执行用户程序</strong>，<strong>主节点</strong>一般被称为<strong><code>Master Node</code></strong>或<strong><code>Head Node</code></strong>，<strong>从节点</strong>被称为<strong><code>Worker Node</code></strong>或Node。</p><p><strong><code>Master Node</code></strong>和<strong><code>Worker Node</code></strong>是分别安装了K8S的Master和Woker组件的实体服务器，每个Node都对应了一台实体服务器，虽然Master Node可和其中一个Worker Node安装在同一台服务器，但<strong>建议<code>Master Node</code>单独部</strong>，所有Master Node和Worker Node组成了K8S集群，<strong>同一个集群可能存在多个<code>Master Node</code>和<code>Worker Node</code></strong>。</p><h5 id="Master-Node包含的组件"><a href="#Master-Node包含的组件" class="headerlink" title="Master Node包含的组件"></a>Master Node包含的组件</h5><ul><li><strong><code>API Server</code></strong>：<strong><code>K8S</code>请求入口服务</strong>，API Server负责接收K8S所有包括来自<strong><code>UI</code>界面</strong>或<strong><code>CLI</code>命令行工具</strong>的请求，然后根据用户具体请求，去通知其他组件干活</li><li><strong><code>Scheduler</code></strong>：K8S所有Worker Node的<strong>调度器</strong>，当用户部署服务时，Scheduler会选择最合适的<strong><code>Worker Node</code></strong>服务器来部署服务</li><li><strong><code>Controller Manager</code></strong>：K8S所有Worker Node的<strong>监控器</strong>，Controller Manager有<strong>很多具体的Controller</strong>， Node Controller、Service Controller、Volume Controller等。Controller负责<strong>监控</strong>和<strong>调整</strong>在<strong><code>Worker Node</code>上部署的服务的状态</strong>，如用户要求A服务部署2个副本，若当其中一个服务挂了时，Controller会马上调整，让 Scheduler再选择一个Worker Node重新部署服务</li><li><strong><code>etcd</code></strong>：K8S的<strong>存储服务</strong>，存储了K8S的<strong>关键配置</strong>和<strong>用户配置</strong>，<strong>仅<code>API Server</code>具备读写权限</strong>，其他组件必须通过API Server接口才能读写数据</li></ul><h5 id="Worker-Node包含的组件"><a href="#Worker-Node包含的组件" class="headerlink" title="Worker Node包含的组件"></a>Worker Node包含的组件</h5><ul><li><strong><code>Kubelet</code></strong>：<strong>Worker Node监视器</strong>，<strong>与<code>Master Node</code>的通讯器</strong>，Kubelet是Master Node安插在Worker Node上的眼线，它会<strong>定期向<code>Master Node</code>汇报自己<code>Node</code>上运行的服务的状态</strong>，并接受来自Master Node的指示采取调整措施，<strong>负责控制</strong>所有容器的<strong>启动停止</strong>，保证节点工作正常</li><li><strong><code>Kube-Proxy</code></strong>：K8S的<strong>网络代理</strong>，<strong>负责Node在K8S的网络通讯</strong>、以及<strong>对外部网络流量的负载均衡</strong></li><li><strong><code>Container Runtime</code></strong>：Worker Node的<strong>运行环境</strong>，即安装了容器化所需的软件环境确保容器化程序能够跑起来，如Docker Engine运行环境</li></ul><h5 id="协同工作流程"><a href="#协同工作流程" class="headerlink" title="协同工作流程"></a>协同工作流程</h5><p>用K8S部署Nginx的过程中，K8S内部各组件的协同工作流程，若在Master节点执行一条命令<strong><code>kubectl create deployment nginx --image=nginx</code></strong>要Master部署一个nginx应用</p><ul><li>该命令首先发到<strong>Master节点</strong>的网关<strong><code>API Server</code></strong></li><li><strong><code>API Server</code></strong>将命令请求交给<strong><code>Controller Mannager</code></strong>进行控制</li><li><strong><code>Controller Mannager</code></strong>进行<strong>应用部署解析</strong>，生成一次部署信息，并通过<strong><code>API Server</code></strong>将信息存入<strong><code>etcd</code></strong></li><li><strong><code>Scheduler</code>调度器</strong>通过<strong><code>API Server</code></strong>从<strong><code>etcd</code></strong>存储中<strong>获取要部署的应用</strong>，开始调度看哪个节点有资源适合部署</li><li>Scheduler把计算出来的调度信息通过<strong><code>API Server</code></strong>再存入<strong><code>etcd</code></strong>中</li><li>每个Node节点的<strong>监控组件<code>kubelet</code></strong>，随时和Master保持联系，给<strong><code>API Server</code></strong>发送请求不断获取最新数据，拿到Master节点存储在<strong><code>etcd</code></strong>中的<strong>部署信息</strong></li><li>若node2的<strong><code>kubelet</code></strong>拿到部署信息，显示其自己节点要部署该nginx应用</li><li><strong><code>kubelet</code>监控组件</strong>就自己run一个应用在<strong>当前机器</strong>上，并随时给Master汇报当前应用的状态信息</li><li>Node和Master也是通过Master的<strong><code>API Server</code></strong>组件联系的</li><li>每个机器上的<strong><code>kube-proxy</code></strong>能知道<strong>集群的所有网络</strong>，只要Node访问别人或别人访问Node，Node上的kube-proxy网络代理<strong>自动计算进行流量转发</strong></li></ul><h3 id="K8S核心概念"><a href="#K8S核心概念" class="headerlink" title="K8S核心概念"></a>K8S核心概念</h3><h5 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h5><p>Deployment负责<strong>创建</strong>和<strong>更新应用程序的实例</strong>。创建Deployment后，Kubernetes Master将应用程序实例调度到集群中的各个节点上，<strong>若托管实例的节点关闭或被删除</strong>，Deployment控制器会<strong>将该实例替换为群集中另一个节点上的实例</strong>。这提供了一种自我修复机制来解决机器故障维护问题。</p><p><img src="../../../../images/云原生/k8s/Deployment.png" alt></p><h5 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h5><p>Pod相当于<strong>逻辑主机</strong>的概念，<strong>负责托管应用实例</strong>，包括<strong>一个</strong>或<strong>多个应用程序容器</strong>如Docker，以及<strong>这些容器的一些共享资源</strong>，共享<strong>存储</strong>、<strong>网络</strong>、<strong>运行信息</strong>等。 </p><p><img src="../../../../images/云原生/k8s/pod.png" alt></p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>Service是一个<strong>抽象层</strong>，它定义了<strong>一组Pod的逻辑集</strong>，并为这些Pod支持<strong>外部流量暴露</strong>、<strong>负载平衡</strong>和<strong>服务发现</strong>。尽管每个Pod都有一个唯一的IP地址，但若没有Service，这些IP不会暴露在群集外部，<strong>Service允许应用程序接收流量</strong>。Service也可用在<strong><code>ServiceSpec</code></strong>标记<strong><code>type</code></strong>的方式暴露，type类型如下：</p><ul><li><strong><code>ClusterIP</code></strong>：<strong>默认</strong>，在集群的内部IP上公开Service，这种类型使得Service<strong>只能从集群内访问</strong></li><li><strong><code>NodePort</code></strong>：使用<strong><code>NAT</code></strong>在集群中每个选定Node的<strong>相同端口上公开<code>Service</code></strong>，使用<strong><code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code></strong>从集群外部访问Service，是ClusterIP的超集</li><li><strong><code>LoadBalancer</code></strong>：在当前云中创建一个<strong>外部负载均衡器</strong>若支持的话，并为Service分配一个固定的外部IP，是NodePort的超集</li><li><strong><code>ExternalName</code></strong>：通过返回带有该名称的<strong><code>CNAME</code></strong>记录公开Service，不使用代理，使用任意名称，由spec中的<strong><code>externalName</code></strong>指定</li></ul><p><img src="../../../../images/云原生/k8s/service.png" alt></p><p><strong>Service是<code>K8S</code>服务的核心屏蔽了服务细节</strong>，<strong>统一对外暴露服务接口</strong>，如一个服务A部署了3个备份，即3个Pod，对于用户来说，只需要关注一个Service的入即可，而不需要操心究竟应该请求哪一个Pod。外部用户<strong>不需要感知</strong>因为Pod上服务的<strong>意外崩溃</strong>、K8S重新拉起Pod而造成的<strong>IP变更</strong>，外部用户也不需要感知因<strong>升级</strong>、<strong>变更服务</strong>带来的Pod替换而造成的IP变化。</p><p>Service还可以做<strong>流量负载均衡</strong>，<strong>主要负责K8S集群内部的网络拓扑</strong>，<strong>集群外部访问集群内部可通过Ingress来完成</strong>，Ingress是<strong>对集群中服务的外部访问进行管理的API对象</strong>，典型的访问方式是HTTP，Ingress可提供<strong>负载均衡</strong>、<strong>SSL终结</strong>和<strong>基于名称的虚拟托管</strong>，Ingress是整个K8S集群的<strong>接入层</strong>，负责<strong>集群内外通讯</strong>，Ingress和Service的网络拓扑关系图如下：</p><p><img src="../../../../images/云原生/k8s/Ingress与Service网络拓扑关系图.png" alt></p><h3 id="K8S安装"><a href="#K8S安装" class="headerlink" title="K8S安装"></a>K8S安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 关闭selinux</span><br><span class="line">sed -i 's/enforcing/disabled/' /etc/selinux/config # 永久关闭</span><br><span class="line">setenforce 0 # 临时关闭</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 关闭swap</span><br><span class="line">swapoff -a # 临时关闭</span><br><span class="line">vim /etc/fstab # 永久关闭，注释掉/etc/fstab文件下面这行代码</span><br><span class="line"><span class="meta">#</span> /dev/mapper/centos‐swap swap swap defaults 0 0</span><br><span class="line"></span><br><span class="line">systemctl reboot # 重启生效</span><br><span class="line">free -m # 查看下swap交换区是否都为0，如果都为0则swap关闭成功</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 给机器设置主机名</span><br><span class="line">hostnamectl set-hostname &lt;hostname&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 给机器名称配置hosts</span><br><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta">#</span> 添加如下行</span><br><span class="line">192.168.0.180 eleven</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将桥接的IPv4流量传递到iptables</span><br><span class="line">vim /etc/sysctl.d/k8s.conf</span><br><span class="line"><span class="meta">#</span> 添加下面两行配置</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line"></span><br><span class="line">sysctl --system # 生效</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置时间同步</span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加k8s yum源</span><br><span class="line">vim /etc/yum.repos.d/kubernetes.repo</span><br><span class="line"><span class="meta">#</span> 添加如下配置</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 若之前安装过k8s，先卸载旧版本</span><br><span class="line">yum remove -y kubelet kubeadm kubectl</span><br><span class="line"><span class="meta">#</span> 查看可以安装的版本</span><br><span class="line">yum list kubelet --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span> 安装kubelet、kubeadm、kubectl指定版本，这里使用kubeadm方式安装k8s集群</span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 开机启动kubelet</span><br><span class="line">systemctl enable kubelet</span><br><span class="line">systemctl start kubelet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在k8s的Master机器上执行初始化操作</span><br><span class="line">kubeadm init --apiserver-advertise-address=192.168.0.180 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置使用kubectl命令工具(类似docker这个命令)</span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">chmod 666 /etc/kubernetes/admin.conf</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看kubectl是否能正常使用，此时节点状态为NotReady，安装Pod网络插件后才会变为Ready状态</span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装Pod网络插件</span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/canal/rbac.yaml</span><br><span class="line"><span class="meta">#</span> 若上面这个calico网络插件安装不成功可以试下下面这个</span><br><span class="line"><span class="meta">#</span> kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kubeflannel.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将node节点加入进Master节点的集群里，复制kubeadm init命令执行后的输出中的kubeadm join内容</span><br><span class="line">kubeadm join 192.168.65.160:6443 --token hbovty.6x82bkdlsk6dfy32 \ --discovery-token-ca-cert-hash sha256:659511b431f276b2a5f47397677b1dff74838ae5eb18e24135e6dae1b8c45840</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将Master也当作Node使用，xxx-nodename表示节点名称，或主机IP，也可使用--all参数</span><br><span class="line">kubectl taint node xxx-nodename node-role.kubernetes.io/master-</span><br><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br><span class="line"><span class="meta">#</span> 将Master恢复成Master Only状态，xxx-nodename表示节点名称，或主机IP</span><br><span class="line">kubectl taint node xxx-nodename node-role.kubernetes.io/master="":NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 要删除k8s-node1节点，首先在master节点上依次执行以下两个命令</span><br><span class="line">kubectl drain k8s‐node1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node k8s-node1</span><br><span class="line"><span class="meta">#</span> 在k8s-node1这个Node节点上执行如下命令，这样该节点即完全从k8s集群中脱离开来</span><br><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h5 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install bash-completion</span><br><span class="line">source /usr/share/bash-completion/bash_completion</span><br><span class="line">source &lt;(kubectl completion bash)</span><br><span class="line">echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="K8S部署应用"><a href="#K8S部署应用" class="headerlink" title="K8S部署应用"></a>K8S部署应用</h3><p><a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/" rel="external nofollow noopener noreferrer" target="_blank">kubectl</a>是<strong><code>API Server</code></strong>的<strong>客户端工具</strong>，工作在命令行下，能够连接<strong><code>API Server</code></strong>实现各种<strong>增删改查</strong>等操作 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一次deployment部署</span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line"><span class="meta">#</span> 查看Nginx的pod和service信息</span><br><span class="line">kubectl get pod,svc -o wide</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> my‐tomcat表示pod的名称 --image表示镜像的地址</span><br><span class="line">kubectl create deployment my-tomcat --image=tomcat:7.0.75-alpine</span><br><span class="line">kubectl get deployment</span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看Pod打印的日志</span><br><span class="line">kubectl logs my-tomcat-6d9cf656c4-45xk5</span><br><span class="line"><span class="meta">#</span> 使用exec可在Pod的容器中执行命令，使用env命令查看环境变量</span><br><span class="line">kubectl exec my-tomcat-6d9cf656c4-45xk5 -- env</span><br><span class="line"><span class="meta">#</span> 查看容器的根目录下面内容</span><br><span class="line">kubectl exec my-tomcat-6d9cf656c4-45xk5 -- ls /</span><br><span class="line"><span class="meta">#</span> 进入Pod容器内部并执行bash命令，若想退出容器可以使用exit命令</span><br><span class="line">kubectl exec -it my-tomcat-6d9cf656c4-45xk5 -- sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在集群外是无法访问Pod的，需要创建一个service服务，才能让外部客户端可访问Pod</span><br><span class="line"><span class="meta">#</span> --name指定service名称，若端口暴露类型为NodePort，可通过集群内任意一台主机加暴露端口进行访问</span><br><span class="line">kubectl expose deployment my-tomcat --name=tomcat --port=8080 --type=NodePort</span><br><span class="line"><span class="meta">#</span>查看service信息，port信息里冒号后面的端口号就是对集群外暴露的访问接口</span><br><span class="line">kubectl get svc -o wide</span><br><span class="line"><span class="meta">#</span> 查看pod信息，‐w意思是一直等待观察pod信息的变动</span><br><span class="line">kubectl get pod -w</span><br><span class="line"><span class="meta">#</span> 查看pod、deployment、service等所有信息</span><br><span class="line">kubectl get all -o wide</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除刚刚创建的Pod，k8s会重新启动一个新的pod，这是k8s的服务自愈功能</span><br><span class="line">kubectl delete pod my-tomcat-6d9cf656c4-45xk5</span><br><span class="line"><span class="meta">#</span> 真正删除pod</span><br><span class="line">kubectl delete deployment my-tomcat</span><br><span class="line"><span class="meta">#</span> 删除service</span><br><span class="line">kubectl delete service tomcat</span><br></pre></td></tr></table></figure><h5 id="扩容缩容"><a href="#扩容缩容" class="headerlink" title="扩容缩容"></a>扩容缩容</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 扩容到3个pod</span><br><span class="line">kubectl scale --replicas=3 deployment my-tomcat</span><br><span class="line"><span class="meta">#</span> 缩容到2个pod</span><br><span class="line">kubectl scale --replicas=2 deployment my-tomcat</span><br></pre></td></tr></table></figure><h5 id="滚动升级与回滚"><a href="#滚动升级与回滚" class="headerlink" title="滚动升级与回滚"></a>滚动升级与回滚</h5><p>滚动升级并不是一次性将多个pod全部停掉升级，而是一个一个的滚动升级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 滚动升级将tomcat版本由tomcat:7.0.75-alpine升级到tomcat:8.0.41-jre8-alpine</span><br><span class="line">kubectl set image deployment my-tomcat tomcat=tomcat:8.0.41-jre8-alpine</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看历史版本</span><br><span class="line">kubectl rollout history deploy my-tomcat</span><br><span class="line"><span class="meta">#</span> 回滚到上一个版本，也可通过--to-revision参数可指定回退的版本</span><br><span class="line">kubectl rollout undo deployment my-tomcat</span><br></pre></td></tr></table></figure><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><p>通过给资源添加Label，可方便地管理资源，如Deployment、Pod、Service等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看Deployment中所包含的Label，该命令是查询deployment详细信息，该信息中包括Label信息</span><br><span class="line">kubectl describe deployment my-tomcat</span><br><span class="line"><span class="meta">#</span> 通过Label查询Pod</span><br><span class="line">kubectl get pods -l app=my-tomcat</span><br><span class="line"><span class="meta">#</span> 通过Label查询services</span><br><span class="line">kubectl get services -l app=my-tomcat</span><br><span class="line"><span class="meta">#</span> 给Pod添加Label</span><br><span class="line">kubectl label pod my-tomcat-6d9cf656c4-45xk5 version=v1</span><br><span class="line"><span class="meta">#</span> 查看Pod的详细信息，包括Label信息</span><br><span class="line">kubectl describe pods my-tomcat-6d9cf656c4-45xk5</span><br><span class="line"><span class="meta">#</span> 通过Label查询Pod</span><br><span class="line">kubectl get pods -l version=v1</span><br><span class="line"><span class="meta">#</span> 通过Label删除服务</span><br><span class="line">kubectl delete service -l app=test-service</span><br></pre></td></tr></table></figure><h5 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看Pod内部某个container打印的日志</span><br><span class="line">kubectl log $&#123;POD_NAME&#125; -c $&#123;CONTAINER_NAME&#125;</span><br><span class="line"><span class="meta">#</span> 查看Pod打印的日志</span><br><span class="line">kubectl logs my-tomcat-6d9cf656c4-45xk5</span><br><span class="line"><span class="meta">#</span> 使用exec可在Pod的容器中执行命令，使用env命令查看环境变量</span><br><span class="line">kubectl exec my-tomcat-6d9cf656c4-45xk5 -- env</span><br><span class="line"><span class="meta">#</span> 查看容器的根目录下面内容</span><br><span class="line">kubectl exec my-tomcat-6d9cf656c4-45xk5 -- ls /</span><br><span class="line"><span class="meta">#</span> 进入Pod容器内部并执行bash命令，若想退出容器可以使用exit命令</span><br><span class="line">kubectl exec -it my-tomcat-6d9cf656c4-45xk5 -- sh</span><br></pre></td></tr></table></figure><h3 id="K8S中的资源"><a href="#K8S中的资源" class="headerlink" title="K8S中的资源"></a>K8S中的资源</h3><p><strong><code>K8S</code>中所有内容都抽象为资源</strong>， 资源实例化之后叫做对象，上面说的那些核心概念都是<br>K8S中的资源：</p><ul><li><strong><code>workload</code>工作负载型资源</strong>：<strong><code>Pod</code></strong>、<strong><code>ReplicaSet</code></strong>、<strong><code>Deployment</code></strong>、<strong><code>StatefulSet</code></strong>、<strong><code>DaemonSet</code></strong>等等</li><li><strong><code>ServiceDiscovery LoadBalance</code>服务发现及负载均衡型资源</strong>：<strong><code>Service</code></strong>、<strong><code>Ingress</code></strong>等等</li><li><strong>配置与存储型资源</strong>： <strong><code>Volume</code></strong>存储卷、<strong><code>CSI</code></strong>容器存储接口、可扩展各种各样的第三方存储卷</li><li><strong>特殊类型的存储卷</strong>：<strong><code>ConfigMap</code></strong>当配置中心来使用的资源类型、<strong><code>Secret</code></strong>保存敏感数据、<strong><code>DownwardAPI</code></strong>把外部环境中的信息输出给容器</li><li><strong>集群级资源</strong>：<strong><code>Namespace</code></strong>、<strong><code>Node</code></strong>、<strong><code>Role</code></strong>、<strong><code>ClusterRole</code></strong>、<strong><code>RoleBinding</code></strong>角色绑定、<strong><code>ClusterRoleBinding</code></strong>集群角色绑定</li><li><strong>元数据型资源</strong>：<strong><code>HPA</code></strong>即Pod水平扩展、<strong><code>PodTemplate</code></strong>即Pod模板，用于让控制器创建Pod时使用的模板、<strong><code>LimitRange</code></strong>用来定义硬件资源限制</li></ul><h5 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h5><p>上面直接用<strong>命令</strong>创建<strong><code>deployment</code></strong>，<strong><code>pod</code></strong>，<strong><code>service</code></strong>这些资源，在k8s中一般都会使用<strong><code>yaml</code></strong>格式的文件来创建符合预期期望的资源，这样的yaml文件一般称为<strong>资源清单</strong>。 </p><p>使用资源清单yaml来创建k8s的资源对象，用yaml创建deployment资源的对象，可用创建deployment的命令加上参数<strong><code>--dry-run -o yaml</code></strong>就可以输出这次部署的资源清单yaml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment my-tomcat --image=tomcat:7.0.75‐alpine --dry-run -o yaml</span><br></pre></td></tr></table></figure><p>对上面的yaml适当的修改下保存为文件<strong><code>tomcat-deployment-demo.yaml</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-tomcat-yaml</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-tomcat-yaml</span><span class="comment">#修改deployment的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 修改pod副本为两个</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-tomcat-yaml</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-tomcat-yaml</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:7.0.75-alpine</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">          <span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">status:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 用yaml文件来创建这次部署</span><br><span class="line">kubectl apply -f tomcat-deployment-demo.yaml</span><br><span class="line"><span class="meta">#</span> 用yaml创建service资源的对象</span><br><span class="line">kubectl expose deployment my-tomcat-yaml --name=tomcat --port=8080 --type=NodePort --dry-run -o yaml</span><br></pre></td></tr></table></figure><p><strong>用<code>yaml</code>创建<code>service</code>资源的对象</strong>，保存为文件<strong><code>tomcat-service-demo.yaml</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-tomcat-yaml</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-service-yaml</span> <span class="comment"># 修改Service名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span>  <span class="comment"># service虚拟ip对应的端口，在集群内网机器可用service的虚拟ip加该端口号访问服务</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># pod暴露的端口，一般与pod内部容器暴露的端口一致</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-tomcat-yaml</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 用yaml文件来创建service</span><br><span class="line">kubectl apply -f tomcat-service-demo.yaml</span><br><span class="line"><span class="meta">#</span> 针对已有资源输出资源清单yaml，使用-o参数加yaml，可将资源的配置以yaml的格式输出出来，也可使用json，输出为json格式</span><br><span class="line">kubectl get pod nginx-deploy-7db697dfbd-2qh7v -o yaml</span><br><span class="line">kubectl get service nginx -o yaml</span><br><span class="line">kubectl get deployment nginx -o yaml</span><br></pre></td></tr></table></figure><h3 id="K8S高级特性"><a href="#K8S高级特性" class="headerlink" title="K8S高级特性"></a>K8S高级特性</h3><p>K8S中还有一些高级特性如<strong>弹性扩缩应用</strong>、<strong>滚动更新</strong>、配置管理、存储卷、网关路由等。</p><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p><strong><code>ReplicaSet</code></strong>确<strong>保任何时间都有指定数量的Pod副本在运行</strong>，通常用来保证给定数量的、完全相同的Pod的可用性。建议使用<strong><code>Deployment</code></strong>来管理<strong><code>ReplicaSet</code></strong>，而不是直接使用<strong><code>ReplicaSet</code></strong>。</p><h4 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h4><p><strong><code>ConfigMap</code></strong>是一种<strong>API对象</strong>，用来将<strong>非机密性</strong>的数据保存到<strong>键值对</strong>中。使用时Pod可<strong>将其用作环境变量</strong>、<strong>命令行参数</strong>或<strong>存储卷中的配置文件</strong>。使用<strong><code>ConfigMap</code></strong>可<strong>将配置数据和应用程序代码分开</strong>。</p><h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><p><strong><code>Volume</code></strong>指的是<strong>存储卷</strong>，<strong>包含可被Pod中容器访问的数据目录</strong>，容器中文件在磁盘上是<strong>临时存放</strong>，当容器崩溃时文件会丢失，同时<strong>无法在多个Pod中共享文件</strong>，通过使用存储卷可以解决这两个问题，常用存储卷：</p><ul><li><strong><code>configMap</code></strong>：<strong>提供向Pod注入配置数据的方法</strong>，ConfigMap对象中存储的数据可被configMap类型的卷引用，然后被Pod中运行的容器化应用使用</li><li><strong><code>emptyDir</code></strong>：emptyDir卷可用于<strong>存储缓存数据</strong>，<strong>当Pod分派到某个Node上时<code>emptyDir</code>卷会被创建</strong>，且Pod在该节点上<strong>运行期间卷一直存在</strong>，<strong>当Pod被从节点上删除时<code>emptyDir</code>卷中的数据也会被永久删除</strong></li><li><strong><code>hostPath</code></strong>：<strong>将主机节点文件系统上的文件或目录挂载到Pod中</strong>，在<strong><code>Minikube</code></strong>中的主机指的是<strong><code>Minikube</code>所在虚拟机</strong></li><li><strong><code>local</code></strong>：代表<strong>某个被挂载的本地存储设备</strong>，如磁盘、分区或目录，local卷只能用作<strong>静态创建的持久卷</strong>，尚<strong>不支持动态配置</strong></li><li><strong><code>nfs</code></strong>：<strong>将NFS网络文件系统挂载到Pod中</strong></li><li><strong><code>persistentVolumeClaim</code></strong>：将持久卷<strong><code>PersistentVolume</code></strong>挂载到Pod中，持久卷是集群中的一块存储，可以由管理员事先供应，或使用存储类Storage Class来动态供应，持久卷是集群资源类似于节点</li></ul><h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><p><img src="../../../../images/云原生/k8s/ingress.png" alt></p><p>通过<strong><code>Ingress</code></strong>资源可实现<strong>类似<code>Nginx</code>的基于域名访问</strong>，<strong>从而实现Pod的负载均衡访问</strong>，进入<a href="https://github.com/kubernetes/ingress-nginx/blob/nginx-0.20.0/deploy/mandatory.yaml" rel="external nofollow noopener noreferrer" target="_blank">ingress-nginx</a>将里面内容复制保存到k8s master机器上的ingress-controller.yaml文件中，修改镜像地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装ingress</span><br><span class="line">kubectl apply -f ingress-controller.yaml</span><br><span class="line"><span class="meta">#</span> 查看是否安装成功</span><br><span class="line">kubectl get pods -n ingress-nginx -o wide</span><br><span class="line"><span class="meta">#</span> 查看日志</span><br><span class="line">kubectl logs -f nginx-ingress-controller-2dvwn -n ingress-nginx</span><br></pre></td></tr></table></figure><p><strong>配置<code>ingress</code>访问规则</strong>，类似配置nginx的代理转发配置，让ingress将域名<strong><code>tomcat.eleven.com</code></strong>转发给后端的<strong><code>tomcat-service-yaml</code></strong>服务，新建<strong><code>ingress-tomcat.yaml</code></strong>文件： </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.eleven.com</span>  <span class="comment"># 转发域名</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">tomcat-service-yaml</span>  <span class="comment"># service名称</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">8081</span>   <span class="comment"># service的端口</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 生效规则</span><br><span class="line">kubectl apply -f ingress-tomcat.yaml</span><br><span class="line"><span class="meta">#</span> 卸载资源</span><br><span class="line">kubectl delete -f ingress-tomcat.yaml</span><br><span class="line"><span class="meta">#</span> 查看生效的ingress规则</span><br><span class="line">kubectl get ing</span><br><span class="line">kubectl describe ing  web-ingress</span><br><span class="line"><span class="meta">#</span> 在hosts中配置：192.168.0.180 tomcat.eleven.com</span><br><span class="line">echo "192.168.0.180 tomcat.eleven.com" &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h4 id="ConfigMap-1"><a href="#ConfigMap-1" class="headerlink" title="ConfigMap"></a>ConfigMap</h4><p>ConfigMap允许<strong>将配置文件</strong>与<strong>镜像文件分离</strong>，将ConfigMap属性注入到Pod的环境变量中去，使容器化的应用程序具有可移植性。添加<strong><code>nginx-config.yaml</code></strong>配置文件用于创建<strong><code>ConfigMap</code></strong>，ConfigMap名称为<strong><code>nginx-config</code></strong>，配置信息存放在data节点下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">nginx-env:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 应用nginx-config.yaml文件创建ConfigMap</span><br><span class="line">kubectl create -f nginx-config.yaml</span><br><span class="line"><span class="meta">#</span> 获取所有ConfigMap</span><br><span class="line">kubectl get configmap</span><br><span class="line"><span class="meta">#</span> 通过yaml格式查看ConfigMap中的内容</span><br><span class="line">kubectl get configmaps nginx-config -o yaml</span><br></pre></td></tr></table></figure><p>添加配置文件<strong><code>nginx-deployment.yaml</code></strong>用于创建Deployment，部署一个Nginx服务，在Nginx的环境变量中引用<strong><code>ConfigMap</code></strong>中的属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.10</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NGINX_ENV</span> <span class="comment"># 在Nginx中设置环境变量</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">nginx-config</span> <span class="comment"># 设置ConfigMap的名称</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">nginx-env</span> <span class="comment"># 需要取值的键</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 应用配置文件文件创建Deployment</span><br><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line"><span class="meta">#</span> 创建成功后查看Pod中的环境变量，发现NGINX_ENV变量已经被注入了</span><br><span class="line">kubectl exec nginx-deployment-7cf97748c4-tcq5v -- env</span><br></pre></td></tr></table></figure><h4 id="存储卷的使用"><a href="#存储卷的使用" class="headerlink" title="存储卷的使用"></a>存储卷的使用</h4><p>通过存储卷可把<strong>外部数据挂载到容器中</strong>去，供容器中的应用访问，这样就算容器崩溃了，数据依然可以存在，使用Docker部署Nginx时，将Nginx的html、logs、conf目录从外部挂载到容器中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v /data/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /data/nginx/logs:/var/log/nginx \</span><br><span class="line">-v /data/nginx/conf:/etc/nginx \</span><br><span class="line">-d nginx:1.10</span><br></pre></td></tr></table></figure><p>Minikube可认为是一台虚拟机，可用<strong><code>Minikube</code></strong>的<strong><code>ssh</code></strong>命令来访问它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minikube ssh</span><br><span class="line"><span class="meta">#</span> Minikube中默认有一个docker用户，我们先重置下它的密码</span><br><span class="line">sudo passwd docker</span><br><span class="line"><span class="meta">#</span> 在Minikube中创建data目录</span><br><span class="line">midir /home/docker/data</span><br><span class="line"><span class="meta">#</span> 把Nginx数据目录复制到Minikube中，才能实现目录的挂载，注意docker用户只能修改/home/docker目录中的文件，通过scp命令来复制文件</span><br><span class="line">scp -r /home/macro/data/nginx docker@192.168.0.180:/home/docker/data/nginx</span><br></pre></td></tr></table></figure><p>添加<strong><code>nginx-volume-deployment.yaml</code></strong>配置文件用于创建Deployment</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-volume-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.10</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">html-volume</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/nginx</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">conf-volume</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html-volume</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/home/docker/data/nginx/html</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Directory</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/home/docker/data/nginx/logs</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Directory</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conf-volume</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/home/docker/data/nginx/conf</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 应用配置文件创建Deployment</span><br><span class="line">kubectl apply -f nginx-volume-deployment.yaml</span><br><span class="line"><span class="meta">#</span> 应用配置文件创建Service</span><br><span class="line">kubectl apply -f nginx-service.yaml</span><br></pre></td></tr></table></figure><p>添加<strong><code>nginx-service.yaml</code></strong>配置文件用于创建Service </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span></span><br></pre></td></tr></table></figure><h3 id="K8S与Docker"><a href="#K8S与Docker" class="headerlink" title="K8S与Docker"></a>K8S与Docker</h3><p>Docker作为非常流行的容器技术，经常有文章说它被K8S弃用了，取而代之的是另一种容器技术containerd，containerd只是从Docker中分离出来的底层容器运行时，使用起来和Docker并没有什么区别，从Docker转型containerd非常简单，只要把之前Docker命令中的<strong><code>docker</code></strong>改为<strong><code>crictl</code></strong>基本就可以了用法一样。</p><p>K8S发布CRI即<strong><code>Container Runtime Interface</code></strong>统一了容器运行时接口，凡是支持CRI的容器运行时，皆可作为K8S的<strong>底层容器运行时</strong>，若K8S使用Docker作为K8S容器运行时的话，kubelet需要先要通过<strong><code>dockershim</code></strong>去调用Docker，再通过Docker去调用<strong><code>containerd</code></strong>，若使用containerd作为K8S容器运行时的话，由于containerd内置了CRI插件，kubelet可直接调用containerd，使用containerd不仅调用链变短了性能提高了，且资源占用也会变小，毕竟Docker不是一个纯粹的容器运行时，具有大量其他功能，未来Docker可能自己直接实现K8S的CRI接口来兼容K8S的底层使用。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>Docker部署过的eureka应用为例，<strong>首先将镜像发布到镜像仓库中</strong>，然后创建用于创建Deployment的配置文件<strong><code>eureka-app-deployment.yaml</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-app-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">eureka-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">eureka-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">eureka-app</span></span><br><span class="line">          <span class="comment"># 指定Docker Hub中的镜像地址</span></span><br><span class="line">          <span class="attr">image:</span> <span class="number">3120130802229</span><span class="string">/eleven-eureka-server:0.0.1</span></span><br><span class="line">          <span class="comment"># Always总是拉取镜像，IfNotPresent(默认该值) 本地有则使用本地镜像，Never只使用本地镜像，从不拉取，即使本地没有镜像</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8761</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TZ</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LOG_FILE</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">/var/logs</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/logs</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">log-volume</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-volume</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/data/k8s-app/eureka/logs</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">Default</span> <span class="comment"># 继承Pod所在宿主机的DNS设置，使pod能访问外网</span></span><br></pre></td></tr></table></figure><p>创建用于创建Service的配置文件<strong><code>eureka-app-service.yaml</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-app-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8761</span><span class="comment"># service的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8761</span> <span class="comment"># pod的端口，一般与pod内部容器的服务端口一致</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 通过应用配置文件来创建Deployment</span><br><span class="line">kubectl apply -f eureka-app-deployment.yaml</span><br><span class="line"><span class="meta">#</span> 通过应用配置文件来创建Service</span><br><span class="line">kubectl apply -f eureka-app-service.yaml</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/home/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Kubernetes&lt;/a&gt;简称K8S，用于&lt;strong&gt;自
      
    
    </summary>
    
      <category term="云原生" scheme="https://yaoyinglong.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
      <category term="k8s" scheme="https://yaoyinglong.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker%20Compose%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/云原生/Docker Compose基础/</id>
    <published>2022-02-13T16:00:00.000Z</published>
    <updated>2022-02-14T03:54:56.922Z</updated>
    
    <content type="html"><![CDATA[<p>使用微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，若每个微服务都要手动启停，效率很低、维护量很大。可使用<strong><code>Docker Compose</code></strong>来轻松、高效地管理容器。Docker Compose是一个<strong>用于定义和运行多容器的Docker应用的工具</strong>，使用Compose可在一个<strong><code>yaml</code>格式</strong>的配置文件中配置应用服务，使用一个命令，即可创建并启动配置中引用的所有服务。</p><p><strong><code>Docker Compose</code></strong>的安装有多种方式，可通过<strong>Shell安装</strong>、<strong>pip安装</strong>、<strong>作为容器安装</strong>等，以下是通过Shell安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker compose安装步骤</span><br><span class="line">sudo curl -L "https://github.com/docker/compose/releases/download/1.28.6/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>Docker Compose的使用只需要编写一个<strong>描述容器的配置<code>docker-compose.yml</code></strong>配置文件，然后使用<strong>描述对容器的操作的<code>docker-compose</code></strong>命令操作即可。</p><p>这里依然使用<strong><code>eureka-server-0.0.1-SNAPSHOT.jar</code></strong>，在该<strong><code>jar</code>所在目录的上一级目录</strong>中创建<strong><code>docker-compose.yml</code></strong>配置文件文件，在该配置文件中配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.8'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">eureka:</span>             <span class="comment">#指定服务名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eleven-eureka-server:0.0.1</span>  <span class="comment">#指定镜像名称</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./eureka</span>   <span class="comment">#指定Dockfile所在路径</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">eleven-eureka-server</span>  <span class="comment">#指定启动容器名称</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8761:8761"</span>   <span class="comment">#指定端口映射</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8761</span>          <span class="comment">#声明容器对外暴露的端口</span></span><br></pre></td></tr></table></figure><p>然后在<strong><code>docker-compose.yml</code></strong>配置文件文件所在路径执行<strong><code>docker-compose up</code></strong>启动服务，使用compose启动时会先<strong>创建一个默认的网络<code>app_default</code></strong>，默认以compose所在文件目录名加<strong><code>_default</code></strong>命名，<strong><code>compose</code>内的所有容器都会加入此网络</strong>，<strong>可用服务名相互访问</strong>，若镜像<strong><code>eleven-eureka-server:0.0.1</code>不存在则先构建镜像</strong>，若镜像存在则不构建，加上<strong><code>--build</code></strong>参数可<strong>强制先构建镜像</strong>，若镜像之前构建过且构建文件没有变化或构建的<strong>内容没有变化</strong>，就算加上–build参数也不会重新构建，根据构建的镜像创建一个名称叫<strong><code>app_eureka_1</code></strong>的容器，<strong><code>app</code></strong>是<strong><code>docker-compose.yml</code></strong>配置文件文件所在目录，最后<strong>启动容器</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -d用于设置后台启动</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure><p>Docker Compose将所管理的容器分为<strong>工程</strong>、<strong>服务</strong>、<strong>容</strong>器三层，Docker Compose<strong>运行目录下的所有文件</strong>包括<strong><code>docker-compose.yml</code></strong>、 <strong><code>extends</code>文件</strong>或<strong>环境变量文件</strong>等<strong>组成一个工程</strong>，<strong>默认为<code>docker-compose.yml</code>所在目录的目录名称</strong>。<strong>一个工程可包含多个服务</strong>，每个服务中定义了<strong>容器运行的镜像</strong>、<strong>参数</strong>和<strong>依赖</strong>，<strong>一个服务可包括多个容器实例</strong>。</p><p><strong>同一个<code>docker compose</code>内部的容器之间可用服务名相互访问</strong>，<strong>服务名</strong>就<strong>相当于<code>hostname</code></strong>，<strong>可直接<code>ping</code>服务名</strong>，得到的就是服务对应容器的ip，若服务<strong>做了扩容一个服务对应了多个容器</strong>，则<strong><code>ping</code>服务名会轮询访问服务对应的每台容器<code>ip</code></strong> ，Docker底层用了<strong><code>LVS</code></strong>等技术实现该负载均衡。</p><h4 id="docker-compose-yml常用指令"><a href="#docker-compose-yml常用指令" class="headerlink" title="docker-compose.yml常用指令"></a>docker-compose.yml常用指令</h4><p>可以参考<strong><code>docker-compose.yml</code></strong>文件<a href="https://docs.docker.com/compose/compose-file/" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># image指定镜像名称或镜像id，若该镜像在本地不存在，Compose会尝试pull下来</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">java</span></span><br><span class="line"><span class="comment"># 指定Dockerfile文件的路径</span></span><br><span class="line"><span class="attr">build:</span> <span class="string">./dir</span></span><br><span class="line"><span class="comment"># build也可以是一个对象，用以指定Dockerfile和参数</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">  <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">    <span class="attr">buildno:</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 覆盖容器启动后默认执行的命令</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">thin</span> <span class="string">-p</span> <span class="number">3000</span></span><br><span class="line"><span class="comment"># command也可以是一个list，类似于Dockerfile中的CMD指令</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">[bundle,</span> <span class="string">exec,</span> <span class="string">thin,</span> <span class="string">-p,</span> <span class="number">3000</span><span class="string">]</span></span><br><span class="line"><span class="comment"># links显示链接到其他服务中的容器，可指定服务名称和链接的别名使用SERVICE:ALIAS的形式，或者只指定服务名称</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">db:database</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"><span class="comment"># 表示链接到docker-compose.yml外部的容器，甚至并非Compose管理的容器，特别是对于那些提供共享容器或共同服务</span></span><br><span class="line"><span class="attr">external_links:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">redis_1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:postgresql</span></span><br><span class="line"><span class="comment"># 暴露端口信息，使用宿主端口:容器端口的格式，或者仅指定容器端口此时宿主机将会随机指定端口，类似于docker run -p</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"3000-3005"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"8000:8000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"9090-9091:8080-8081"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"49100:22"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"127.0.0.1:5000-5010:5000-5010"</span></span><br><span class="line"><span class="comment"># 暴露端口，只将端口暴露给连接的服务，而不暴露给宿主机</span></span><br><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"3000"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"8000"</span></span><br><span class="line"> <span class="comment"># 卷挂载路径设置，可设置宿主机路径HOST:CONTAINER或加上访问模式HOST:CONTAINER:ro</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="comment"># Just specify a path and let the Engine create a volume</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="comment"># Specify an absolute path mapping</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/opt/data:/var/lib/mysql</span></span><br><span class="line"> <span class="comment"># Path on the host, relative to the Compose file</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">./cache:/tmp/cache</span></span><br><span class="line"> <span class="comment"># User-relative path</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br><span class="line"> <span class="comment"># Named volume</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">datavolume:/var/lib/mysql</span></span><br><span class="line"><span class="comment"># 从另一个服务或者容器挂载卷。可指定只读或可读写，若访问模式未指定，则默认是可读写</span></span><br><span class="line"><span class="attr">volumes_from:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">service_name</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">service_name:ro</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">container:container_name</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">container:container_name:rw</span></span><br><span class="line"><span class="comment"># 设置环境变量，可使用数组或字典，只有一个key的环境变量可在运行Compose的机器上找到对应的值，这有助于加密的或特殊主机的值</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SHOW:</span> <span class="string">'true'</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">SHOW=true</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br><span class="line"><span class="comment"># 从文件中获取环境变量，可为单独的文件路径或列表，若通过docker-compose -f FILE指定了模板文件，则env_file中路径会基于模板文件路径，若有变量名称与environment指令冲突，则以envirment为准</span></span><br><span class="line"><span class="attr">env_file:</span> <span class="string">.env</span></span><br><span class="line"><span class="attr">env_file:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">./common.env</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">./apps/web.env</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/opt/secrets.env</span></span><br><span class="line"><span class="comment"># extends继承另一个服务，基于已有的服务进行扩展</span></span><br><span class="line"><span class="comment"># 设置网络模式</span></span><br><span class="line"><span class="attr">net:</span> <span class="string">"bridge"</span></span><br><span class="line"><span class="attr">net:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">net:</span> <span class="string">"none"</span></span><br><span class="line"><span class="attr">net:</span> <span class="string">"container:[service name or container name/id]"</span></span><br><span class="line"><span class="comment"># 配置dns服务器，可为一个值，也可为一个列表</span></span><br><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"> <span class="bullet">-</span> <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span></span><br><span class="line"><span class="comment"># 配置DNS搜索域，可以是一个值，也可以是一个列表</span></span><br><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dc1.example.com</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dc2.example.com</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.8'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="comment"># 覆盖容器启动后默认执行的启动mysql命令</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mysqld</span> <span class="string">--character-set-server=utf8mb4</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span> </span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>  <span class="comment"># 关机或者重启机器时，docker同时重启容器，一般mysql服务可这么设置，保持服务一直都在</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span> <span class="comment"># 设置root帐号密码</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mysql/data/db:/var/lib/mysql</span> <span class="comment"># 数据文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mysql/data/conf:/etc/mysql/conf.d</span> <span class="comment"># 配置文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mysql/log:/var/log/mysql</span> <span class="comment"># 日志文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span>  <span class="comment">#同步宿主机与容器时间，ro代表readonly只读</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">redis:</span>   </span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:5.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--appendonly</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/redis/data:/data</span> <span class="comment"># 数据文件挂载</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rabbitmq:3.7.25-management</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rabbitmq</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/rabbitmq/data:/var/lib/rabbitmq</span> <span class="comment"># 数据文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/rabbitmq/log:/var/log/rabbitmq</span> <span class="comment"># 日志文件挂载</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5672</span><span class="string">:5672</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">15672</span><span class="string">:15672</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:6.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"cluster.name=elasticsearch"</span> <span class="comment"># 设置集群名称为elasticsearch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"discovery.type=single-node"</span> <span class="comment"># 单一节点模式启动</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span> <span class="comment"># 置使用jvm内存大小，稍微配置大点，不然有可能启动不成功</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/elasticsearch/plugins:/usr/share/elasticsearch/plugins</span><span class="comment"># 插件文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/elasticsearch/data:/usr/share/elasticsearch/data</span><span class="comment"># 数据文件挂载</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kibana:6.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="comment"># 一个compose文件管理的服务可直接用服务名访问，若给服务取别名则可用links实现，如下面的es就是elasticsearch服务别名</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch:es</span> <span class="comment"># 用es这个域名访问elasticsearch服务</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span> <span class="comment"># kibana在elasticsearch启动之后再启动</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"elasticsearch.hosts=http://es:9200"</span> <span class="comment"># 设置访问elasticsearch的地址</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">logstash:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">logstash:6.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">logstash</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 挂载logstash的配置文件，docker对单个文件的挂载需要先在宿主机建好对应文件才能挂载成功</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/logstash/logstash-springboot.conf:/usr/share/logstash/pipeline/logstash.conf</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span> <span class="comment"># kibana在elasticsearch启动之后再启动</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch:es</span> <span class="comment"># 可用es这个域名访问elasticsearch服务</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4560</span><span class="string">:4560</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:3.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mongo/db:/data/db</span> <span class="comment"># 数据文件挂载</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:1.4.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/nacos/logs/:/home/nacos/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8848:8848"</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.5</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span> </span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/conf:/conf</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">rocketmq:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rocketmqinc/rocketmq</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>    </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/rocketmq/logs:/home/rocketmq/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/rocketmq/store:/home/rocketmq/store</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqnamesrv</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rocketmqinc/rocketmq</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqbroker</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>    </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10912</span><span class="string">:10912</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/rocketmq/logs:/home/rocketmq/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/rocketmq/store:/home/rocketmq/store</span></span><br><span class="line">      <span class="comment"># 该配置需要先在宿主机对应目录放好broker.conf配置文件，文件内容参考下面文档</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/rocketmq/conf/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqbroker</span> <span class="string">-n</span> <span class="string">namesrv:9876</span> <span class="string">-c</span> <span class="string">../conf/broker.conf</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_HOME=/usr/lib/jvm/jre</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">console:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">styletang/rocketmq-console-ng</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rocketmq-console-ng</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>    </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8076</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPTS=</span> <span class="string">-Dlogging.level.root=info</span> <span class="string">-Drocketmq.namesrv.addr=rocketmq:9876</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">Dcom.rocketmq.sendMessageWithVIPChannel=false</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = 0</span><br><span class="line">deleteWhen = 04</span><br><span class="line">fileReservedTime = 48</span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line"># 宿主机IP</span><br><span class="line">brokerIP1=192.168.65.42</span><br></pre></td></tr></table></figure><h4 id="docker-compose命令"><a href="#docker-compose命令" class="headerlink" title="docker-compose命令"></a>docker-compose命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看compose内的容器</span><br><span class="line">docker-compose -f docker-compose-app.yml ps</span><br><span class="line"><span class="meta">#</span> 关闭或启动或重启compose内的某个容器</span><br><span class="line">docker-compose -f docker-compose-app.yml stop|start|restart &lt;服务名&gt;</span><br><span class="line"><span class="meta">#</span> 关闭或重启compose所有容器</span><br><span class="line">docker-compose -f docker-compose-app.yml stop|restart</span><br><span class="line"><span class="meta">#</span> 查看compose所有容器的运行日志</span><br><span class="line">docker-compose -f docker-compose-app.yml logs -f</span><br><span class="line"><span class="meta">#</span> 查看compose下某个容器的运行日志</span><br><span class="line">docker-compose -f docker-compose-app.yml logs -f &lt;服务名&gt;</span><br><span class="line"><span class="meta">#</span> 也可以把compose的容器日志输出到日志文件里去，然后用tail -f随时查看</span><br><span class="line">docker-compose -f docker-compose-app.yml logs -f &gt;&gt; myDockerCompose.log &amp;</span><br><span class="line"><span class="meta">#</span> 重新构建有变化的镜像并更新到容器再启动</span><br><span class="line">docker-compose -f docker-compose-app.yml up --build -d</span><br><span class="line"><span class="meta">#</span> 重新创建docker-compose.yml配置有变化的容器并启动</span><br><span class="line">docker-compose -f docker-compose-app.yml up --force-recreate -d</span><br><span class="line"><span class="meta">#</span> 停掉容器再删除容器</span><br><span class="line">docker-compose -f docker-compose-app.yml down</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.8'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">eleven-auth:</span><span class="comment"># 指定服务名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eleven-auth:0.0.1</span>  <span class="comment"># 指定镜像名称</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./eleven</span>   <span class="comment"># 指定Dockfile所在路径</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">eleven-auth</span><span class="comment"># 指定启动容器名称</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8888:8888"</span>   <span class="comment"># 指定端口映射</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8888</span>          <span class="comment"># 声明容器对外暴露的端口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_TOOL_OPTIONS=-Xmx1g</span> <span class="string">-Xms1g</span> <span class="string">-XX:MaxMetaspaceSize=512m</span> <span class="string">-javaagent:/agent/skywalking-agent.jar</span> <span class="string">-DSW_AGENT_NAME=eleven-auth</span> <span class="string">-DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.0.180:11800</span></span><br><span class="line">    <span class="comment"># 访问不在同一个compose文件管理的服务需要用external_links，前提是这些服务都在同一个网络下才能正常访问 </span></span><br><span class="line">    <span class="attr">external_links:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos:nacos</span>  <span class="comment"># 可用nacos这个域名访问nacos服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql:db</span>   <span class="comment"># 可用db这个域名访问mysql服务</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SYS_PTRACE</span>  <span class="comment"># 该参数让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令</span></span><br><span class="line">  <span class="attr">eleven-user:</span><span class="comment"># 指定服务名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eleven-user:0.0.1</span>  <span class="comment"># 指定镜像名称</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./eleven</span>   <span class="comment"># 指定Dockfile所在路径</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">eleven-user</span><span class="comment"># 指定启动容器名称</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8877:8877"</span>   <span class="comment"># 指定端口映射</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8877</span>          <span class="comment"># 声明容器对外暴露的端口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_TOOL_OPTIONS=-Xmx1g</span> <span class="string">-Xms1g</span> <span class="string">-XX:MaxMetaspaceSize=512m</span> <span class="string">-javaagent:/agent/skywalking-agent.jar</span> <span class="string">-DSW_AGENT_NAME=eleven-user</span> <span class="string">-DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.0.180:11800</span></span><br><span class="line">    <span class="comment"># 访问不在同一个compose文件管理的服务需要用external_links，前提是这些服务都在同一个网络下才能正常访问 </span></span><br><span class="line">    <span class="attr">external_links:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos:nacos</span>  <span class="comment"># 可用nacos这个域名访问nacos服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql:db</span>   <span class="comment"># 可用db这个域名访问mysql服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mongo</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbitmq</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SYS_PTRACE</span>  <span class="comment"># 该参数让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eleven-auth</span>  <span class="comment"># authcenter启动之后再启动</span></span><br></pre></td></tr></table></figure><p>有时需要<strong>扩容微服务</strong>，则需要将<strong><code>docker-compose.yml</code></strong>里的服务的<strong>端口映射</strong>和<strong>容器名称</strong>都注释掉，因为不可能两个服务的容器映射到宿主机的同一个端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.8'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">eleven-auth:</span><span class="comment"># 指定服务名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eleven-auth:0.0.1</span>  <span class="comment"># 指定镜像名称</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./eleven</span>   <span class="comment"># 指定Dockfile所在路径</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">eleven-auth</span><span class="comment"># 指定启动容器名称</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8888:8888"</span>   <span class="comment"># 指定端口映射</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8888</span>          <span class="comment"># 声明容器对外暴露的端口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_TOOL_OPTIONS=-Xmx1g</span> <span class="string">-Xms1g</span> <span class="string">-XX:MaxMetaspaceSize=512m</span> <span class="string">-javaagent:/agent/skywalking-agent.jar</span> <span class="string">-DSW_AGENT_NAME=eleven-auth</span> <span class="string">-DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.0.180:11800</span></span><br><span class="line">    <span class="comment"># 访问不在同一个compose文件管理的服务需要用external_links，前提是这些服务都在同一个网络下才能正常访问 </span></span><br><span class="line">    <span class="attr">external_links:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos:nacos</span>  <span class="comment"># 可用nacos这个域名访问nacos服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql:db</span>   <span class="comment"># 可用db这个域名访问mysql服务</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SYS_PTRACE</span>  <span class="comment"># 该参数让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令</span></span><br><span class="line">  <span class="attr">eleven-user:</span><span class="comment"># 指定服务名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eleven-user:0.0.1</span>  <span class="comment"># 指定镜像名称</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./eleven</span>   <span class="comment"># 指定Dockfile所在路径</span></span><br><span class="line">    <span class="comment"># container_name: eleven-user# 指定启动容器名称</span></span><br><span class="line">    <span class="comment"># ports:</span></span><br><span class="line">    <span class="comment">#   - "8877:8877"   # 指定端口映射</span></span><br><span class="line">    <span class="comment"># expose:</span></span><br><span class="line">    <span class="comment">#   - 8877          # 声明容器对外暴露的端口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_TOOL_OPTIONS=-Xmx1g</span> <span class="string">-Xms1g</span> <span class="string">-XX:MaxMetaspaceSize=512m</span> <span class="string">-javaagent:/agent/skywalking-agent.jar</span> <span class="string">-DSW_AGENT_NAME=eleven-user</span> <span class="string">-DSW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.0.180:11800</span></span><br><span class="line">    <span class="comment"># 访问不在同一个compose文件管理的服务需要用external_links，前提是这些服务都在同一个网络下才能正常访问 </span></span><br><span class="line">    <span class="attr">external_links:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos:nacos</span>  <span class="comment"># 可用nacos这个域名访问nacos服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql:db</span>   <span class="comment"># 可用db这个域名访问mysql服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mongo</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbitmq</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SYS_PTRACE</span>  <span class="comment"># 该参数让docker能支持在容器里能执行jdk自带的类似jinfo，jmap这些命令</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eleven-auth</span>  <span class="comment"># authcenter启动之后再启动</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="string">replicas:2</span></span><br></pre></td></tr></table></figure><p>执行如下扩容命令，<strong>服务一旦扩容对应了多个容器，则访问服务名docker会自动负载均衡去访问服务对应的每台容器</strong>，docker compose主要用在<strong>单物理机内扩容</strong>的情况，要做多机扩容还需自己在多个机器上做很多定制化配置，做多物理机扩容一般都会用<strong><code>docker swarm</code></strong>或<strong><code>kubernetes</code></strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 必须先正常编排微服务，然后才能动态扩容，文件有变动，需要重新创建容器</span><br><span class="line">docker-compose -f docker-compose-app.yml up --force-recreate -d     </span><br><span class="line">docker-compose -f docker-compose-app.yml scale eleven-user=2</span><br><span class="line"><span class="meta">#</span> 如果要缩容执行如下操作</span><br><span class="line">docker-compose -f docker-compose-app.yml scale eleven-user=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，若每个微服务都要手动启停，效率很低、维护量很大。可使用&lt;strong&gt;&lt;code&gt;Docker Compose&lt;/code&gt;&lt;/strong&gt;来轻松、高效地管理容器。Docker Compose是
      
    
    </summary>
    
      <category term="云原生" scheme="https://yaoyinglong.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
      <category term="Docker" scheme="https://yaoyinglong.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>模本</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A8%A1%E6%9D%BF/"/>
    <id>https://yaoyinglong.github.io/Blog/模板/</id>
    <published>2022-02-10T16:00:00.000Z</published>
    <updated>2022-02-11T13:11:28.139Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/云原生/Docker基础/</id>
    <published>2022-02-10T16:00:00.000Z</published>
    <updated>2022-02-14T02:19:26.704Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的<strong>容器引擎</strong>，有助于更快地交付应用。 Docker可<strong>将应用程序和基础设施层隔离</strong>，且能<strong>将基础设施当作程序一样进行管理</strong>。使用Docker可<strong>更快地打包</strong>、<strong>测试</strong>以及<strong>部署应用程序</strong>，且<strong>可缩短从编写到部署运行代码的周期</strong>。Docker有如下优点：</p><ul><li><strong>简化程序</strong>：让开发者可打包应用以及依赖包到一个<strong>可移植</strong>的容器中，然后发布到任何流行Linux机器上，便可实现虚拟化。<strong>方便快捷</strong>是Docker最大优势，过去需要用数天乃至数周的任务，在Docker容器处理下只需要数秒就能完成。Docker镜像中包含了<strong>运行环境</strong>和<strong>配置</strong>，所以Docker可<strong>简化部署多种应用实例工作</strong>。</li><li><strong>节省开支</strong>：云计算时代到来，使开发者<strong>不必为了追求效果而配置高额的硬件</strong>，Docker改变了<strong>高性能必然高价格</strong>的思维定势。Docker与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理问题，也改变了虚拟化的方式。</li></ul><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p><img src="../../../../images/云原生/Docker/Docker架构.png" alt></p><h5 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h5><p><strong><code>Docker daemon</code></strong>是<strong>Docker守护进程</strong>是一个<strong>运行在宿主机<code>DOCKER-HOST</code></strong>的后台进程，可通过Docker客户端与之通信。</p><h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><p><strong>Docker客户端</strong>是Docker的<strong>用户界面</strong>，可接受<strong>用户命令</strong>和<strong>配置标识</strong>，并<strong>与<code>Docker daemon</code>通信</strong>。图中<strong><code>docker build</code></strong>等都是Docker的相关命令。</p><h5 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h5><p><strong>Docker镜像</strong>是一个<strong>只读模板</strong>，它包<strong>含创建Docker容器的说明</strong>，<strong>和系统安装光盘有点像</strong>，使用系统安装光盘可安装系统，同理使用Docker镜像可运行Docker镜像中的程序。</p><h5 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h5><p><strong>容器</strong>是<strong>镜像的可运行实例</strong>，<strong>镜像和容器的关系有点类似于面向对象中，类和对象的关系</strong>，可通过Docker API或CLI命令来<strong>启停</strong>、<strong>移动</strong>、<strong>删除容器</strong>。</p><h5 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h5><p><strong><code>Docker Registry</code></strong>是一个<strong>集中存储与分发镜像的服务</strong>，构建完Docker镜像后，可在当前宿主机上运行。若想要在其他机器上运行该镜像，需要手动复制。此时可借助Docker Registry来避免镜像的手动复制。</p><p><strong>一个Docker Registry可包含多个Docker仓库</strong>，每个仓库可包含<strong>多个镜像标签</strong>，每个标签对应一个Docker镜像。这跟Maven的仓库有点类似，若把Docker Registry比作Maven仓库的话，则Docker仓库就可理解为某jar包的路径，而镜像标签则可理解为jar包的版本号。</p><p>Docker Registry可分为公有Docker Registry和私有Docker Registry，最常用的Docker Registry莫过于官方的默认的Docker Hub，Docker Hub上存放着⼤量优秀的镜像，可使用Docker命令下载并使用。</p><h3 id="Docker虚拟化原理"><a href="#Docker虚拟化原理" class="headerlink" title="Docker虚拟化原理"></a>Docker虚拟化原理</h3><p><strong>传统虚拟化技术</strong>是在<strong>硬件层面实现虚拟化</strong>，增加了<strong>系统调用链路的环节</strong>，<strong>有性能损耗</strong>；<strong>容器虚拟化技术</strong>以<strong>共享宿主机<code>Kernel</code>的方式实现</strong>，<strong>几乎没有性能损耗</strong>。</p><p><img src="../../../../images/云原生/Docker/Docker虚拟化原理.png" alt></p><p>Docker利用的是<strong>宿主机的内核</strong>，而<strong>不需要<code>Guest OS</code></strong>，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核，避免了<strong>寻址</strong>、<strong>加载</strong>操作系统内核这些比较费时费资源的过程。当<strong>新建一个虚拟机时</strong>，虚拟机软件需要<strong>加载<code>Guest OS</code></strong>，该新建过程是<strong>分钟级</strong>别的。而Docker由于直接利用宿主机的操作系统，则省略了该过程，因此新建一个Docker容器只需要几秒钟。</p><p><img src="../../../../images/云原生/Docker/容器虚拟化技术与传统虚拟化技术对比.png" alt></p><p>Docker是使用<strong>联合文件系统将机器的资源进行隔离的</strong>，常见的<strong>联合文件系统</strong>有<strong><code>AUFS</code></strong>、<strong><code>Overlay</code></strong>、<strong><code>devicemapper</code></strong>、<strong><code>BTRFS</code></strong>和<strong><code>ZFS</code></strong>等。以Overlay2的架构图为例：</p><p><img src="../../../../images/云原生/Docker/Overlay2联合文件系统架构图.jpeg" alt></p><p><strong><code>Overlayfs</code></strong>在Linux主机上只有<strong>两层</strong>，一个目录在<strong>下层</strong>，用来<strong>保存镜像</strong>(docker)，另外一个目录在<strong>上层</strong>，用来<strong>存储容器信息</strong>。在Overlayfs中，底层的目录叫做<strong><code>lowerdir</code></strong>，顶层的目录称之为<strong><code>upperdir</code></strong>，对外提供统一的文件系统为<strong><code>merged</code></strong>。当需要修改一个文件时，使用<strong>COW(Copy-on-write)写时复制</strong>将文件从<strong>只读的<code>Lower</code>复制到可写的<code>Upper</code>进行修改</strong>，<strong>结果也保存在<code>Upper</code>层</strong>。在<strong><code>Docker</code>中</strong>底下的<strong>只读层</strong>就是<strong><code>image</code></strong>，<strong>可写层</strong>就是<strong><code>Container</code></strong>。</p><h5 id="写时复制技术"><a href="#写时复制技术" class="headerlink" title="写时复制技术"></a>写时复制技术</h5><p><strong>所有驱动都用到写时复制技术</strong>，<strong><code>COW</code></strong>全称copy-on-write，表示<strong>只是在需要写时才去复制</strong>，这是<strong>针对已有文件的修改场景</strong>。如<strong>基于一个Image启动多个Container</strong>，若每个Container都去分配一个Image一样的文件系统，将会占用大量磁盘空间。而COW技术可让所有容器共享Image的文件系统，所有数据都从Image中读取，只有<strong>当要对文件进行写操作时</strong>，<strong>才从<code>Image</code>里把要写的文件复制到自己的文件系统进行修改</strong>。</p><p>无论有多少个容器共享一个Image，所做的<strong>写操作都是对从<code>Image</code>中复制到自己的文件系统的副本上进行</strong>，<strong>并不会修改<code>Image</code>源文件</strong>，且多个容器操作同一个文件，会<strong>在每个容器的文件系统里生成一个副本</strong>，<strong>每个容器修改的都是自己的副本</strong>，<strong>互相隔离互不影响</strong>。使用<strong>COW可有效的提高磁盘的利用率</strong>，故<strong>容器占用空间很少</strong>。</p><h5 id="用时分配"><a href="#用时分配" class="headerlink" title="用时分配"></a>用时分配</h5><p><strong>用时分配</strong>是<strong>针对原本没有该文件的场景</strong>，只有在要新写入一个文件时才分配空间，这样<strong>可提高存储资源的利用率</strong>。如<strong>启动一个容器，并不会因为该容器分配一些磁盘空间</strong>，而是<strong>当有新文件写入时，才按需分配新空间</strong>。</p><h5 id="查看容器占用磁盘大小指令"><a href="#查看容器占用磁盘大小指令" class="headerlink" title="查看容器占用磁盘大小指令"></a>查看容器占用磁盘大小指令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看所有容器的大小</span><br><span class="line">cd /var/lib/docker/containers  # 进入docker容器存储目录</span><br><span class="line">du -sh *  # 查看所有容器的大小</span><br><span class="line">du -sh &lt;容器完整id&gt;  #查看某一个容器的大小</span><br></pre></td></tr></table></figure><h3 id="镜像分层原理"><a href="#镜像分层原理" class="headerlink" title="镜像分层原理"></a>镜像分层原理</h3><p>Docker使用<strong>共享技术减少镜像存储空间</strong>，所有<strong>镜像层</strong>和<strong>容器层</strong>都保存在<strong>宿主机的文件系统<code>/var/lib/docker/</code>中</strong>，<strong>由存储驱动进行管理</strong>，尽管存储方式不尽相同，但在所有版本的Docker中都可<strong>共享镜像层</strong>。在下载镜像时，Docker Daemon会检查镜像中的镜像层与宿主机文件系统中的镜像层进行对比，若存在则不下载，只下载不存在的镜像层，这样可非常<strong>节约存储空间</strong>。<br><img src="../../../../images/云原生/Docker/Docker镜像分层原理1.png" alt></p><h3 id="Docker安装卸载"><a href="#Docker安装卸载" class="headerlink" title="Docker安装卸载"></a>Docker安装卸载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看当前内核版本，Docker要求CentOS系统的内核版本高于3.10</span><br><span class="line">uname -r</span><br><span class="line"><span class="meta">#</span> 使用root权限登录Centos确保yum包更新到最新</span><br><span class="line">yum -y update</span><br><span class="line"><span class="meta">#</span> 若安装过Docker，卸载旧版本</span><br><span class="line">sudo yum remove -y docker*</span><br><span class="line"><span class="meta">#</span> 安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"><span class="meta">#</span> 设置yum源，并更新yum包索引</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta">#</span> 查看所有仓库中所有docker版本，并选择特定版本安装</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span> 安装docker，且指定安装版本</span><br><span class="line">yum install -y docker-ce-3:19.03.9-3.el7.x86_64</span><br><span class="line"><span class="meta">#</span> 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span> 将Docker启动加入开机启动</span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta">#</span> 验证安装是否成功：有client和service两部分表示docker安装启动都成功了</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Docker卸载</span><br><span class="line">yum remove -y docker*</span><br><span class="line">rm -rf /etc/systemd/system/docker.service.d</span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line">rm -rf /var/run/docker</span><br></pre></td></tr></table></figure><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>可借助阿里云的镜像加速器，<a href="https://cr.console.aliyun.com/#/accelerator" rel="external nofollow noopener noreferrer" target="_blank">登录阿里云</a>，在配置<strong><code>daemon.json</code></strong>文件时，若<strong><code>JSON</code></strong>格式有问题会导致Docker启动失败。</p><p><img src="../../../../images/云原生/Docker/阿里云镜像加速器配置.png" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line"><span class="meta">#</span> 查看有没有daemon.json，docker默认的配置文件，若没有则新建，若有则修改</span><br><span class="line">vim daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://x0y2v4jf.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 重启docker服务</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用docker search命令搜索存放在Docker Hub中的镜像，搜索含有java关键词的镜像仓库</span><br><span class="line"><span class="meta">#</span> NAME：镜像仓库名称</span><br><span class="line"><span class="meta">#</span> DESCRIPTION：镜像仓库描述</span><br><span class="line"><span class="meta">#</span> STARS：镜像仓库收藏数，表示该镜像仓库的受欢迎程度，类似于GitHub的stars0</span><br><span class="line"><span class="meta">#</span> OFFICAL：表示是否为官方仓库，该列标记为[0K]的镜像均由各软件的官方项目组创建和维护</span><br><span class="line"><span class="meta">#</span> AUTOMATED：表示是否是自动构建的镜像仓库</span><br><span class="line">docker search java</span><br><span class="line"><span class="meta">#</span> docker pull命令可从Docker Registry上下载镜像，执行该命令后，Docker会从Docker Hub中的nginx仓库下载最新版本的nginx镜像</span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta">#</span> 若要下载指定版本则在java后面加冒号指定版本</span><br><span class="line">docker pull java:8</span><br><span class="line"><span class="meta">#</span> 列出已下载的镜像：REPOSITORY镜像所属仓库名称，TAG镜像标签默认是latest最新，IMAGE ID镜像ID镜像唯一标识，CREATED镜像创建时间，SIZE镜像大小</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h5 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h5><p>通过<strong><code>docker rmi</code></strong>命令删除镜像时，<strong>若不是<code>latest</code>版本</strong>，<strong>删除时需要加上版本号</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 删除指定镜像</span><br><span class="line">docker rmi java</span><br><span class="line"><span class="meta">#</span> 删除指定版本即Tag的镜像</span><br><span class="line">docker rmi java:8</span><br><span class="line">docker rmi -f nginx</span><br><span class="line"><span class="meta">#</span> 删除所有镜像</span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h5 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h5><p>使用<strong><code>docker run</code></strong>命令即可<strong>新建并启动一个容器</strong>，该命令会<strong>先检查本地是否存在指定镜像</strong>，若本地不存在该名称的镜像，Docker就会自动从Docker Hub下载镜像并启动一个 Docker容器，该命令常用选项：</p><ul><li><strong><code>-d</code></strong>选项：表示<strong>后台运行</strong></li><li><strong><code>-P</code></strong>选项：<strong>随机端口映射</strong></li><li><strong><code>-p</code></strong>选项：<strong>指定端口映射</strong>，有以下四种格式<ul><li>–ip:hostPort:containerPort</li><li>–ip::containerPort</li><li>–hostPort:containerPort </li><li>–containerPort</li></ul></li><li><strong><code>--net</code></strong>选项：<strong>指定网络模式</strong>，该选项有以下可选参数<ul><li>–net=<strong><code>bridge</code></strong>：<strong>默认选项</strong>，表示连接到默认的网桥</li><li>–net=host：容器<strong>使用宿主机的网络</strong></li><li>–net=container:NAME-or-ID：告诉Docker让新建的容器使用已有容器的网络配置</li><li>–net=none：不配置该容器的网络，用户可自定义网络配置</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 91:80 nginx</span><br><span class="line"><span class="meta">#</span> 通过--name指定容器名称为nginx_eleven</span><br><span class="line">docker run -d --name nginx_eleven -p 91:80 nginx</span><br><span class="line"><span class="meta">#</span> 启动已停止的容器，若容器已近被创建，但是被停止后不能创建相同名称的容器</span><br><span class="line">docker start nginx_eleven</span><br><span class="line">docker start 31dc1cff48b7</span><br></pre></td></tr></table></figure><h5 id="停止镜像"><a href="#停止镜像" class="headerlink" title="停止镜像"></a>停止镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 31dc1cff48b7是容器ID</span><br><span class="line">docker stop 31dc1cff48b7</span><br><span class="line"><span class="meta">#</span> 使用docker stop容器名称来停止指定容器</span><br><span class="line">docker stop nginx_eleven</span><br><span class="line"><span class="meta">#</span> 发送SIGKILL信号来强制停止容器</span><br><span class="line">docker kill 31dc1cff48b7</span><br><span class="line">docker kill nginx_eleven</span><br></pre></td></tr></table></figure><h5 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 列出运行中的容器</span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span> 列出包括已停止的容器</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p><img src="../../../../images/云原生/Docker/docker ps.png" alt></p><p><strong><code>CONTAINER_ID</code></strong>表示<strong>容器ID</strong>，<strong><code>IMAGE</code></strong>表示<strong>镜像名称</strong>，<strong><code>COMMAND</code></strong>表示<strong>启动容器时运行的命令</strong>，<strong><code>CREATED</code></strong>表示<strong>容器创建时间</strong>，<strong><code>STATUS</code></strong>表示<strong>容器运行状态</strong>，<strong><code>UP</code></strong>表示<strong>运行中</strong>，<strong><code>Exited</code></strong>表示<strong>已停止</strong>，<strong><code>PORTS</code></strong>表示<strong>容器对外端口号</strong>，<strong><code>NAMES</code></strong>表示<strong>容器名称</strong>，该名称默认由Docker自动生成，也可使用<strong><code>docker run</code></strong>命令的<strong><code>--name</code></strong>选项自行指定。</p><h5 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看容器所有信息</span><br><span class="line">docker inspect 31dc1cff48b7</span><br><span class="line">docker inspect nginx_eleven</span><br><span class="line"><span class="meta">#</span> 查看容器日志</span><br><span class="line">docekr container logs nginx_eleven</span><br><span class="line"><span class="meta">#</span> 查看容器里的进程</span><br><span class="line">docker top nginx_eleven</span><br></pre></td></tr></table></figure><p><img src="../../../../images/云原生/Docker/docker top.png" alt></p><h5 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h5><p>使用<strong><code>docker exec</code></strong>命令用于<strong>进入一个正在运行的docker容器</strong>，若<strong><code>docker run</code></strong>命令运行容器时未使用<strong><code>-it</code></strong>参数，就要用该命令进入容器。一旦进入容器就可在容器的Shell执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用exit命令退出容器</span><br><span class="line">docker exec -it 31dc1cff48b7 /bin/bash</span><br><span class="line">docker exec -it nginx_eleven /bin/bash</span><br></pre></td></tr></table></figure><p><img src="../../../../images/云原生/Docker/docker exec -it进入容器.png" alt></p><h5 id="容器与宿主机相互复制文件"><a href="#容器与宿主机相互复制文件" class="headerlink" title="容器与宿主机相互复制文件"></a>容器与宿主机相互复制文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 从容器里面拷文件到宿主机</span><br><span class="line"><span class="meta">#</span> docker cp 容器id或容器名称:要拷贝的文件在容器里面的路径 宿主机的相应路径 </span><br><span class="line">docker cp nginx_eleven:/etc/nginx/nginx.conf /mydata/nginx</span><br><span class="line"><span class="meta">#</span> docker cp 要拷贝的宿主机文件路径 容器id:要拷贝到容器里面对应的路径</span><br><span class="line">docker cp /data/nginx/test.txt nginx_eleven:/etc/nginx/</span><br></pre></td></tr></table></figure><p><img src="../../../../images/云原生/Docker/宿主机文件拷贝到容器中.png" alt></p><h5 id="在容器中安装软件"><a href="#在容器中安装软件" class="headerlink" title="在容器中安装软件"></a>在容器中安装软件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入容器</span><br><span class="line">docker exec -it nginx_eleven /bin/bash</span><br><span class="line"><span class="meta">#</span> 在容器中执行以下命令</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim           # 安装vim</span><br><span class="line">apt-get install iputils-ping  # 安装ping</span><br><span class="line">apt-get install net-tools     # 安装ifconfig</span><br></pre></td></tr></table></figure><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 删除指定容器，只能删除已停止的容器，若需删除正在运行的容器，可使用-f参数</span><br><span class="line">docker rm 31dc1cff48b7</span><br><span class="line">docker rm nginx_eleven</span><br><span class="line"><span class="meta">#</span> 强制删除所有容器</span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure><h5 id="查看容器资源使用情况"><a href="#查看容器资源使用情况" class="headerlink" title="查看容器资源使用情况"></a>查看容器资源使用情况</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stats  # 返回容器资源的实时使用情况，1秒刷新一次</span><br><span class="line">docker stats --no-stream  # 返回容器当时的资源使用情况</span><br></pre></td></tr></table></figure><p><img src="../../../../images/云原生/Docker/docker stats容器资源使用情况.png" alt></p><p><strong><code>CONTAINER ID</code></strong>表示容器ID，<strong><code>CPU %</code></strong>表示CPU使用情况，<strong><code>MEM USAGE / LIMIT</code></strong>当前使用内存和最大可使用内存，<strong><code>MEM %</code></strong>以百分比的形式显示内存使用情况，<strong><code>NET I/O</code></strong>网络I/O数据，<strong><code>BLOCK I/O</code></strong>磁盘I/O数据，<strong><code>PIDS</code></strong>表示PID号。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>可以使用<strong><code>Dockerfile</code></strong>构建Docker镜像，从而将微服务运行在docker上，<strong><code>Dockerfile</code></strong>是一个<strong>文本文件</strong>，其中包含了若干条指令，<strong>指令描述了构建镜像的细节</strong>。在/data/docker/nginx_eleven目录下创建一个名为<strong><code>Dockerfile</code></strong>的文件，在里面增加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo '&lt;h1&gt;This is Tuling Nginx!!!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>其中的<strong><code>FROM</code></strong>、<strong><code>RUN</code></strong>都是Dockerfile的指令，<strong><code>FROM</code></strong>指令用于<strong>指定基础镜像</strong>，<strong><code>RUN</code></strong>指令用于<strong>执行命令</strong>，创建好Dockerfile后通过                <strong><code>docker build</code></strong>命令构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -t指定镜像名字，eleven表示打包的版本号，/data/docker/nginx_eleven为Dockerfile文件路径</span><br><span class="line">docker build -t nginx:eleven /data/docker/nginx_eleven</span><br></pre></td></tr></table></figure><p><img src="../../../../images/云原生/Docker/构建镜像1.png" alt></p><h5 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h5><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><strong><code>FROM</code></strong></td><td><strong>基础镜像文件</strong></td></tr><tr><td><strong><code>RUN</code></strong></td><td><strong>构建镜像阶段执行命令</strong>，执行结果会打包进入image文件，<strong>一个<code>Dockerfile</code>可包含多个<code>RUN</code>命令</strong></td></tr><tr><td><strong><code>ADD</code></strong></td><td><strong>添加文件</strong>，从src目录复制文件到容器的dest，其中src可Dockerfile所在目录相对路径，也可以是一个URL，还可是一个压缩包</td></tr><tr><td><strong><code>COPY</code></strong></td><td><strong>拷贝文件</strong>，和ADD命令类似，但不支持URL和压缩包</td></tr><tr><td><strong><code>CMD</code></strong></td><td>容器<strong>启动后执行命令</strong>，一个<strong><code>Dockerfile</code></strong>只能包含<strong>一个<code>CMD</code>命令</strong>，指定了CMD命令以后，<strong><code>docker container run</code></strong>命令就不能附加命令了，如前面的/bin/bash，否则会覆盖CMD命令</td></tr><tr><td><strong><code>EXPOSE</code></strong></td><td>声明容器在运行时<strong>对外提供的服务端口</strong></td></tr><tr><td><strong><code>WORKDIR</code></strong></td><td>指定<strong>容器工作路径</strong></td></tr><tr><td><strong><code>ENV</code></strong></td><td>指定<strong>环境变量</strong></td></tr><tr><td><strong><code>ENTRYPINT</code></strong></td><td>容器入口， ENTRYPOINT和CMD指令目的一样，都是指定Docker容器启动时执行的命令，可多次设置但只有最后一个有效</td></tr><tr><td><strong><code>USER</code></strong></td><td>该指令用于<strong>设置启动镜像时的用户或<code>UID</code></strong>，写在该指令后的<strong><code>RUN</code></strong>、<strong><code>CMD</code></strong>、<strong><code>ENTRYPOINT</code></strong>指令都将使用该用户执行命令</td></tr><tr><td><strong><code>VOLUME</code></strong></td><td><strong>指定挂载点</strong>，该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可共享给其他容器，当容器中的应用有持久化数据的需求时可在Dockerfile中使用该指令，格式为<strong><code>VOLUME[&quot;/data&quot;]</code></strong></td></tr></tbody></table><h5 id="使用Dockerfile构建微服务镜像"><a href="#使用Dockerfile构建微服务镜像" class="headerlink" title="使用Dockerfile构建微服务镜像"></a>使用Dockerfile构建微服务镜像</h5><p>以eureka-server为例，将该微服务的可运行jar包构建成docker镜像，首先将该jar包上传到<strong><code>/data/docker/eureka</code></strong>目录，并在jar包所在目录创建名为<strong><code>Dockerfile</code></strong>的文件，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 基于哪个镜像</span><br><span class="line">From java:8</span><br><span class="line"><span class="meta">#</span> 复制文件到容器</span><br><span class="line">ADD eureka-server-0.0.1-SNAPSHOT.jar /app.jar</span><br><span class="line"><span class="meta">#</span> 声明需要暴露的端口</span><br><span class="line">EXPOSE 8761</span><br><span class="line"><span class="meta">#</span> 配置容器启动后执行的命令</span><br><span class="line">ENTRYPOINT java $&#123;JAVA_OPTS&#125; -jar /app.jar</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用docker build命令构建镜像</span><br><span class="line">docker build -t eleven-eureka-server:0.0.1 /data/docker/eureka</span><br><span class="line"><span class="meta">#</span> 启动镜像，加-d可在后台启动</span><br><span class="line">docker run -d -p 8761:8761 eleven-eureka-server:0.0.1</span><br><span class="line"><span class="meta">#</span> 使用-v可挂载一个主机上的目录到容器的目录</span><br><span class="line">docker run -d -p 8761:8761 -v /log:/container-log eleven-eureka-server:0.0.1</span><br><span class="line"><span class="meta">#</span> 加上JVM参数</span><br><span class="line"><span class="meta">#</span> 参数--cap-add=SYS_PTRACE是让docker能支持在容器里能执行jdk自带类似jinfo，jmap等命令，若不需要在容器里执行这些命令可不加</span><br><span class="line">docker run -e JAVA_OPTS='-Xms1028M -Xmx1028M -Xmn512M -Xss512K -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M' --cap-add=SYS_PTRACE -d -p 8761:8761 eleven-eureka-server:0.0.1</span><br></pre></td></tr></table></figure><h5 id="将微服务镜像发布到远程镜像仓库"><a href="#将微服务镜像发布到远程镜像仓库" class="headerlink" title="将微服务镜像发布到远程镜像仓库"></a>将微服务镜像发布到远程镜像仓库</h5><p>制作好微服务镜像，一般需要发布到镜像仓库供别人使用，可选择自建镜像仓库，也可直接使用docker<a href="https://hub.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">官方镜像仓库</a>，首先需要在docke官方镜像仓库里注册一个账号，然后在Linux服务器上用<strong><code>docker login</code></strong>命令登录镜像仓库，要把镜像推送到镜像仓库，需要将镜像前面加个分组名，一般为docker hub的账户名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line"><span class="meta">#</span> 修改镜像名字</span><br><span class="line">docker tag eleven-eureka-server:0.0.1 eleven/eleven-eureka-server:0.0.1</span><br><span class="line"><span class="meta">#</span> 将镜像推送到远程仓库</span><br><span class="line">docker push eleven/eleven-eureka-server:0.0.1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker是一个开源的&lt;strong&gt;容器引擎&lt;/strong&gt;，有助于更快地交付应用。 Docker可&lt;strong&gt;将应用程序和基础设施层隔离&lt;/strong&gt;，且能&lt;strong&gt;将基础设施当作程序一样进行管理&lt;/strong&gt;。使用Docker可&lt;strong&gt;更
      
    
    </summary>
    
      <category term="云原生" scheme="https://yaoyinglong.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
      <category term="云原生" scheme="https://yaoyinglong.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>模本</title>
    <link href="https://yaoyinglong.github.io/Blog/%E5%A4%A7%E6%95%B0%E6%8D%AE/Clickhouse%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/大数据/Clickhouse基础/</id>
    <published>2022-02-10T16:00:00.000Z</published>
    <updated>2022-02-11T13:11:28.139Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP&amp;UDP协议</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/TCP&amp;UDP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/协议族/TCP&amp;UDP协议/</id>
    <published>2022-02-10T16:00:00.000Z</published>
    <updated>2022-07-21T14:55:58.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP是<strong>面向连接的、可靠的、基于字节流</strong>的<strong>传输层</strong>通信协议，且TCP连接是<strong>全双工</strong>的。TCP会将数据临时存储到连接的<strong>发送缓存<code>send buffer</code></strong>中，该send buffer是三次握手之间设置的缓存之⼀，然后TCP在合适的时间将发送缓存中的数据发送到目标主机的接收缓存中。</p><ul><li><p><strong>面向连接</strong>：一定是<strong>一对一</strong>才能连接，不能像UDP协议一对多即可一个主机同时向多个主机发送消息</p></li><li><p><strong>可靠的</strong>：无论网络链路中出现怎样的链路变化，TCP都可保证一个报文一定能够到达接收端</p></li><li><p><strong>字节流</strong>：<strong>消息没有边界</strong>，无论消息有多大都可进行传输，且消息是<strong>有序的</strong>，当前一个消息没有收到时，即使它先收到后面的字节，也不能扔给应用层去处理，同时<strong>对重复的报文会自动丢弃</strong></p></li></ul><p><img src="../../../../../images/网络/TCP通信发送缓冲.png" alt></p><p>主机之间的发送是以<strong>报文段Segment</strong>进行的，TCP会将要<strong>传输的数据流</strong>分为多个<strong><code>Chunk</code>块</strong>，然后向每个Chunk块中添加<strong><code>TCP</code>标头</strong>，这样就形成了⼀个TCP段即<strong>报文段</strong>。</p><p>每⼀个报文段可传输的长度是有限的，不能超过<strong>最大数据长度<code>Maximum Segment Size</code>即<code>MSS</code></strong>，在报文段向下传输过程中<strong>会经过链路层</strong>，<strong>数据链路层上所能通过最大数据包大小<code>Maximum Transmission Unit</code>最大传输单元<code>MTU</code></strong>，最大传输单元<strong>通常与通信接口有关</strong>。</p><h5 id="MSS和MTU区别"><a href="#MSS和MTU区别" class="headerlink" title="MSS和MTU区别"></a>MSS和MTU区别</h5><p>计算机网络是分层的，不同层的称呼不⼀样，对于<strong>传输层</strong>来说称为<strong>报文段</strong>，而对<strong>网络层</strong>来说叫做<strong><code>IP</code>数据包</strong>，故<strong><code>MTU</code></strong>可认为是<strong>网络层能够传输的最大<code>IP</code>数据包</strong>，而<strong><code>MSS</code></strong>可认为是<strong>传输层</strong>的概念，即<strong>TCP数据包每次能够传输的最大量</strong>。</p><h5 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h5><p><img src="../../../../../images/网络/TCP头格式.png" alt="TCP头格式"></p><p>TCP各种功能和特点都是通过TCP报⽂结构来体现的</p><ul><li><strong>序列号</strong>：用来<strong>解决网络包乱序问题</strong>，在建立连接时由计算机生成的<strong>随机数</strong>作为其<strong>初始值</strong>，通过<strong><code>SYN</code>包</strong>传给接收端主机，<strong>每发送一次数据就累加一次该数据字节数大小</strong></li><li><strong>确认应答号</strong>：<strong>用于解决不丢包问题，下一次期望收到的数据的序列号</strong>，发送端收到该确认应答以后可认为<strong>在该序号以前的数据都已经被正常接收</strong></li><li><strong>控制位：</strong><ul><li><strong><code>ACK</code></strong>：该位为 <strong><code>1</code></strong> 时<strong>确认应答字段变为有效</strong>，TCP规定<strong>除了最初建立连接时的<code>SYN</code>包之外</strong>该位必须设置为<code>1</code> </li><li><strong><code>RST</code></strong>：该位为<strong><code>1</code></strong>时，表示<strong>TCP连接中出现异常必须强制断开连接</strong></li><li><strong><code>SYC</code></strong>：该位为<strong><code>1</code></strong>时，表示<strong>希望建立连</strong>并在其<strong>序列号字段</strong>进行<strong>序列号初始值的设定</strong></li><li><strong><code>FIN</code></strong>：该位为<strong><code>1</code></strong>时，表示<strong>之后不会再有数据发送</strong>，<strong>希望断开连接</strong>。<strong>当通信结束希望断开连接时</strong>，通信双方的主机之间就可<strong>相互交换<code>FIN</code>位置为<code>1</code>的TCP段</strong></li></ul></li></ul><h4 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h4><p>TCP是面向连接的协议，故使用TCP前必须先建立连接，而<strong>建立连接是通过三次握手而进行的</strong>。</p><p><img src="../../../../../images/网络/TCP连接建立-三次握手过程.png" alt="三次握手过程状态变更"></p><p>一开始<strong>客户端</strong>和<strong>服务端</strong>都处于<strong><code>CLOSED</code></strong>状态，先是<strong>服务端主动监听某个端口</strong>处于<strong><code>LISTEN</code></strong>状态，<strong>客户端</strong>会<strong>随机初始化序号<code>client_isn</code></strong>，将此序号置于TCP首部的序号字段中，同时把<strong><code>SYN</code></strong>标志位置为 <code>1</code>表示<code>SYN</code>报文，接着<strong>把第一个SYN报文发送给服务端</strong>，表示<strong>向服务端发起连接</strong>，<strong>该报文不包含应用层数据</strong>，之后客户端处于<strong><code>SYN-SENT</code></strong>状态。</p><p><img src="../../../../../images/网络/三次握手第一个报文SYN报文.png" alt="三次握手第一个报文-SYN报文"></p><p><strong>服务端</strong>收到客户端的<strong><code>SYN</code>报文</strong>后，首先<strong>服务端也随机初始化自己的序号<code>server_isn</code></strong>，将此序号<strong>填入TCP首部的序号字段</strong>中，其次把TCP首部的<strong>确认应答号</strong>字段填入<strong><code>client_isn + 1</code></strong>，接着把<strong><code>SYN</code></strong>和<strong><code>ACK</code></strong>标志位置为<code>1</code>，最后把该报文发给客户端，<strong>该报文也不包含应用层数据</strong>，之后<strong>服务端处于<code>SYN-RCVD</code>状态</strong>。</p><p><img src="../../../../../images/网络/三次握手第二个报文SYN+ACK报文.png" alt="三次握手第二个报文-SYN+ACK报文"></p><p>客户端收到服务端报文后还要<strong>向服务端回应最后一个应答报文</strong>，首先该应答报文TCP首部<code>ACK</code>标志位置为<code>1</code> ，其次<strong>确认应答号</strong>字段填入<strong><code>server_isn + 1</code></strong>，最后<strong>把报文发送给服务端</strong>，该报文<strong>可携带客户到服务器的数据</strong>，之后<strong>客户端处于<code>ESTABLISHED</code>状态</strong>。服务器收到客户端的应答报文后，<strong>服务端也进入<code>ESTABLISHED</code>状态</strong>。</p><p><img src="../../../../../images/网络/三次握手第三个报文ACK报文.png" alt="三次握手第三个报文-ACK报文"></p><p>从上面的过程可发现<strong>第三次握手可携带数据，前两次握手不可携带数据</strong>，一旦完成三次握手，双方都处于<strong><code>ESTABLISHED</code>状态</strong>，至此连接已建立完成，客户端和服务端就可相互发送数据了。</p><p>使用三次握手建立连接的目的：<strong>阻止历史重复连接的初始化</strong>、<strong>同步双方的初始序列号</strong>、<strong>避免资源浪费</strong></p><h5 id="避免历史连接"><a href="#避免历史连接" class="headerlink" title="避免历史连接"></a>避免历史连接</h5><p><strong>防止旧的重复连接初始化造成混乱</strong>，网络环境是错综复杂的，往往并不是如期望的一样，先发送的数据包，就先到达目标主机，可能会由于网络拥堵等原因，会使得旧的数据包，先到达目标主机</p><p><img src="../../../../../images/网络/三次握手避免历史连接.png" alt="三次握手避免历史连接"></p><p><strong>客户端连续发送多次SYN建立连接的报文</strong>，在<strong>网络拥堵</strong>等情况下，一个<strong>旧SYN报文</strong>比<strong>最新的SYN报文早到达服务端</strong>，此时服务端回一个<code>SYN + ACK</code>报文给客户端，客户端收到后可根据自身的上下文，判断这是一个<strong>历史连接</strong>即<strong>序列号过期或超时</strong>，客户端就会发送<code>RST</code>报文给服务端，表示<strong>中止这一次连接</strong></p><p>若是<strong>两次握手连接</strong>，就不能判断当前连接是否是历史连接，三次握手则可在<strong>客户端</strong>即<strong>发送方</strong>准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p><ul><li>若是<strong>历史连接</strong>即<strong>序列号过期或超时</strong>，则<strong>第三次握手</strong>发送的报文是<code>RST</code>报文，以此<strong>中止历史连接</strong></li><li>若<strong>不是历史连接</strong>，则第三次发送的报文是<code>ACK</code>报文，通信双方就会成功建立连接</li></ul><h5 id="同步双方初始序列号"><a href="#同步双方初始序列号" class="headerlink" title="同步双方初始序列号"></a>同步双方初始序列号</h5><p>TCP协议的通信双方，都必须维护一个<strong>序列号</strong>，<strong>序列号是可靠传输的一个关键因素</strong>，序列号作用：<strong>接收方可去除重复数据</strong>；<strong>接收方可根据数据包的序列号按序接收</strong>；可<strong>标识发送出去的数据包中哪些是已经被对方收到的</strong>；</p><p><strong>序列号</strong>在TCP连接中占据着非常重要的作用，当客户端发送携带<strong>初始序列号</strong>的<code>SYN</code>报文时，需要服务端回一个<code>ACK</code>应答报文，表示客户端SYN报文已被服务端成功接收，当服务端发送初始序列号给客户端时，也要得到客户端的应答回应，<strong>这样一来一回才能确保双方的初始序列号能被可靠的同步</strong>。</p><p><img src="../../../../../images/网络/三次握手vs四次握手.png" alt></p><p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了三次握手，而<strong>两次握手只保证了一方的初始序列号能被对方成功接收</strong>，<strong>无法保证双方的初始序列号都能被确认接收</strong>。</p><h5 id="避免资源浪费"><a href="#避免资源浪费" class="headerlink" title="避免资源浪费"></a>避免资源浪费</h5><p><strong>若只有两次握手</strong>，当客户端<code>SYN</code>请求连接在网络中阻塞，客户端没有接收到<code>ACK</code>报文，就会<strong>重新发送<code>SYN</code></strong>，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的<code>ACK</code>确认信号，故每收到一个<code>SYN</code>就只能先主动建立一个连接，若客户端<code>SYN</code>阻塞了，重复发送多次<code>SYN</code>报文，服务器在收到请求后就会<strong>建立多个冗余的无效链接</strong>，造成不必要的资源浪费。即两次握手会造成消息滞留情况下，服务器重复接收无用的连接请求<code>SYN</code>报文，而造成重复分配资源。</p><p><img src="../../../../../images/网络/两次握手.png" alt="两次握手"></p><h4 id="TCP连接断开"><a href="#TCP连接断开" class="headerlink" title="TCP连接断开"></a>TCP连接断开</h4><p><img src="../../../../../images/网络/TCP连接断开-四次挥手.png" alt="TCP连接断开-四次挥手"></p><p>TCP断开连接是通过<strong>四次挥手</strong>方式，<strong>双方都可主动断开连接</strong>，断开连接后主机中的资源将被释放，<strong>四次挥手过程</strong>，每个方向都需要<strong>一个<code>FIN</code>和一个<code>ACK</code></strong>，因此通常被称为<strong>四次挥手</strong>，且<strong>主动关闭连接才有<code>TIME_WAIT</code>状态</strong>：</p><ul><li><strong>客户端准备关闭连接</strong>时发送一个TCP首部<strong><code>FIN</code></strong>标志位被置为<code>1</code>的报文后，<strong>客户端</strong>进入<strong><code>FIN_WAIT_1</code>状态</strong></li><li><strong>服务端收到FIN报文后</strong>向客户端发送<strong><code>ACK</code></strong>应答报文后，<strong>服务端</strong>进入<strong><code>CLOSED_WAIT</code>状态</strong></li><li><strong>客户端收到服务端<code>ACK</code>应答报文</strong>后，<strong>客户端</strong>进入<strong><code>FIN_WAIT_2</code>状态</strong></li><li>等待<strong>服务端处理完数据后</strong>，也向客户端发送<strong><code>FIN</code>报文</strong>，之后<strong>服务端</strong>进入<strong><code>LAST_ACK</code>状态</strong></li><li><strong>客户端</strong>收到<strong>服务端<code>FIN</code>报文</strong>后，回一个<code>ACK</code>应答报文后，<strong>客户端</strong>进入<strong><code>TIME_WAIT</code>状态</strong></li><li><strong>服务端</strong>收到<code>ACK</code>应答报文后，进入<strong><code>CLOSE</code>状态</strong>，至此服务端已经完成连接的关闭</li><li>客户端在经过<strong><code>2MSL</code></strong>一段时间后，自动进入<code>CLOSE</code>状态，至此客户端也完成连接的关闭</li></ul><p>关闭连接时<strong>客户端向服务端发送<code>FIN</code>时</strong>，仅<strong>表示客户端不再发送数据但还能接收数据</strong>，服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而<strong>服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。<strong>服务端通常需要等待完成数据的发送和处理</strong>，故<strong>服务端<code>ACK</code>和<code>FIN</code>一般会分开发送</strong>，<strong>从而比三次握手导致多了一次</strong>。</p><h5 id="TIME-WAIT等待的2MSL时间"><a href="#TIME-WAIT等待的2MSL时间" class="headerlink" title="TIME_WAIT等待的2MSL时间"></a>TIME_WAIT等待的2MSL时间</h5><p><strong><code>MSL</code></strong>即<strong><code>Maximum Segment Lifetime</code>报文最大生存时间</strong>，它是<strong>任何报文在网络上存在的最长时间</strong>，<strong>超过该时间报文将被丢弃</strong>。因为TCP报文基于是IP协议的，而<strong>IP头</strong>中有一个<strong><code>TTL</code></strong>字段，是<strong><code>IP</code>数据报文可经过的最大路由数</strong>，每经过一个处理他的路由器<strong><code>TTL</code></strong>值减<strong><code>1</code></strong>，当<strong><code>TTL</code></strong>值为<strong><code>0</code></strong>则<strong>数据报将被丢弃</strong>，同时<strong>发送<code>ICMP</code>报文通知源主机</strong>。</p><p><strong>MSL单位是时间</strong>，而<strong>TTL单位是经过路由条数</strong>。故<strong><code>MSL</code>应该要大于等于<code>TTL</code>消耗为<code>0</code>的时间</strong>，以<strong>确保报文已被自然消亡</strong>。</p><p><strong><code>TIME_WAIT</code></strong>等待<strong>2倍<code>MSL</code></strong>，因为网络中可能存在<strong>来自发送方的数据包</strong>，当这些<strong>发送方的数据包被接收方处理后又会向对方发送响应</strong>，故<strong>一来一回需要等待2倍的时间</strong>。若<strong>被动关闭方</strong>没有收到断开连接的<strong>最后的<code>ACK</code>报文</strong>，就会触发超时<strong>重发<code>FIN</code>报文</strong>，另一方接收到FIN后，会重发ACK给被动关闭方， 一来一去正好2个MSL。</p><p><strong><code>2MSL</code></strong>时间是从<strong>客户端接收到<code>FIN</code>后发送<code>ACK</code>开始计时的</strong>，若在<strong><code>TIME-WAIT</code></strong>时间内，因为客户端的ACK没有传输到服务端，<strong>客户端又接收到了服务端重发的<code>FIN</code>报文</strong>，则<strong><code>2MSL</code>时间将重新计时</strong>。在Linux系统里<strong><code>2MSL</code></strong>默认是<code>60</code>秒，则一个<code>MSL</code>即<code>30</code> 秒。<strong>Linux系统停留在<code>TIME_WAIT</code>的时间为固定的60 秒</strong>。</p><h5 id="TIME-WAIT状态的作用"><a href="#TIME-WAIT状态的作用" class="headerlink" title="TIME_WAIT状态的作用"></a>TIME_WAIT状态的作用</h5><p><strong>主动发起关闭连接的一方</strong>才会有<strong><code>TIME-WAIT</code>状态</strong>，需要TIME-WAIT状态主要是两个原因：<strong>防止具有相同四元组的旧数据包被收到</strong>；<strong>保证被动关闭连接的一方能被正确的关闭</strong>，即保证最后的ACK能让被动关闭方接收，从而帮助其正常关闭；</p><p><strong>防止旧连接的数据包</strong>，假设<strong><code>TIME-WAIT</code></strong>没有等待时间或时间过短，被延迟的数据包抵达，服务端在关闭连接之前发送的<code>SEQ = 301</code>报文被网络延迟，此时有相同端口的TCP连接被复用后，被延迟的<code>SEQ = 301</code>抵达客户端，客户端有可能正常接收该过期报文，则会<strong>产生数据错乱等严重的问题</strong>。故TCP设计出了经过<strong><code>2MSL</code></strong>时间机制，<strong>让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</strong>。</p><p><img src="../../../../../images/网络/TIME-WAIT防止旧连接数据包被收到.png" alt="TIME-WAIT防止旧连接数据包被收到"></p><p><strong><code>TIME-WAIT</code></strong>作用是<strong>等待足够的时间以确保最后的<code>ACK</code>能让被动关闭方接收</strong>，从而帮助其正常关闭。客户端四次挥手的最后一个<code>ACK</code>报文若在网络中被丢失，此时若客户端<code>TIME-WAIT</code>过短或没有，则直接进入了<code>CLOSE</code>状态，<strong>服务端会一直处在<code>LASE-ACK</code>状态</strong>。当客户端发起建立连接的<code>SYN</code>请求报文后，服务端会发送<code>RST</code>报文给客户端，连接建立的过程就会被终止。</p><p>若<strong><code>TIME-WAIT</code></strong>等待足够长的情况就会遇到两种情况：服务端正常收到四次挥手的最后一个<code>ACK</code>报文，则服务端正常关闭连接。服务端没有收到四次挥手的最后一个<code>ACK</code>报文时，则会重发<code>FIN</code>关闭连接报文并等待新的<code>ACK</code>报文。故客户端在<code>TIME-WAIT</code>状态等待<code>2MSL</code>时间后，就能<strong>保证双方连接都可正常关闭</strong>。</p><p><img src="../../../../../images/网络/TIME-WAIT保证连接正确关闭.png" alt="TIME-WAIT保证连接正确关闭"></p><h4 id="TCP可靠性传输"><a href="#TCP可靠性传输" class="headerlink" title="TCP可靠性传输"></a>TCP可靠性传输</h4><p>为了实现可靠性传输，需要考虑很多事情，如<strong>数据破坏</strong>、<strong>丢包</strong>、<strong>重复</strong>以及<strong>分片顺序混乱</strong>等问题。TCP是<strong>通过序列号</strong>、<strong>确认应答</strong>、<strong>重发控制</strong>、<strong>连接管理</strong>以及<strong>窗口控制</strong>等机制<strong>实现可靠性传输</strong>的。</p><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p><strong>发送方不能无脑的发数据给接收方</strong>，要考虑接收方处理能力，若一直无脑的发数据给对方，但对方<strong>处理不过来</strong>，会<strong>导致触发重发机制</strong>，从而<strong>导致网络流量的无端的浪费</strong>。</p><p>为了解决这种现象发生，TCP提供一种机制可<strong>让发送方根据接收方的实际接收能力控制发送的数据量</strong>，即所谓的<strong>流量控制</strong>。TCP通过⼀个<strong>接收窗口<code>receive window</code></strong>的变量来<strong>提供流量控制</strong>。<strong>接收窗口</strong>会给发送方⼀个指示到底还<strong>有多少可用的缓存空间</strong>，发送端会根据接收端的实际接受能力来控制发送的数据量。</p><p><strong>接收端主机向发送端主机通知自己可接收数据的大小</strong>，发送端会<strong>发送不超过该限度的数据</strong>，该大小限度就是窗⼝大小，TCP首部有⼀个接收窗口，该字段用于流量控制，<strong>用于指示接收方能够够或愿意接收的字节数量</strong>。</p><p>发送端主机会<strong>定期发送⼀个窗口探测包</strong> ，该包用于探测接收端主机是否还能够接受数据，<strong>当接收端的缓冲区⼀旦面临数据溢出的风险时</strong>，窗口大小值也随之被设置为⼀个更小的值通知发送端，从而控制数据发送量。</p><p><img src="../../../../../images/网络/TCP流量控制.png" alt="TCP流量控制"></p><p>当主机B收到报文段2000-2999之后缓冲区已满，不得不暂时停止接收数据，然后主机A发送窗口探测包，<strong>窗口探测包非常小仅仅⼀个字节</strong>。然后主机B更新缓冲区接收窗口大小并发送窗口更新通知给主机A，然后主机A再继续发送报⽂段。<strong>窗口更新通知可能会丢失</strong>，⼀旦丢失发送端就不会发送数据，故窗口探测包会<strong>随机发送</strong>，以避免这种情况发⽣。</p><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><p>流量控制是避免发送方的数据填满接收方的缓存，但是并不知道网络的中发生了什么，一般来说计算机网络都处在一个共享的环境。因此<strong>可能会因为其他主机之间的通信使得网络拥堵</strong>。</p><p>在<strong>网络出现拥堵时</strong>，若<strong>继续发送大量数据包</strong>，可能会<strong>导致数据包时延</strong>、<strong>丢失</strong>等，此时TCP就<strong>会重传数据</strong>，<strong>但重传会导致网络负担更重</strong>，于是会导致更大的延迟以及更多的丢包，该情况会进入恶性循环被不断地放大。</p><p>TCP被设计成一个<strong>无私的协议</strong>，当网络发送拥塞时，TCP会<strong>自我牺牲降低发送的数据量</strong>，于是就有了<strong>拥塞控制</strong>，控制目的是<strong>避免发送方的数据填满整个网络</strong>，为了在发送方调节所要发送数据的量，定义了一个叫做<strong>拥塞窗口</strong>。</p><p><strong>拥塞窗口<code>cwnd</code></strong>是<strong>发送方维护的一个的状态变量</strong>，它会根据<strong>网络拥塞程度动态变化</strong>，发送窗口<code>swnd</code>和接收窗口 <code>rwnd</code>是约等于的关系，由于入了拥塞窗口，此时<strong>发送窗口的值是<code>swnd = min(cwnd, rwnd)</code></strong>，即<strong>拥塞窗口和接收窗口中的最小值</strong>。</p><p>拥塞窗口<code>cwnd</code>变化的规则：只要网络中没有出现拥塞，<code>cwnd</code>就会增大；若网络中出现拥塞，<code>cwnd</code>就减少；只要<strong>发送方没有在规定时间内接收到ACK应答报文</strong>，即<strong>发生了超时重传就认为网络出现了用拥塞</strong>。TCP<strong>拥塞控制算法</strong>主要包含<strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>快速恢复</strong>三部分。</p><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>当⼀条TCP开始建立连接时，<strong>拥塞窗口</strong>的值就会<strong>初始化为⼀个<code>MSS</code>的较小值</strong>，这使得初始发送速率大概是<strong><code>MSS/RTT</code>字节/秒</strong> ，若要传输1000字节的数据RTT为200ms ，则得到的初始发送速率大概是40kb/s。实际情况下可用带宽要比该<strong><code>MSS/RTT</code></strong>大得多，因此<strong>TCP想要找到最佳的发送速率可通过慢启动的方式</strong>，在慢启动方式中<strong>拥塞窗口</strong>的值会<strong>初始化为1个MSS</strong>，且每次传输报问确认后会增加⼀个MSS，<strong>拥塞窗口</strong>的值会变为2个MSS，这两个报文段都传输成功后每个报文段<strong><code>+1</code></strong>，会变为4个MSS，依此类推每成功⼀次<strong>拥塞窗口</strong>的值就会翻倍。</p><p><img src="../../../../../images/网络/慢启动.png" alt="慢启动"></p><p>发送速率不可能会⼀直增⻓，增长总有结束的时候，慢启动通常会使用下面这几种方式结束发送速率的增⻓：</p><ul><li>若在<strong>慢启动的发送过程出现丢包</strong>情况，TCP会将发送方的<strong>拥塞窗口</strong>设置为<strong><code>1</code></strong>并<strong>重新开始慢启动过程</strong>，<strong>慢启动阈值</strong>初始值就是<strong>产生丢包</strong>的<strong>拥塞窗口</strong>的值<strong>除2</strong>，即当检测到拥塞时，<strong>慢启动阈值</strong>就变成窗⼝值的⼀半</li><li>因为当检测到拥塞时，<strong>慢启动阈值</strong>就是窗口值的⼀半，则当<strong>拥塞窗口</strong>大于<strong>慢启动阈值</strong>时，<strong>每次翻番都可能会出现丢包</strong>，故最好的方式使<strong>拥塞窗口</strong>值等于<strong>慢启动阈值</strong>，这样TCP就会转为<strong>拥塞控制模式</strong>，结束慢启动</li><li>若<strong>检测到3个冗余<code>ACK</code></strong>，TCP就会执行⼀种<strong>快速重传并进入恢复状态</strong></li></ul><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p><strong>当TCP进入拥塞控制状态后</strong>，<strong>拥塞窗口</strong>值就等于<strong>拥塞时值的⼀半</strong>即<strong>慢启动阈值</strong>。故无法每次报文段到达后都将<strong>拥塞窗口</strong>值再翻倍。而是采⽤了⼀种相对保守的方式，每次传输完成后只将<strong>拥塞窗口</strong>的值增加⼀个<strong><code>MSS</code></strong>，如收到10个报问段的确认，但<strong>拥塞窗口</strong>值只增加⼀个MSS。这是⼀种线性增长模式，它也会有增长阈值，它的增长阈值和慢启动⼀样，若出现丢包，则<strong>拥塞窗口</strong>值就是⼀个MSS，<strong>慢启动阈值</strong>就等于<strong>拥塞窗口</strong>的⼀半；或是收到3个冗余ACK响应也能停止MSS增⻓。若TCP将<strong>拥塞窗口</strong>值减半后，仍会收到3个冗余ACK，则将<strong>慢启动阈值</strong>记录为<strong>拥塞窗口</strong>值的⼀半，进入快速恢复状态。</p><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>在快速恢复中，对于使TCP进入快速恢复状态缺失的报⽂段，对于<strong>每个收到的冗余ACK</strong>，<strong>拥塞窗口</strong>值都会增加⼀个MSS。当对丢失报文段的⼀个ACK到达时，TCP在降低<strong>拥塞窗口</strong>后进入拥塞避免状态。若在拥塞控制状态后出现超时，则会<strong>迁移到慢启动状态</strong>，<strong>拥塞窗口</strong>的值被设置为1个MSS，<strong>慢启动阈值</strong>设置为<strong>拥塞窗口</strong>的⼀半。</p><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>TCP实现可靠传输的方式之一，是<strong>通过序列号</strong>与<strong>确认应答</strong>，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。但在错综复杂的网络，并不一定能顺利正常的数据传输，TCP针对数据包丢失情况用<strong>重传机制</strong>解决：<strong>超时重传</strong>、<strong>快速重传</strong>、<strong><code>SACK</code></strong>、<strong><code>D-SACK</code></strong></p><p><img src="../../../../../images/网络/确认应答.png" alt></p><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>在<strong>发送数据时设定一个定时器</strong>，当超过指定的时间后，没有收到对方的<code>ACK</code>确认应答报文，就会重发该数据，TCP 会在<strong>数据包丢失</strong>、<strong>确认应答丢失</strong>两种情况发生超时重传。</p><p><img src="../../../../../images/网络/超时重传.png" alt></p><p>若<strong>超时重发数据再次超时时</strong>，又需要重传时，TCP的策略是<strong>超时间隔加倍</strong>，即<strong>每当遇到一次超时重传时，都会将下一次超时时间间隔设为先前值的两倍。两次超时说明网络环境差，不宜频繁反复发送</strong>。超时触发重传<strong>超时周期可能相对较长</strong>，可使用<strong>快速重传</strong>机制来解决<strong>超时重发的时间等待</strong>。</p><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p><strong>快速重传不以时间为驱动，而是以数据驱动重传</strong>，发送方发出了1，2，3，4，5份数据，第一份Seq1先送到了，于是就Ack回2；结果Seq2因为某些原因没收到，Seq3到达了，于是还是Ack回2；后面的Seq4和Seq5都到了，但还是Ack回2，因为Seq2还是没有收到；</p><p>发送端收到了三个Ack = 2的确认，知道了Seq2还没有收到，就会在定时器过期之前，重传丢失的Seq2，最后接收到收到了Seq2，此时因为Seq3，Seq4，Seq5都收到了，于是Ack回6。</p><p><img src="../../../../../images/网络/快速重传.png" alt></p><p>快速重传的工作方式是<strong>当收到三个相同的ACK报文时</strong>，会<strong>在定时器过期之前</strong>，<strong>重传丢失的报文段</strong>，快速重传机制只解决了一个问题，即超时时间的问题，但它不能解决在<strong>重传时是重传之前的一个，还是重传所有的</strong>。</p><p>上面的例子是重传Seq2还是重传Seq2、Seq3、Seq4、Seq5，发送端并不清楚这连续的三个Ack2是谁传回来的，根据TCP不同的实现，以上两种情况都是有可能的。为了解决不知道该重传哪些TCP报文，于是就有<code>SACK</code>方法。</p><h5 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h5><p><code>SACK</code>即Selective Acknowledgment选择性确认，该方式需要<strong>在TCP头部选项字段里加一个<code>SACK</code></strong>，它<strong>可将缓存的地图发送给发送方</strong>，这样发送方就能知道哪些数据收到了，哪些数据没收到，就可<strong>只重传丢失的数据</strong>。</p><p><img src="../../../../../images/网络/快速重传-sack.png" alt></p><p>发送方收到了三次同样的ACK确认报文，于是就会触发<strong>快速重发机制</strong>，通过<code>SACK</code>信息发现只有<code>200~299</code>这段数据丢失，则重发时只选择该TCP段进行重复。若要支持<code>SACK</code>，必须双方都要支持，在Linux下可通过 <code>net.ipv4.tcp_sack</code>参数打开该功能，Linux 2.4后默认打开。</p><h5 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h5><p><code>D-SACK</code>即Duplicate SACK，其主要<strong>使用了SACK来告诉发送方有哪些数据被重复接收了</strong>，<strong>接收方</strong>发给<strong>发送方</strong>的两个ACK确认应答都丢失了，发送方超时后，重传第一个数据包3000 ~ 3499，<strong>于是接收方发现数据是重复收到的，于是回了一个SACK = 3000~3500</strong>，告诉发送方3000~3500的数据早已被接收了，因为ACK都是4000，意味着4000之前的所有数据都已收到，故该SACK就代表<code>D-SACK</code>，发送方则知道数据没有丢，是接收方ACK确认报文丢失。</p><p><img src="../../../../../images/网络/D-SACK-ACK丢包.png" alt="D-SACK ACK丢包"></p><p>数据包1000~1499被网络延迟了，导致发送方没有收到Ack 1500的确认报文，而后面报文到达的三个相同的ACK 确认报文，就触发了快速重传机制，但在重传后被延迟的数据包1000~1499又到了接收方；故接收方回了一个 SACK=1000~1500，因为ACK已经到了3000，故该SACK是D-SACK，表示收到了重复的包。这样发送方就知道<strong>快速重传触发的原因</strong>是因为网络延迟。</p><p><img src="../../../../../images/网络/D-SACK-网络延迟.png" alt="D-SACK 网络延迟"></p><p><code>D-SACK</code>可<strong>让发送方知道是发出去的包丢了，还是接收方回应的ACK包丢了</strong>；可知道<strong>是不是发送方的数据包被网络延迟了</strong>；可知道网络中是不是把发送方的数据包给复制了；</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p><img src="../../../../../images/网络/UDP头部格式.png" alt="UDP头部格式"></p><p><strong><code>UDP</code></strong>不提供复杂的控制机制，<strong>利用IP提供面向无连接</strong>的通信服务，全称<strong><code>User Datagram Protocol</code>用户数据报协议</strong>，UDP为应用程序提供了⼀种<strong>无需建立连接就可发送封装的<code>IP</code>数据包</strong>的方法，若应用程序开发人员选择的是 UDP，则该应用程序<strong>相当于和<code>IP</code>直接打交道</strong>。</p><ul><li><strong>目标端口和源端口</strong>：主要是<strong>告诉<code>UDP</code>协议应该把报文发给哪个进程</strong></li><li><strong>包长度</strong>：该字段保存了<strong><code>UDP</code>首部长度和数据长度之和</strong></li><li><strong>校验和</strong>：为了提供<strong>可靠的<code>UDP</code>首部</strong>和<strong>数据</strong>而设计</li></ul><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p>TCP与UDP的区别主要体现在<strong>连接</strong>、<strong>服务对象</strong>、<strong>可靠性</strong>、<strong>拥塞</strong>和<strong>流量控制</strong>、<strong>首部开销</strong>等几个方面</p><p>TCP是<strong>面向连接</strong>的<strong>传输层协议</strong>，<strong>传输数据前先要建立连接</strong>；TCP是<strong>一对一</strong>的两点服务，即一条连接只有两个端点；TCP是<strong>可靠交付数据</strong>的，数据可<strong>无差错</strong>、<strong>不丢失</strong>、<strong>不重复</strong>、<strong>按需到达</strong>；TCP有<strong>拥塞控制</strong>和<strong>流量控制机制</strong>，保证数据传输的<strong>安全性</strong>；TCP<strong>首部长度较长</strong>，会有一定的开销，首部没有使用<strong>选项字段</strong>时是<strong><code>20</code></strong>个字节，若使用了选项字段会更长；</p><p>UDP是<strong>不需要建立连接</strong>即可传输数据，UDP支持<strong>一对一</strong>、<strong>一对多</strong>、<strong>多对多</strong>的交互通信；UDP是<strong>尽最大努力交付</strong>，<strong>不保证可靠交付数据</strong>；UDP没有<strong>拥塞控制</strong>和<strong>流量控制机制</strong>，即使网络非常拥堵也不会影响UDP发送速率；UDP首部只有8个字节，且是固定不变的开销较小；</p><h5 id="TCP和UDP应用场景"><a href="#TCP和UDP应用场景" class="headerlink" title="TCP和UDP应用场景"></a>TCP和UDP应用场景</h5><p>由于TCP是<strong>面向连接</strong>，能保证数据的<strong>可靠性交付</strong>，因此经常用于：<strong><code>FTP</code>文件传输</strong>、<strong><code>HTTP</code> / <code>HTTPS</code></strong></p><p>由于UDP面向<strong>无连接</strong>，可随时发送数据，UDP本身处理既简单又高效，因此经常用于：<strong>包总量较少的通信</strong>如<code>DNS</code> 、<code>SNMP</code>等、视频、音频等多媒体通信、广播通信</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP协议&quot;&gt;&lt;a href=&quot;#TCP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP协议&quot;&gt;&lt;/a&gt;TCP协议&lt;/h3&gt;&lt;p&gt;TCP是&lt;strong&gt;面向连接的、可靠的、基于字节流&lt;/strong&gt;的&lt;strong&gt;传输层&lt;/strong&gt;通
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="协议族" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="网络" scheme="https://yaoyinglong.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务解决方案</title>
    <link href="https://yaoyinglong.github.io/Blog/Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://yaoyinglong.github.io/Blog/Cloud/分布式事务解决方案/</id>
    <published>2022-02-08T16:00:00.000Z</published>
    <updated>2022-02-11T13:11:28.069Z</updated>
    
    <content type="html"><![CDATA[<p>大多数场景下应用都只需要操作单一数据库，该情况下的事务称之为<strong>本地事务</strong>(Local Transaction)。<strong>本地事务的ACID特性是数据库直接提供支持</strong>。在JDBC编程中通过<strong><code>java.sql.Connection</code></strong>对象来<strong>开启</strong>、<strong>关闭</strong>或<strong>提交</strong>事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = ... ; <span class="comment">//获取数据库连接</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行增删改查sql</span></span><br><span class="line">    conn.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    conn.rollback();<span class="comment">// 事务回滚</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    conn.close();<span class="comment">// 关闭链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝大部分公司都进行了<strong>数据库拆分</strong>和<strong>服务化</strong>，完成某一个业务功能可能需要横跨多个服务，操作多个数据库，<strong>需要操作的资源位于多个资源服务器上</strong>，<strong>分布式事务</strong>就是为了保证<strong>不同资源服务器</strong>的<strong>数据一致性</strong>。典型的分布式事务场景：<strong>垮库事务</strong>、<strong>分库分表</strong>、<strong>服务化</strong>。</p><h3 id="DTP模型"><a href="#DTP模型" class="headerlink" title="DTP模型"></a>DTP模型</h3><p>构成DTP模型的5个基本元素：</p><ul><li><strong><code>AP</code>应用程序Application Program</strong>：用于<strong>定义事务边界</strong>即定义事务的开始和结束，并在事务边界内对资源进行操作</li><li><strong><code>RM</code>资源管理器Resource Manager</strong>：如<strong>数据库</strong>、<strong>文件系统</strong>等，并提供访问资源的方式</li><li><strong><code>TM</code>事务管理器Transaction Manager</strong>：负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等</li><li><strong><code>CRM</code>通信资源管理器Communication Resource Manager</strong>：控制一个TM域内或者跨TM域的<strong>分布式应用之间的通信</strong></li><li><strong><code>CP</code>通信协议Communication Protocol</strong>：提供CRM提供的分布式应用节点之间的<strong>底层通信服务</strong></li></ul><h3 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h3><p>在DTP本地模型实例中，由<strong><code>AP</code>应用程序</strong>、<strong><code>RMs</code>资源管理器</strong>和<strong><code>TM</code>事务管理器</strong>组成，不需要其他元素，AP、RM和TM之间彼此都需要进行交互。XA规范主要作用是定义了<strong><code>RM-TM</code>的交互接口</strong>，还<strong>对两阶段提交协议进行了优化</strong>。</p><p><img src="../../../../images/Cloud/秒杀/分布式事务XA模型.png" alt></p><p><strong>两阶段协议</strong>是在<strong><code>OSI TP</code></strong>标准中提出的，在DTP参考模型中，指定了<strong>全局事务</strong>的提交要使用<strong>两阶段提交协议</strong>；而XA规范只是定义了<strong>两阶段提交协议中需要使用到的接口</strong>，也就是上述提到的<strong><code>RM-TM</code>交互的接口</strong>。</p><h4 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h4><p><strong>两阶段提交协议</strong>不是在XA规范中提出，但XA规范对其进行了优化，<strong>将提交过程划分为两个阶段</strong>。</p><p><strong>第一阶段</strong>：<strong>TM通知各个RM准备提交它们的事务分支</strong>；若RM判断自己进行的工作<strong>可以被提交</strong>，则<strong>对工作内容进行持久化</strong>，再<strong>给TM肯定答复</strong>；若<strong>发生了其他情况</strong>则给TM的都是<strong>否定答复</strong>。在发送了否定答复并回滚了工作后，RM就可以丢弃该事务分支信息。</p><p><strong>第二阶段</strong>：<strong>TM根据第一阶段各个RM prepare的结果，决定是提交还是回滚事务</strong>；若<strong>所有<code>RM</code>都<code>prepare</code>成功</strong>，则TM通知所有RM进行提交；若<strong>有<code>RM prepare</code>失败</strong>则TM通知所有RM<strong>回滚事务分支</strong>。</p><p><img src="../../../../images/Cloud/秒杀/两阶段提交协议一.png" alt></p><p>二阶段提交看起来确实能够提供原子性的操作，但二阶段提交还是有几个缺点：</p><p><strong>同步阻塞问题</strong>：两阶段提交方案下<strong>全局事务的ACID特性是依赖于RM的</strong>，一个<strong>全局事务</strong>内部包含了<strong>多个独立的事务分支</strong>，这一组事务分支要不都成功要不都失败，<strong>各个事务分支的ACID特性共同构成了全局事务的ACID特性</strong>。<strong>可重复读隔离级别不足以保证分布式事务一致性</strong>，若使用MySQL来支持XA分布式事务最好将事务隔离级别设置为<strong><code>SERIALIZABLE</code></strong>，而<strong><code>SERIALIZABLE</code></strong>是四个事务隔离级别中最高且执行效率最低一个级别。</p><p><strong>单点故障</strong>：由于协调者的重要性，一旦<strong>协调者TM发生故障</strong>，参与者RM会一直阻塞下去。尤其在第二阶段，协调者发生故障，所有参与者还都处于锁定事务资源状态中，而无法继续完成事务操作。若协调者挂掉，可重新选举一个协调者，但无法解决因为协调者宕机导致的参与者处于阻塞状态的问题</p><p><strong>数据不一致</strong>：在第二阶段中当<strong>协调者</strong>向<strong>参与者</strong>发送commit请求之后，发生了<strong>局部网络异常</strong>或在发送commit请求过程中<strong>协调者发生故障</strong>，会导致只有一部分参与者接受到了commit请求，而在这部分参与者接到commit请求之后就会执行commit操作，但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</p><hr><p><img src="../../../../images/Cloud/秒杀/常见分布式事务解决方案.png" alt="常见分布式事务解决方案"></p><h3 id="JTA-XA规范实现"><a href="#JTA-XA规范实现" class="headerlink" title="JTA/XA规范实现"></a>JTA/XA规范实现</h3><p>针对实现了JDBC规范中规定的实现<strong><code>XADataSource</code></strong>接口的数据库连接池，典型的<strong><code>XADataSource</code></strong>实现包括：</p><ul><li>MySQL官方提供的<strong><code>com.mysql.jdbc.jdbc2.optional.MysqlXADataSource</code></strong></li><li>阿里巴巴开源的druid连接池，对应的实现类为<strong><code>com.alibaba.druid.pool.xa.DruidXADataSource</code></strong></li><li>tomcat-jdbc连接池提供的<strong><code>org.apache.tomcat.jdbc.pool.XADataSource</code></strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MySQL JDBC实现了XA规范 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.39<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true表示打印XA语句,，用于调试</span></span><br><span class="line"><span class="keyword">boolean</span> logXaCommands = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 获得资源管理器操作接口实例 RM1</span></span><br><span class="line">Connection conn1 = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db_user"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">XAConnection xaConn1 = <span class="keyword">new</span> MysqlXAConnection((com.mysql.jdbc.Connection) conn1, logXaCommands);</span><br><span class="line">XAResource rm1 = xaConn1.getXAResource();</span><br><span class="line"><span class="comment">// 获得资源管理器操作接口实例 RM2</span></span><br><span class="line">Connection conn2 = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db_account"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">XAConnection xaConn2 = <span class="keyword">new</span> MysqlXAConnection((com.mysql.jdbc.Connection) conn2, logXaCommands);</span><br><span class="line">XAResource rm2 = xaConn2.getXAResource();</span><br><span class="line"><span class="comment">// AP请求TM执行一个分布式事务，TM生成全局事务id</span></span><br><span class="line"><span class="keyword">byte</span>[] gtrid = <span class="string">"g12345"</span>.getBytes();</span><br><span class="line"><span class="keyword">int</span> formatId = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ==============分别执行RM1和RM2上的事务分支====================</span></span><br><span class="line">    <span class="comment">// TM生成rm1上的事务分支id</span></span><br><span class="line">    <span class="keyword">byte</span>[] bqual1 = <span class="string">"b00001"</span>.getBytes();</span><br><span class="line">    Xid xid1 = <span class="keyword">new</span> MysqlXid(gtrid, bqual1, formatId);</span><br><span class="line">    <span class="comment">// 执行rm1上的事务分支</span></span><br><span class="line">    rm1.start(xid1, XAResource.TMNOFLAGS);<span class="comment">// One of TMNOFLAGS, TMJOIN, or TMRESUME.</span></span><br><span class="line">    PreparedStatement ps1 = conn1.prepareStatement(<span class="string">"INSERT into user(name) VALUES ('Eleven')"</span>);</span><br><span class="line">    ps1.execute();</span><br><span class="line">    rm1.end(xid1, XAResource.TMSUCCESS);</span><br><span class="line">    <span class="comment">// TM生成rm2上的事务分支id</span></span><br><span class="line">    <span class="keyword">byte</span>[] bqual2 = <span class="string">"b00002"</span>.getBytes();</span><br><span class="line">    Xid xid2 = <span class="keyword">new</span> MysqlXid(gtrid, bqual2, formatId);</span><br><span class="line">    <span class="comment">// 执行rm2上的事务分支</span></span><br><span class="line">    rm2.start(xid2, XAResource.TMNOFLAGS);</span><br><span class="line">    PreparedStatement ps2 = conn2.prepareStatement(<span class="string">"INSERT into account(user_id, money) VALUES (1, 10000000)"</span>);</span><br><span class="line">    ps2.execute();</span><br><span class="line">    rm2.end(xid2, XAResource.TMSUCCESS);</span><br><span class="line">    <span class="comment">// ===================两阶段提交================================</span></span><br><span class="line">    <span class="comment">// phase1：询问所有的RM 准备提交事务分支</span></span><br><span class="line">    <span class="keyword">int</span> rm1_prepare = rm1.prepare(xid1);</span><br><span class="line">    <span class="keyword">int</span> rm2_prepare = rm2.prepare(xid2);</span><br><span class="line">    <span class="comment">// phase2：提交所有事务分支</span></span><br><span class="line">    <span class="keyword">boolean</span> onePhase = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//TM判断有2个事务分支，所以不能优化为一阶段提交</span></span><br><span class="line">    <span class="keyword">if</span> (rm1_prepare == XAResource.XA_OK &amp;&amp; rm2_prepare == XAResource.XA_OK) &#123;</span><br><span class="line">        <span class="comment">// 所有事务分支都prepare成功，提交所有事务分支</span></span><br><span class="line">        rm1.commit(xid1, onePhase);</span><br><span class="line">        rm2.commit(xid2, onePhase);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果有事务分支没有成功，则回滚</span></span><br><span class="line">        rm1.rollback(xid1);</span><br><span class="line">        rm2.rollback(xid2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (XAException e) &#123; <span class="comment">// 如果出现异常，也要进行回滚</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开源框架<strong><code>Atomikos</code></strong>：<strong><code>TransactionEssentials</code></strong>开源的免费产品，<strong><code>ExtremeTransactions</code></strong>上商业版需要收费。</p><p><img src="../../../../images/Cloud/秒杀/TransactionEssentials.png" alt></p><p>TransactionEssentials实现了<strong><code>JTA/XA</code></strong>规范中的<strong>事务管理器</strong>应该实现的相关接口，如<strong><code>UserTransaction</code></strong>实现了<strong><code>com.atomikos.icatch.jta.UserTransactionImp</code></strong>，用户只需要直接操作该类，<strong><code>TransactionManager</code></strong>实现了<strong><code>com.atomikos.icatch.jta.UserTransactionManager</code></strong>，<strong><code>Transaction</code></strong>实现了com.atomikos.icatch.jta.TransactionImp。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JTA规范扩展包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.transaction<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jta<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- atomikos JTA/XA全局事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atomikos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transactions-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AtomikosDataSourceBean <span class="title">createAtomikosDataSourceBean</span><span class="params">(String dbName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接池基本属性</span></span><br><span class="line">    Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">    p.setProperty(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://localhost:3306/"</span> + dbName);</span><br><span class="line">    p.setProperty(<span class="string">"user"</span>, <span class="string">"root"</span>);</span><br><span class="line">    p.setProperty(<span class="string">"password"</span>, <span class="string">"root"</span>);</span><br><span class="line">    <span class="comment">// 使用AtomikosDataSourceBean封装com.mysql.jdbc.jdbc2.optional.MysqlXADataSource</span></span><br><span class="line">    AtomikosDataSourceBean ds = <span class="keyword">new</span> AtomikosDataSourceBean();</span><br><span class="line">    <span class="comment">// 设置resourceName 唯一</span></span><br><span class="line">    ds.setUniqueResourceName(dbName);</span><br><span class="line">    ds.setXaDataSourceClassName(<span class="string">"com.mysql.jdbc.jdbc2.optional.MysqlXADataSource"</span>);</span><br><span class="line">    ds.setXaProperties(p);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomikosDataSourceBean ds1 = createAtomikosDataSourceBean(<span class="string">"db_user"</span>);</span><br><span class="line">    AtomikosDataSourceBean ds2 = createAtomikosDataSourceBean(<span class="string">"db_account"</span>);</span><br><span class="line">    Connection conn1 = <span class="keyword">null</span>;</span><br><span class="line">    Connection conn2 = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps1 = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps2 = <span class="keyword">null</span>;</span><br><span class="line">    UserTransaction userTransaction = <span class="keyword">new</span> UserTransactionImp();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        userTransaction.begin();</span><br><span class="line">        <span class="comment">// 执行db1上的sql</span></span><br><span class="line">        conn1 = ds1.getConnection();</span><br><span class="line">        ps1 = conn1.prepareStatement(<span class="string">"INSERT into user(name) VALUES (?)"</span>, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">        ps1.setString(<span class="number">1</span>, <span class="string">"Eleven"</span>);</span><br><span class="line">        ps1.executeUpdate();</span><br><span class="line">        ResultSet generatedKeys = ps1.getGeneratedKeys();</span><br><span class="line">        <span class="keyword">int</span> userId = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (generatedKeys.next()) &#123;</span><br><span class="line">            <span class="comment">// 获得自动生成的userId</span></span><br><span class="line">            userId = generatedKeys.getInt(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模拟异常 ，直接进入catch代码块，2个都不会提交</span></span><br><span class="line">        <span class="comment">// int i=1/0;</span></span><br><span class="line">        <span class="comment">// 执行db2上的sql</span></span><br><span class="line">        conn2 = ds2.getConnection();</span><br><span class="line">        ps2 = conn2.prepareStatement(<span class="string">"INSERT into account(user_id,money) VALUES (?,?)"</span>);</span><br><span class="line">        ps2.setInt(<span class="number">1</span>, userId);</span><br><span class="line">        ps2.setDouble(<span class="number">2</span>, <span class="number">10000000</span>);</span><br><span class="line">        ps2.executeUpdate();</span><br><span class="line">        <span class="comment">// 两阶段提交</span></span><br><span class="line">        userTransaction.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            userTransaction.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SystemException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps1.close();</span><br><span class="line">            ps2.close();</span><br><span class="line">            conn1.close();</span><br><span class="line">            conn2.close();</span><br><span class="line">            ds1.close();</span><br><span class="line">            ds2.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Seata-AT模式"><a href="#Seata-AT模式" class="headerlink" title="Seata AT模式"></a>Seata AT模式</h3><p>Seata相比与其它分布式事务框架有以下几个<strong>优势</strong>:</p><ul><li><strong>应用层基于SQL解析实现了自动补偿</strong>，从而最大程度的<strong>降低业务侵入性</strong></li><li>将分布式事务中<strong>TC事务协调者独立部署</strong>，负责事务的注册、回滚</li><li>通过<strong>全局锁</strong>实现了<strong>写隔离</strong>与<strong>读隔离</strong></li></ul><p>Seata提供了<strong><code>AT</code></strong>、<strong><code>TCC</code></strong>、<strong><code>SAGA</code></strong>和<strong><code>XA</code></strong>事务模式，AT模式是Seata首推模式，Seata有<strong><code>TC</code>事务协调者</strong>、<strong><code>TM</code>事务管理器</strong>、<strong><code>RM</code>资源管理器</strong>三大角色，<strong><code>TC</code>为单独部署的<code>Server</code>服务端，<code>TM</code>和<code>RM</code>为嵌入到应用中的Client客户端</strong></p><ul><li><strong><code>TC</code>事务协调者</strong>：维护全局和分支事务的状态驱动全局事务提交或回滚</li><li><strong><code>TM</code>事务管理器</strong>：<strong>定义全局事务的范围</strong>开始全局事务、提交或回滚全局事务</li><li><strong><code>RM</code>资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务状态，并驱动分支事务提交或回滚</li></ul><p><img src="../../../../../images/Seata/分布式事务生命周期.png" alt="Seata分布式事务生命周期"></p><p>TM请求TC开启一个全局事务，TC会生成一个XID作为该全局事务的编号，<strong><code>XID</code>会在微服务的调用链路中传播</strong>，保证将多个微服务的子事务关联在一起；<strong>RM请求TC将本地事务注册为全局事务的分支事务</strong>，<strong>通过全局事务的XID进行关联</strong>；TM请求TC告诉XID对应的全局事务是进行提交还是回滚；TC驱动RM们将XID对应的自己的本地事务进行提交还是回滚。</p><p><img src="../../../../../images/Seata/Seata分布式事务整体执行流程.png" alt></p><p>AT模式的核心是<strong>对业务无侵入</strong>，是一种<strong>改进后的两阶段提交</strong>，前提是<strong>基于支持本地<code>ACID</code>事务的关系型数据库</strong>，<strong><code>Java</code>应用通过<code>JDBC</code>访问数据库</strong>。通过两阶段提交：</p><ul><li><strong>一阶段</strong>：<strong>业务数据</strong>和<strong>回滚日志记录</strong>在<strong>同一个本地事务中提交</strong>，释放本地锁和连接资源，本地事务提交前，需确保先拿到<strong>全局锁</strong>，否则不能提交本地事务，且拿全局锁的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务释放本地锁</li><li><strong>二阶段</strong>：<strong>提交异步化</strong>非常快速地完成，回滚通过一阶段的<strong>回滚日志进行反向补偿</strong></li></ul><p><img src="../../../../../images/Seata/Seata分布式事务第一阶段.png" alt="第一阶段"></p><p><strong>一阶段</strong>会<strong>解析<code>SQL</code>类型</strong>是更新删除还是新增、<strong>表名</strong>、<strong>条件</strong>等相关信息，根据解析得到的条件信息，生成查询语句定位数据生成<strong>前置镜像</strong>，然后执行业务SQL，根据前镜像的结果，通过<strong>主键</strong>定位数据得到<strong>后置镜像</strong>，把<strong>前置镜像</strong>和<strong>后置镜像</strong>数据以及<strong>业务<code>SQL</code></strong>相关的信息组成一条<strong>回滚日志记录</strong>，插入到<strong><code>UNDO_LOG</code></strong>表中。提交前向TC注册分支申请目标表中，对应主键值的记录的<strong>全局锁</strong>，业务数据的更新和前面步骤中生成的<strong><code>UNDO LOG</code></strong>一并提交，将本地事务提交的结果上报给TC。</p><p><img src="../../../../../images/Seata/Seata分布式事务第二阶段回滚.png" alt="第二阶段回滚"></p><p>二阶段回滚，收到TC分支回滚请求，开启一个本地事务，通过XID和Branch ID查找到相应的UNDO LOG记录，拿 UNDO LOG中的后镜与当前数据进行比较，若有<strong>不同</strong>说明数据<strong>被当前全局事务之外的动作做了修改</strong>。该情况需要<strong>根据配置策略来做处理</strong>，根据UNDO LOG中前镜像和业务SQL相关信息生成并执行回滚的语句，提交本地事务并把本地事务的执行结果即<strong>分支事务回滚结果上报给TC事务协调者</strong>。</p><p><img src="../../../../../images/Seata/Seata分布式事务第二阶段提交.png" alt="第二阶段提交"></p><p>二阶段提交，即<strong>分布式事务操作成功</strong>，<strong><code>TC</code>通知<code>RM</code>异步删除<code>undolog</code></strong>，收到TC分支提交请求，把请求放入一个异步任务队列中，马上返回提交成功结果给TC，<strong>异步任务阶段的分支提交请求</strong>将异步和批量地<strong>删除相应<code>UNDO LOG</code>记录</strong>。</p><p>Seata AT模式存在的问题：</p><ul><li><strong>性能损耗</strong>：一条Update的SQL需要与TC通讯获取全局事务xid、before image解析SQL查询一次数据库、after image查询一次数据库、insert undo log写一次数据库、before commit与TC通讯判断锁冲突，这些操作都需要<strong>同步远程通讯RPC</strong>，且undo log写入时blob字段插入性能也不高。每条写SQL都会增加这么多开销，粗略估计会增加5倍响应时间</li><li><strong>性价比</strong>：为了进行自动补偿，需要对所有交易生成前后镜像并持久化，在实际业务场景下<strong>分布式事务失败需要回滚的有多少比率</strong>，按照二八原则预估，为了20%的交易回滚，需要将80%的成功交易的响应时间增加5倍，这样的代价相比于让应用开发一个补偿交易是否是值得</li><li><strong>全局锁</strong>：相比XA，Seata虽然在<strong>一阶段成功后会释放数据库锁</strong>，但<strong>一阶段在commit前全局锁的判定也拉长了对数据锁的占有时间</strong>，这个开销比XA的prepare低多少需要根据实际业务场景进行测试。全局锁的引入实现了隔离性，但带来的问题就是阻塞，降低并发性，<strong>尤其是热点数据</strong>，这个问题会更加严重。</li><li><strong>回滚锁释放时间</strong>：Seata在回滚时，需要先删除各节点的undo log，然后才能释放TC内存中的锁，所以若第二阶段是回滚，释放锁的时间会更长</li><li><strong>死锁问题</strong>：Seata的引入全局锁<strong>会额外增加死锁风险</strong>，若出现死锁会不断进行重试，最后靠等待全局锁超时，这种方式并不优雅，也延长了对数据库锁的占有时间</li></ul><h3 id="柔性事务TCC"><a href="#柔性事务TCC" class="headerlink" title="柔性事务TCC"></a>柔性事务TCC</h3><p>TCC是比较常用的一种<strong>柔性事务方案</strong>。开源的TCC框架：<strong><code>Tcc-Transaction</code></strong>、<strong><code>Hmily</code></strong>、<strong><code>ByteTCC</code></strong>、<strong><code>EasyTransaction</code></strong>、<strong><code>Seata TCC</code></strong>。</p><p><img src="../../../../images/Cloud/秒杀/两阶段提交TCC vs XA.png" alt></p><p>TCC两阶段提交与XA两阶段提交的区别是：<strong>XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁，TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁</strong>。</p><p><strong>TCC事务的优点</strong>是<strong>有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能底下的问题</strong>。相对于AT模式，TCC模式<strong>对业务代码有一定的侵入性</strong>，但TCC模式无AT模式的全局行锁，TCC性能会比AT模式高很多。</p><p><strong>TCC事务的缺点</strong>是主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。原来只需要提供一个接口，现在需要改造成<strong><code>try</code></strong>、<strong><code>confirm</code></strong>、<strong><code>canel</code></strong>三个接口开发成本高。</p><h4 id="空回滚"><a href="#空回滚" class="headerlink" title="空回滚"></a>空回滚</h4><p>在没有调用TCC资源Try方法的情况下，调用了二阶段的Cancel方法，<strong>Cancel方法需要识别出这是一个空回滚</strong>，<strong>然后直接返回成功</strong>，空回滚出现的原因是<strong><code>Try</code>超时丢包</strong>，<strong>分布式事务回滚触发<code>Cancel</code>，出现未收到<code>Try</code>，收到<code>Cancel</code>的情况</strong>。</p><p><img src="../../../../images/Cloud/秒杀/TCC分布式事务-空回滚.png" alt></p><h4 id="悬挂"><a href="#悬挂" class="headerlink" title="悬挂"></a>悬挂</h4><p><strong>悬挂</strong>即<strong><code>Cancel</code>比<code>Try</code>先执行</strong>，要运行空回滚，但<strong>要拒绝空回滚之后的Try操作</strong>，悬挂出现的原因是<strong>Try超时拥堵</strong>，<strong>分布式事务回滚触发<code>Cancel</code>，之后拥堵的<code>Try</code>到达</strong>。</p><p><img src="../../../../images/Cloud/秒杀/TCC分布式事务-悬挂.png" alt></p><h4 id="幂等控制"><a href="#幂等控制" class="headerlink" title="幂等控制"></a>幂等控制</h4><p>Try，Confirm，Cancel都需要保证幂等性，因为<strong>网络抖动</strong>或<strong>拥堵</strong>可能会超时，<strong>事务管理器</strong>会对资源进行<strong>重试</strong>操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常可用<strong>事务<code>xid</code></strong>或<strong>业务主键</strong>判重来控制。</p><p><img src="../../../../images/Cloud/秒杀/TCC分布式事务-幂等.png" alt></p><h3 id="TCC设计注意事项"><a href="#TCC设计注意事项" class="headerlink" title="TCC设计注意事项"></a>TCC设计注意事项</h3><p>以扣钱场景为例，场景为A转账30元给B，A和B账户在不同的服务。在微服务架构下，很有可能出现<strong>网络超时</strong>、<strong>重发</strong>，<strong>机器宕机</strong>等一系列的异常，出现<strong>空回滚</strong>、<strong>幂等</strong>、<strong>悬挂</strong>的问题。</p><p><img src="../../../../images/Cloud/秒杀/扣钱基础场景.png" alt></p><p>对于以下示例，都是<strong>先执行账户A的try方法</strong>，从而执行账户B的try方法，若成功则<strong>执行账户A的<code>confirm</code>方法</strong>，<strong>然后执行账户B的<code>confirm</code>方法</strong>，若失败则<strong>执行账户A的<code>concel</code>方法</strong>，然后再<strong>执行账户B的<code>cancel</code>方法</strong>。</p><h4 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h4><p>方案C优于方案B优于方案A</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 账户A</span><br><span class="line">try： </span><br><span class="line">    检查余额是否够30元      </span><br><span class="line">    扣减30元</span><br><span class="line">confirm：</span><br><span class="line">    空</span><br><span class="line">cancel： </span><br><span class="line">    增加30元</span><br><span class="line"># 账户B</span><br><span class="line">try：</span><br><span class="line">    增加30元        </span><br><span class="line">confirm：</span><br><span class="line">    空        </span><br><span class="line">cancel： </span><br><span class="line">    减少30元</span><br></pre></td></tr></table></figure><h4 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 账户A</span><br><span class="line">try： </span><br><span class="line">    检查余额是否够30元</span><br><span class="line">    扣减30元</span><br><span class="line">confirm： </span><br><span class="line">    空        </span><br><span class="line">cancel： </span><br><span class="line">    增加30元</span><br><span class="line"># 账户B</span><br><span class="line">try： </span><br><span class="line">    空        </span><br><span class="line">confirm： </span><br><span class="line">    增加30元        </span><br><span class="line">cancel： </span><br><span class="line">    空</span><br></pre></td></tr></table></figure><h4 id="方案C"><a href="#方案C" class="headerlink" title="方案C"></a>方案C</h4><p>需要创建<strong><code>local_transaction_log</code></strong>日志表用于<strong>幂等性</strong>、<strong>空回滚</strong>、<strong><code>try</code>悬挂处理</strong>时校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 账户A</span><br><span class="line">try： </span><br><span class="line">    try幂等校验      </span><br><span class="line">    try悬挂处理      </span><br><span class="line">    检查余额是否够30元      </span><br><span class="line">    扣减30元        </span><br><span class="line">confirm： </span><br><span class="line">    空        </span><br><span class="line">cancel：</span><br><span class="line">    cancel幂等校验</span><br><span class="line">    cancel空回滚处理</span><br><span class="line">    增加可用余额30元</span><br><span class="line"># 账户B</span><br><span class="line">try：</span><br><span class="line">    空</span><br><span class="line">confirm： </span><br><span class="line">    confirm幂等校验      </span><br><span class="line">    正式增加30元</span><br><span class="line">cancel： </span><br><span class="line">    空</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountMapper accountMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Bank2FeignClient bank2FeignClient;</span><br><span class="line">    <span class="comment">// try方法执行逻辑：try幂等校验，try悬挂处理，检查余额是否足够扣减，扣减金额</span></span><br><span class="line">    <span class="comment">// 只要标记@Hmily就是try方法，在注解中指定confirm、cancel两个方法的名字</span></span><br><span class="line">    <span class="meta">@Transactional</span>(timeout = <span class="number">60</span>)</span><br><span class="line">    <span class="meta">@Hmily</span>(confirmMethod = <span class="string">"commit"</span>, cancelMethod = <span class="string">"rollback"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String fromAccountNo, String toAccountNo, Double amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取全局事务id</span></span><br><span class="line">        String transId = HmilyTransactionContextLocal.getInstance().get().getTransId();</span><br><span class="line">        log.info(<span class="string">"bank1 try begin 开始执行...xid:&#123;&#125;"</span>, transId);</span><br><span class="line">        <span class="comment">// 幂等判断 判断local_transaction_log表中是否有try日志记录，如果有则不再执行</span></span><br><span class="line">        <span class="keyword">if</span> (accountMapper.isExistTransactionLogByType(transId, TransactionEnum.TRY.getValue()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"bank1 try 已经执行，无需重复执行,xid:&#123;&#125;"</span>, transId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// try悬挂处理，如果cancel、confirm有一个已经执行了，try不再执行</span></span><br><span class="line">        <span class="keyword">if</span> (accountMapper.isExistTransactionLogByType(transId, TransactionEnum.CONFIRM.getValue()) &gt; <span class="number">0</span></span><br><span class="line">                || accountMapper.isExistTransactionLogByType(transId, TransactionEnum.CANCEL.getValue()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"bank1 try悬挂处理  cancel或confirm已经执行，不允许执行try,xid:&#123;&#125;"</span>, transId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扣减金额</span></span><br><span class="line">        <span class="keyword">if</span> (accountMapper.subtractAccountBalance(fromAccountNo, amount) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"bank1 try 扣减金额失败,xid:"</span> + transId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入try执行记录,用于幂等判断</span></span><br><span class="line">        accountMapper.addTransactionLog(transId, TransactionEnum.TRY.getValue());</span><br><span class="line">        <span class="comment">// 转账,远程调用bank2</span></span><br><span class="line">        <span class="keyword">if</span> (!bank2FeignClient.transferTo(toAccountNo, amount)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"bank1 远程调用bank2微服务失败,xid:"</span> + transId);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"bank2 request end 结束执行...xid:&#123;&#125;"</span>, transId);</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"人为制造异常,xid:"</span> + transId);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"bank1 try end 结束执行...xid:&#123;&#125;"</span>, transId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(String fromAccountNo, String toAccountNo, Double amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取全局事务id</span></span><br><span class="line">        String transId = HmilyTransactionContextLocal.getInstance().get().getTransId();</span><br><span class="line">        log.info(<span class="string">"bank1 confirm begin 开始执行...xid:&#123;&#125;,accountNo:&#123;&#125;,amount:&#123;&#125;"</span>, transId, fromAccountNo, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cancel方法执行逻辑： 1.cancel幂等校验 2.cancel空回滚处理 3.增加可用余额</span></span><br><span class="line">    <span class="meta">@Transactional</span>(timeout = <span class="number">60</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(String fromAccountNo, String toAccountNo, Double amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取全局事务id</span></span><br><span class="line">        String transId = HmilyTransactionContextLocal.getInstance().get().getTransId();</span><br><span class="line">        log.info(<span class="string">"bank1 cancel begin 开始执行...xid:&#123;&#125;"</span>, transId);</span><br><span class="line">        <span class="comment">// cancel幂等校验</span></span><br><span class="line">        <span class="keyword">if</span> (accountMapper.isExistTransactionLogByType(transId, TransactionEnum.CANCEL.getValue()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"bank1 cancel 已经执行，无需重复执行,xid:&#123;&#125;"</span>, transId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cancel空回滚处理，如果try没有执行，cancel不允许执行</span></span><br><span class="line">        <span class="keyword">if</span> (accountMapper.isExistTransactionLogByType(transId, TransactionEnum.TRY.getValue()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"bank1 空回滚处理，try没有执行，不允许cancel执行,xid:&#123;&#125;"</span>, transId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加可用余额</span></span><br><span class="line">        accountMapper.addAccountBalance(fromAccountNo, amount);</span><br><span class="line">        <span class="comment">//插入一条cancel的执行记录</span></span><br><span class="line">        accountMapper.addTransactionLog(transId, TransactionEnum.CANCEL.getValue());</span><br><span class="line">        log.info(<span class="string">"bank1 cancel end 结束执行...xid:&#123;&#125;"</span>, transId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的设计并不能进行并发控制，即隔离性的保证，对业务模型进行优化，<strong>在业务模型中增加冻结金额字段</strong>，用来表示<strong>账户有多少金额处以冻结状态</strong>。</p><p><img src="../../../../images/Cloud/秒杀/扣钱场景一.png" alt></p><p><img src="../../../../images/Cloud/秒杀/扣钱场景二.png" alt></p><p>对于<strong>用户下单场景</strong>，整个业务逻辑由仓储服务、订单服务、帐户服务三个微服务构成，分别完成对给定的商品扣除库存数量、根据采购需求创建订单、从用户帐户中扣除余额。</p><p><img src="../../../../images/Cloud/秒杀/用户下单场景.png" alt></p><hr><h3 id="柔性事务：可靠消息最终一致性方案实现"><a href="#柔性事务：可靠消息最终一致性方案实现" class="headerlink" title="柔性事务：可靠消息最终一致性方案实现"></a>柔性事务：可靠消息最终一致性方案实现</h3><h4 id="本地消息表方案"><a href="#本地消息表方案" class="headerlink" title="本地消息表方案"></a>本地消息表方案</h4><p>本地消息表这个方案最初是eBay提出的，此方案的核心是通过<strong>本地事务</strong>保证数据业务操作和消息的<strong>一致性</strong>，然后通过<strong>定时任务</strong>将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。</p><h4 id="Rocketmq事务消息实现"><a href="#Rocketmq事务消息实现" class="headerlink" title="Rocketmq事务消息实现"></a>Rocketmq事务消息实现</h4><hr><h3 id="柔性事务：最大努力通知"><a href="#柔性事务：最大努力通知" class="headerlink" title="柔性事务：最大努力通知"></a>柔性事务：最大努力通知</h3><p><strong>最大努力通知型</strong>是最简单的一种柔性事务，是分布式事务中对一致性<strong>要求最低</strong>的一种，适用于一些<strong>最终一致性时间敏感度低</strong>的业务，且<strong>被动方处理结果不影响主动方的处理结果</strong>，典型的使用场景：<strong>银行通知</strong>、<strong>商户通知</strong>等。最大努力通知型的实现方案，一般符合以下特点，且需要实现<strong>消息重复通知机制</strong>、<strong>息校对机制</strong>：</p><ul><li><strong>不可靠消息</strong>：业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失</li><li><strong>定期校对</strong>：业务活动的被动方，根据定时策略，向业务活动主动方查询，主动方提供查询接口，恢复丢失的业务消息</li></ul><p><img src="../../../../images/Cloud/秒杀/柔性事务-最大努力通知.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大多数场景下应用都只需要操作单一数据库，该情况下的事务称之为&lt;strong&gt;本地事务&lt;/strong&gt;(Local Transaction)。&lt;strong&gt;本地事务的ACID特性是数据库直接提供支持&lt;/strong&gt;。在JDBC编程中通过&lt;strong&gt;&lt;code&gt;jav
      
    
    </summary>
    
      <category term="Cloud" scheme="https://yaoyinglong.github.io/categories/Cloud/"/>
    
    
      <category term="分布式事务" scheme="https://yaoyinglong.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Canal基础</title>
    <link href="https://yaoyinglong.github.io/Blog/Cloud/Canal%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/Cloud/Canal基础/</id>
    <published>2022-02-07T16:00:00.000Z</published>
    <updated>2022-02-08T11:19:48.174Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://github.com/alibaba/canal/releases" rel="external nofollow noopener noreferrer" target="_blank">Canal</a>模拟MySQL Slave的交互协议伪装自己为MySQL Slave</strong>，向MySQL Master发送Dump协议MySQL Master收到Dump请求，开始推送Binary Log给Slave即Canal，Canal解析Binary Log对象，原始为byte流。</p><p><img src="../../../../images/Cloud/秒杀/Canal工作原理.png" alt></p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">mkdir canal</span><br><span class="line">tar -zxvf canal.deployer-1.1.5.tar.gz</span><br><span class="line">vim conf/example/instance.properties</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改mysql配置</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">log-bin=mysql-bin  # 添加这一行就ok </span><br><span class="line">binlog-format=ROW  # 选择row模式 </span><br><span class="line">server-id=1        # 配置mysql replaction需要定义，不能和canal的slaveId重复</span><br><span class="line">binlog-do-db=micromall</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 执行mysql 创建canal用户</span><br><span class="line">create user canal identified by 'canal';</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%';</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="meta">#</span> 查看是否授权成功</span><br><span class="line">select * from user where user='canal' </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动canal</span><br><span class="line">cd bin</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>修改<strong>instance.properties</strong>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#################################################</span><br><span class="line">## mysql serverId , v1.0.26+ will autoGen</span><br><span class="line"># canal.instance.mysql.slaveId=0</span><br><span class="line"># enable gtid use true/false</span><br><span class="line">canal.instance.gtidon=false</span><br><span class="line"># position info</span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line">canal.instance.master.journal.name=</span><br><span class="line">canal.instance.master.position=</span><br><span class="line">canal.instance.master.timestamp=</span><br><span class="line">canal.instance.master.gtid=</span><br><span class="line"></span><br><span class="line"># rds oss binlog</span><br><span class="line">canal.instance.rds.accesskey=</span><br><span class="line">canal.instance.rds.secretkey=</span><br><span class="line">canal.instance.rds.instanceId=</span><br><span class="line"></span><br><span class="line"># table meta tsdb info</span><br><span class="line">canal.instance.tsdb.enable=true</span><br><span class="line">#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb</span><br><span class="line">#canal.instance.tsdb.dbUsername=canal</span><br><span class="line">#canal.instance.tsdb.dbPassword=canal</span><br><span class="line"></span><br><span class="line">#canal.instance.standby.address =</span><br><span class="line">#canal.instance.standby.journal.name =</span><br><span class="line">#canal.instance.standby.position =</span><br><span class="line">#canal.instance.standby.timestamp =</span><br><span class="line">#canal.instance.standby.gtid=</span><br><span class="line"></span><br><span class="line"># 数据库username/password</span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=root</span><br><span class="line">canal.instance.connectionCharset = UTF-8</span><br><span class="line">canal.instance.defaultDatabaseName=eleven</span><br><span class="line"># enable druid Decrypt database password</span><br><span class="line">canal.instance.enableDruid=false</span><br><span class="line">#canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==</span><br><span class="line"></span><br><span class="line"># table regex</span><br><span class="line"># canal.instance.filter.regex=.*\\..*</span><br><span class="line"># 配置表</span><br><span class="line">canal.instance.filter.regex=micromall.pms_product,micromall.sms_flash_promotion_product_relation</span><br><span class="line"># table black regex</span><br><span class="line">canal.instance.filter.black.regex=mysql\\.slave_.*</span><br><span class="line"># table field filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span><br><span class="line">#canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch</span><br><span class="line"># table field black filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span><br><span class="line">#canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch</span><br><span class="line"></span><br><span class="line"># mq config</span><br><span class="line"># 消息队列Topic</span><br><span class="line">canal.mq.topic=productDetailChange</span><br><span class="line"># dynamic topic route by schema or table regex</span><br><span class="line">#canal.mq.dynamicTopic=mytest1.user,mytest2\\..*,.*\\..*</span><br><span class="line">canal.mq.partition=0</span><br><span class="line"># hash partition config</span><br><span class="line">#canal.mq.partitionsNum=3</span><br><span class="line">#canal.mq.partitionHash=test.table:id^name,.*\\..*</span><br><span class="line">#canal.mq.dynamicTopicPartitionNum=test.*:4,mycanal:6</span><br></pre></td></tr></table></figure><p>修改<strong>canal.properties</strong>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#################################################</span><br><span class="line">######### common argument#############</span><br><span class="line">#################################################</span><br><span class="line"># tcp bind ip</span><br><span class="line">canal.ip =</span><br><span class="line"># register ip to zookeeper</span><br><span class="line">canal.register.ip =</span><br><span class="line">canal.port = 11111</span><br><span class="line">canal.metrics.pull.port = 11112</span><br><span class="line"># canal instance user/passwd</span><br><span class="line"># canal.user = canal</span><br><span class="line"># canal.passwd = E3619321C1A937C46A0D8BD1DAC39F93B27D4458</span><br><span class="line"></span><br><span class="line"># canal admin config</span><br><span class="line">#canal.admin.manager = 127.0.0.1:8089</span><br><span class="line">canal.admin.port = 11110</span><br><span class="line">canal.admin.user = admin</span><br><span class="line">canal.admin.passwd = 4ACFE3202A5FF5CF467898FC58AAB1D615029441</span><br><span class="line"># admin auto register</span><br><span class="line">#canal.admin.register.auto = true</span><br><span class="line">#canal.admin.register.cluster =</span><br><span class="line">#canal.admin.register.name =</span><br><span class="line"></span><br><span class="line">canal.zkServers =</span><br><span class="line"># flush data to zk</span><br><span class="line">canal.zookeeper.flush.period = 1000</span><br><span class="line">canal.withoutNetty = false</span><br><span class="line"># tcp, kafka, rocketMQ, rabbitMQ</span><br><span class="line">canal.serverMode = tcp</span><br><span class="line"># flush meta cursor/parse position to file</span><br><span class="line">canal.file.data.dir = $&#123;canal.conf.dir&#125;</span><br><span class="line">canal.file.flush.period = 1000</span><br><span class="line">## memory store RingBuffer size, should be Math.pow(2,n)</span><br><span class="line">canal.instance.memory.buffer.size = 16384</span><br><span class="line">## memory store RingBuffer used memory unit size , default 1kb</span><br><span class="line">canal.instance.memory.buffer.memunit = 1024 </span><br><span class="line">## meory store gets mode used MEMSIZE or ITEMSIZE</span><br><span class="line">canal.instance.memory.batch.mode = MEMSIZE</span><br><span class="line">canal.instance.memory.rawEntry = true</span><br><span class="line"></span><br><span class="line">## detecing config</span><br><span class="line">canal.instance.detecting.enable = false</span><br><span class="line">#canal.instance.detecting.sql = insert into retl.xdual values(1,now()) on duplicate key update x=now()</span><br><span class="line">canal.instance.detecting.sql = select 1</span><br><span class="line">canal.instance.detecting.interval.time = 3</span><br><span class="line">canal.instance.detecting.retry.threshold = 3</span><br><span class="line">canal.instance.detecting.heartbeatHaEnable = false</span><br><span class="line"></span><br><span class="line"># support maximum transaction size, more than the size of the transaction will be cut into multiple transactions delivery</span><br><span class="line">canal.instance.transaction.size =  1024</span><br><span class="line"># mysql fallback connected to new master should fallback times</span><br><span class="line">canal.instance.fallbackIntervalInSeconds = 60</span><br><span class="line"></span><br><span class="line"># network config</span><br><span class="line">canal.instance.network.receiveBufferSize = 16384</span><br><span class="line">canal.instance.network.sendBufferSize = 16384</span><br><span class="line">canal.instance.network.soTimeout = 30</span><br><span class="line"></span><br><span class="line"># binlog filter config</span><br><span class="line">canal.instance.filter.druid.ddl = true</span><br><span class="line">canal.instance.filter.query.dcl = false</span><br><span class="line">canal.instance.filter.query.dml = false</span><br><span class="line">canal.instance.filter.query.ddl = false</span><br><span class="line">canal.instance.filter.table.error = false</span><br><span class="line">canal.instance.filter.rows = false</span><br><span class="line">canal.instance.filter.transaction.entry = false</span><br><span class="line">canal.instance.filter.dml.insert = false</span><br><span class="line">canal.instance.filter.dml.update = false</span><br><span class="line">canal.instance.filter.dml.delete = false</span><br><span class="line"></span><br><span class="line"># binlog format/image check</span><br><span class="line">canal.instance.binlog.format = ROW,STATEMENT,MIXED </span><br><span class="line">canal.instance.binlog.image = FULL,MINIMAL,NOBLOB</span><br><span class="line"></span><br><span class="line"># binlog ddl isolation</span><br><span class="line">canal.instance.get.ddl.isolation = false</span><br><span class="line"></span><br><span class="line"># parallel parser config</span><br><span class="line">canal.instance.parser.parallel = true</span><br><span class="line">## concurrent thread number, default 60% available processors, suggest not to exceed Runtime.getRuntime().availableProcessors()</span><br><span class="line">#canal.instance.parser.parallelThreadSize = 16</span><br><span class="line">## disruptor ringbuffer size, must be power of 2</span><br><span class="line">canal.instance.parser.parallelBufferSize = 256</span><br><span class="line"></span><br><span class="line"># table meta tsdb info</span><br><span class="line">canal.instance.tsdb.enable = true</span><br><span class="line">canal.instance.tsdb.dir = $&#123;canal.file.data.dir:../conf&#125;/$&#123;canal.instance.destination:&#125;</span><br><span class="line">canal.instance.tsdb.url = jdbc:h2:$&#123;canal.instance.tsdb.dir&#125;/h2;CACHE_SIZE=1000;MODE=MYSQL;</span><br><span class="line">canal.instance.tsdb.dbUsername = canal</span><br><span class="line">canal.instance.tsdb.dbPassword = canal</span><br><span class="line"># dump snapshot interval, default 24 hour</span><br><span class="line">canal.instance.tsdb.snapshot.interval = 24</span><br><span class="line"># purge snapshot expire , default 360 hour(15 days)</span><br><span class="line">canal.instance.tsdb.snapshot.expire = 360</span><br><span class="line"></span><br><span class="line">#################################################</span><br><span class="line">######### destinations#############</span><br><span class="line">#################################################</span><br><span class="line">canal.destinations = example</span><br><span class="line"># conf root dir</span><br><span class="line">canal.conf.dir = ../conf</span><br><span class="line"># auto scan instance dir add/remove and start/stop instance</span><br><span class="line">canal.auto.scan = true</span><br><span class="line">canal.auto.scan.interval = 5</span><br><span class="line"># set this value to &apos;true&apos; means that when binlog pos not found, skip to latest.</span><br><span class="line"># WARN: pls keep &apos;false&apos; in production env, or if you know what you want.</span><br><span class="line">canal.auto.reset.latest.pos.mode = false</span><br><span class="line"></span><br><span class="line">canal.instance.tsdb.spring.xml = classpath:spring/tsdb/h2-tsdb.xml</span><br><span class="line">#canal.instance.tsdb.spring.xml = classpath:spring/tsdb/mysql-tsdb.xml</span><br><span class="line"></span><br><span class="line">canal.instance.global.mode = spring</span><br><span class="line">canal.instance.global.lazy = false</span><br><span class="line">canal.instance.global.manager.address = $&#123;canal.admin.manager&#125;</span><br><span class="line">#canal.instance.global.spring.xml = classpath:spring/memory-instance.xml</span><br><span class="line">canal.instance.global.spring.xml = classpath:spring/file-instance.xml</span><br><span class="line">#canal.instance.global.spring.xml = classpath:spring/default-instance.xml</span><br><span class="line"></span><br><span class="line">##################################################</span><br><span class="line">#########       MQ Properties      #############</span><br><span class="line">##################################################</span><br><span class="line"># aliyun ak/sk , support rds/mq</span><br><span class="line">canal.aliyun.accessKey =</span><br><span class="line">canal.aliyun.secretKey =</span><br><span class="line">canal.aliyun.uid=</span><br><span class="line"></span><br><span class="line">canal.mq.flatMessage = true</span><br><span class="line">canal.mq.canalBatchSize = 50</span><br><span class="line">canal.mq.canalGetTimeout = 100</span><br><span class="line"># Set this value to &quot;cloud&quot;, if you want open message trace feature in aliyun.</span><br><span class="line">canal.mq.accessChannel = local</span><br><span class="line"></span><br><span class="line">canal.mq.database.hash = true</span><br><span class="line">canal.mq.send.thread.size = 30</span><br><span class="line">canal.mq.build.thread.size = 8</span><br><span class="line"></span><br><span class="line">##################################################</span><br><span class="line">#########      Kafka      #############</span><br><span class="line">##################################################</span><br><span class="line">kafka.bootstrap.servers = 127.0.0.1:9092</span><br><span class="line">kafka.acks = all</span><br><span class="line">kafka.compression.type = none</span><br><span class="line">kafka.batch.size = 16384</span><br><span class="line">kafka.linger.ms = 1</span><br><span class="line">kafka.max.request.size = 1048576</span><br><span class="line">kafka.buffer.memory = 33554432</span><br><span class="line">kafka.max.in.flight.requests.per.connection = 1</span><br><span class="line">kafka.retries = 0</span><br><span class="line"></span><br><span class="line">kafka.kerberos.enable = false</span><br><span class="line">kafka.kerberos.krb5.file = &quot;../conf/kerberos/krb5.conf&quot;</span><br><span class="line">kafka.kerberos.jaas.file = &quot;../conf/kerberos/jaas.conf&quot;</span><br><span class="line"></span><br><span class="line">##################################################</span><br><span class="line">#########     RocketMQ     #############</span><br><span class="line">##################################################</span><br><span class="line">rocketmq.producer.group = test</span><br><span class="line">rocketmq.enable.message.trace = false</span><br><span class="line">rocketmq.customized.trace.topic =</span><br><span class="line">rocketmq.namespace =</span><br><span class="line">rocketmq.namesrv.addr = 127.0.0.1:9876</span><br><span class="line">rocketmq.retry.times.when.send.failed = 0</span><br><span class="line">rocketmq.vip.channel.enabled = false</span><br><span class="line">rocketmq.tag = </span><br><span class="line"></span><br><span class="line">##################################################</span><br><span class="line">#########     RabbitMQ     #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host =</span><br><span class="line">rabbitmq.virtual.host =</span><br><span class="line">rabbitmq.exchange =</span><br><span class="line">rabbitmq.username =</span><br><span class="line">rabbitmq.password =</span><br><span class="line">rabbitmq.deliveryMode =</span><br></pre></td></tr></table></figure><p><img src="../../../../images/Cloud/秒杀/Canal核心参数说明.png" alt></p><h3 id="Canal内部原理"><a href="#Canal内部原理" class="headerlink" title="Canal内部原理"></a>Canal内部原理</h3><p>Canal源码入口<strong><code>AbstractEventParser</code></strong>的<strong><code>start</code></strong>方法</p><p><img src="../../../../images/Cloud/秒杀/Canal内部原理.png" alt></p><ul><li>server代表一个canal运行实例，对应于一个jvm</li><li>instance对应于一个数据队列 （1个server对应1..n个instance)</li><li>eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)</li><li>eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作)</li><li>eventStore (数据存储)</li><li>metaManager (增量订阅&amp;消费信息管理器)</li></ul><h3 id="Canal集群高可用"><a href="#Canal集群高可用" class="headerlink" title="Canal集群高可用"></a>Canal集群高可用</h3><p>Canal的HA分为Canal Server和Canal Client两部分实现，整个HA机制的控制主要是依赖了Zookeeper的几个特性，watcher和EPHEMERAL节点和session生命周期绑定。</p><ul><li><strong><code>Canal Server</code></strong>：为了<strong>减少对<code>MySQL Dump</code>的请求</strong>，不同Server上的instance要求<strong>同一时间只能有一个处于<code>Running</code></strong>，其他的处于<strong><code>Standby</code></strong>状态</li><li><strong><code>Canal Client</code></strong>：为了保证<strong>有序性</strong>，一份instance同一时间只能由一个Canal Client进行get/ack/rollback操作，否则客户端接收无法保证有序</li></ul><p><img src="../../../../images/Cloud/秒杀/Canal高可用.png" alt></p><p>Canal Server要启动某个Canal instance时都先向Zookeeper进行一次尝试启动判断，创建EPHEMERAL临时节点，谁创建成功就允许谁启动</p><p>创建Zookeeper节点成功后，对应的Canal Server就启动对应的Canal instance，没有创建成功的Canal instance就会处于Standby状态</p><p>一旦Zookeeper发现Canal Server A创建的节点消失后，立即通知其他的Canal Server再次进行步骤1的操作，重新选出一个Canal Server启动instance.</p><p>Canal Client每次进行connect时，会首先向Zookeeper询问当前是谁启动了Canal instance，然后和其建立链接，一旦链接不可用，会重新尝试connect.</p><p>Canal Client的方式和Canal Server方式类似，也是利用Zookeeper的抢占EPHEMERAL节点的方式进行控制。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = <span class="string">"$&#123;rocketmq.canal.topic&#125;"</span>, consumerGroup = <span class="string">"$&#123;rocketmq.canal.group&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshCacheListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">FlatMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisOpsUtil redisOpsUtil;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PRODUCT = <span class="string">"pms_product"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SKU = <span class="string">"pms_sku_stock"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(FlatMessage flatMessage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//修改后的新记录</span></span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; records = flatMessage.getData();</span><br><span class="line">        <span class="comment">//修改前的数据</span></span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; old = flatMessage.getOld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCanalClientExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">11111</span>), <span class="string">"example"</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> emptyCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            connector.subscribe(<span class="string">".*\\..*"</span>);</span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">int</span> totalEmptyCount = <span class="number">120</span>;</span><br><span class="line">            <span class="keyword">while</span> (emptyCount &lt; totalEmptyCount) &#123;</span><br><span class="line">                Message message = connector.getWithoutAck(batchSize); <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                <span class="keyword">long</span> batchId = message.getId();</span><br><span class="line">                <span class="keyword">int</span> size = message.getEntries().size();</span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    emptyCount++;</span><br><span class="line">                    System.out.println(<span class="string">"empty count : "</span> + emptyCount);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    emptyCount = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// System.out.printf("message[batchId=%s,size=%s] \n", batchId, size);</span></span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                connector.ack(batchId); <span class="comment">// 提交确认</span></span><br><span class="line">                <span class="comment">// connector.rollback(batchId); // 处理失败, 回滚数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"empty too many times, exit"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEntry</span><span class="params">(List&lt;Entry&gt; entrys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RowChange rowChage = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChage = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ERROR ## parser of eromanga-event has an error , data:"</span> + entry.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            EventType eventType = rowChage.getEventType();</span><br><span class="line">            System.out.println(String.format(<span class="string">"================&amp;gt; binlog[%s:%s] , name[%s,%s] , eventType : %s"</span>,</span><br><span class="line">                                             entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class="line">                                             entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class="line">                                             eventType));</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"-------&amp;gt; before"</span>);</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    System.out.println(<span class="string">"-------&amp;gt; after"</span>);</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColumn</span><span class="params">(List&lt;Column&gt; columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            System.out.println(column.getName() + <span class="string">" : "</span> + column.getValue() + <span class="string">"    update="</span> + column.getUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/alibaba/canal/releases&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Canal&lt;/a&gt;模拟MySQL 
      
    
    </summary>
    
      <category term="Cloud" scheme="https://yaoyinglong.github.io/categories/Cloud/"/>
    
    
      <category term="Canal" scheme="https://yaoyinglong.github.io/tags/Canal/"/>
    
  </entry>
  
  <entry>
    <title>秒杀问题及解决方案</title>
    <link href="https://yaoyinglong.github.io/Blog/Cloud/%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://yaoyinglong.github.io/Blog/Cloud/秒杀问题及解决方案/</id>
    <published>2022-02-07T16:00:00.000Z</published>
    <updated>2022-02-11T13:11:28.101Z</updated>
    
    <content type="html"><![CDATA[<h4 id="秒杀业务特性"><a href="#秒杀业务特性" class="headerlink" title="秒杀业务特性"></a>秒杀业务特性</h4><p><strong>秒杀具有瞬时高并发的特点</strong>，秒杀请求在时间上高度集中于某一特定的时间点（秒杀开始那一秒），就会导致一个特别高的流量峰值，它对资源的消耗是瞬时的。</p><p>但对秒杀场景来说，最终能够抢到商品的人数是固定的，也就是说100人和10000人发起请求的结果都是一样的，<strong>并发度越高，无效请求也越多</strong>。</p><p>但是<strong>从业务上来说，秒杀活动是希望更多的人来参与</strong>，开始之前希望有更多的人来刷页面，但是真正开始下单时，秒杀请求并不是越多越好。</p><h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p><strong>服务器处理资源是恒定的</strong>，用或者不用它的处理能力都是一样的，出现峰值很容易导致忙到处理不过来，闲的时候却又没有什么要处理。</p><p>流量削峰，一是可以<strong>让服务端处理变得更加平稳</strong>，二是可以<strong>节省服务器的资源成本</strong>。针对秒杀这一场景，削峰从本质上来说就是<strong>更多地延缓用户请求的发出</strong>，以便减少和过滤掉一些无效请求，它遵从<strong>请求数要尽量少</strong>的原则。流量削峰的比较常见的思路：<strong>排队</strong>、<strong>答题</strong>、<strong>分层过滤</strong>。</p><h4 id="秒杀业务设计"><a href="#秒杀业务设计" class="headerlink" title="秒杀业务设计"></a>秒杀业务设计</h4><p><img src="../../../../images/Cloud/秒杀/秒杀业务设计一.png" alt></p><p><strong>营销工具：</strong>系统整理的促销工具，可以对某些特定的工具详细解释</p><p><strong>营销活动：</strong>从营销工具中提出创建一个活动</p><p><strong>营销活动订单：</strong>针对营销活动产生的订单</p><p><img src="../../../../images/Cloud/秒杀/秒杀业务设计二.png" alt></p><p><strong>商品级优惠</strong>：限时促销、限时抢购、秒杀、商品包邮</p><p><strong>订单级优惠</strong>：满就赠、满立减、送优惠券、折扣、Vip折扣、订单包邮</p><p><strong>全站级促销优惠</strong>：优惠券、优化券补发、银行促销、支付红包、团购预售、微信砍价</p><h4 id="秒杀技术特性"><a href="#秒杀技术特性" class="headerlink" title="秒杀技术特性"></a>秒杀技术特性</h4><p>单一职责、流量错峰、限流、熔断、降级、队列削峰、预热快速扣减、动静分离</p><hr><p>一般下单流程分为<strong>下单确认</strong>和<strong>下单提交</strong>，核心点为<strong>价格计算</strong>和<strong>库存处理</strong>，在下单确认时首先做一些检查、然后获取会员、商品等信息计算金额生成商品信息。</p><ul><li>信息检查：检查<strong>本地缓存售罄状态</strong>、校验token是否有权限购买、判断redis库存是否充足、检查是否正在排队中</li><li>调用会员服务获取会员信息</li><li>调用产品服务获取产品信息</li><li>验证秒杀时间是否超时</li><li>获取用户收获列表</li><li>构建商品信息</li><li>根据各种优惠计算订单金额</li></ul><p><strong>下单提交的核心流程</strong>为：</p><ul><li>信息检查：检查<strong>本地缓存售罄状态</strong>、校验token是否有权限购买、判断redis库存是否充足、检查是否正在排队中</li><li>调用会员服务获取会员信息</li><li>调用产品服务获取产品信息</li><li>验证秒杀时间是否超时</li><li>预减库存（异步流程）</li><li>生成下单商品信息</li><li>库存处理</li></ul><hr><h3 id="库存问题"><a href="#库存问题" class="headerlink" title="库存问题"></a>库存问题</h3><p>高并发下会出现<strong>超卖问题</strong>、<strong>何时扣减库存</strong></p><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><p>可通过<strong>数据库锁</strong>、<strong>redis特性</strong>、<strong>异步下单</strong>等解决方案来解决</p><h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><p><strong>悲观锁</strong>，通过<strong><code>MySQL</code>提供的<code>select...for update</code></strong>实现的悲观锁方式，但<strong><code>select...for update</code>语句执行中所有扫描过的行都会被锁上</strong>，因此在MySQL中用悲观锁<strong>务必须确定走索引</strong>，而不是全表扫描，否则将会将整个数据表锁住。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> flash_promotion_count <span class="keyword">from</span> sms_flash_promotion_product_relation <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">43</span> <span class="keyword">for</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">update</span> sms_flash_promotion_product_relation <span class="keyword">set</span> flash_promotion_count = flash_promotion_count - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">43</span>;</span><br><span class="line"><span class="comment">--ROLLBACK;</span></span><br><span class="line"><span class="keyword">commit</span>；</span><br></pre></td></tr></table></figure><p>悲观锁大多数情况下依靠<strong>数据库的锁机制</strong>实现，以保证操作最大程度的独占性，若<strong>加锁时间过长</strong>，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对<strong>数据库性能开销影响很大</strong>，特别是对<strong>长事务</strong>而言，这样的开销往往无法承受，这时就需要乐观锁。</p><p><strong>乐观锁</strong>，在<strong>数据进行提交更新时</strong>，才会正式对数据的冲突与否进行检测，若发现冲突则返回错误信息，让用户决定如何去做。<strong>版本号的实现</strong>有<strong>数据版本机制</strong>和<strong>时间催机制</strong>两种。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> flash_promotion_count <span class="keyword">from</span> sms_flash_promotion_product_relation <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">43</span> ;</span><br><span class="line"><span class="keyword">update</span> sms_flash_promotion_product_relation <span class="keyword">set</span> flash_promotion_count = flash_promotion_count, <span class="keyword">version</span> = <span class="keyword">version</span> + <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">43</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="comment">#version#;</span></span><br><span class="line"><span class="comment">-- ROLLBACK;</span></span><br><span class="line"><span class="keyword">Commit</span>；</span><br></pre></td></tr></table></figure><p>除了查询库存还需要<strong>更新库存</strong>，还有订单、订单日志、订单详情等需要插入数据库。库存更新没问题，但插入订单时<strong>失败</strong>了<strong>是否回滚</strong>，若<strong>不在一个事务就会出错</strong>。若在一个事务又涉及到<strong>事务过长</strong>甚至可能是<strong>跨库</strong>然后无法用本地事务来解决。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 扣减库存，防止库存超卖，若可以买多个，上面的SQL就有问题</span></span><br><span class="line"><span class="keyword">UPDATE</span> sms_flash_promotion_product_relation</span><br><span class="line"><span class="keyword">SET</span> flash_promotion_count = <span class="keyword">CASE</span></span><br><span class="line">  <span class="keyword">WHEN</span> flash_promotion_count &gt;= <span class="comment">#&#123;stock&#125; THEN</span></span><br><span class="line">    flash_promotion_count - <span class="comment">#&#123;stock&#125;</span></span><br><span class="line">  <span class="keyword">ELSE</span></span><br><span class="line">    flash_promotion_count</span><br><span class="line">  <span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">id</span> = <span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure><p><strong>数据库锁的问题</strong>：若数据库只有10个商品，1000个人来抢，意味着990个请求没有意义，但这种方案1000个请求都会到数据库尝试扣减库存，大量请求会导致数据库超载。</p><h4 id="Redis版本"><a href="#Redis版本" class="headerlink" title="Redis版本"></a>Redis版本</h4><p>使用数据库锁方案数<strong>据库性能相对来说是有很大瓶颈</strong>，故可把库存放到redis中，秒杀下单时先从redis中获取库存数量，然后根据库存数量判断是否可进行下一步，若有库存就直接下单没有库存就不能下单。这样<strong>可拦截大部分流量进入到数据库中</strong>。需要将商品库存预先加载到Redis中。</p><p><img src="../../../../images/Cloud/秒杀/redis扣减库存一.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从redis缓存当中取出当前要购买的商品库存</span></span><br><span class="line">Integer stock = redisOpsUtil.get(RedisKeyPrefixConst.MIAOSHA_STOCK_CACHE_PREFIX + productId, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (stock == <span class="keyword">null</span> || stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> CommonResult.failed(<span class="string">"商品已经售罄，请购买其它商品!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Redis来说还是有<strong>网络IO</strong>，当商品售罄时在<strong>本地缓存</strong>中设置该商品的售罄标志为true，从而减少Redis的网络IO。</p><p><img src="../../../../images/Cloud/秒杀/redis扣减库存二.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Boolean localcache = cache.getCache(RedisKeyPrefixConst.MIAOSHA_STOCK_CACHE_PREFIX + productId);</span><br><span class="line"><span class="keyword">if</span> (localcache != <span class="keyword">null</span> &amp;&amp; localcache) &#123;</span><br><span class="line">    <span class="keyword">return</span> CommonResult.failed(<span class="string">"商品已经售罄,请购买其它商品!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从redis缓存当中取出当前要购买的商品库存</span></span><br><span class="line">Integer stock = redisOpsUtil.get(RedisKeyPrefixConst.MIAOSHA_STOCK_CACHE_PREFIX + productId, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (stock == <span class="keyword">null</span> || stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置标记，如果售罄了在本地cache中设置为true</span></span><br><span class="line">    cache.setLocalCache(RedisKeyPrefixConst.MIAOSHA_STOCK_CACHE_PREFIX + productId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> CommonResult.failed(<span class="string">"商品已经售罄,请购买其它商品!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可通过增加本地缓存减少Redis网络IO，但会存在<strong>产品售罄标志同步问题</strong>，可<strong>通过<code>Zookeeper</code>的watcher机制来实现同步</strong>，给每个JVM都监听Zookeeper的某个节点，一旦数据有改变之后通知到其他节点上。还可以利用<strong>Redis的<code>Channel</code>机制</strong>实现的<strong>发布订阅模式</strong>来实现<strong>产品售罄标志同步</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisOpsUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String channel,Object message)</span></span>&#123;</span><br><span class="line">        redisTemplate.convertAndSend(channel,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPublishCleanMsg</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">    Integer stock = redisOpsUtil.get(RedisKeyPrefixConst.MIAOSHA_STOCK_CACHE_PREFIX + productId, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> (stock == <span class="keyword">null</span> || stock &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通知服务群,清除本地售罄标记缓存</span></span><br><span class="line"><span class="keyword">if</span> (shouldPublishCleanMsg(productId)) &#123;</span><br><span class="line">    redisOpsUtil.publish(<span class="string">"cleanNoStockCache"</span>, productId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisChannelListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LocalCache localCache;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, @Nullable <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"sub message :) channel[cleanNoStockCache] !"</span>);</span><br><span class="line">        String productId = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">        localCache.remove(RedisKeyPrefixConst.MIAOSHA_STOCK_CACHE_PREFIX + productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Zookeeper</code></strong>和<strong><code>Redis</code></strong>各有各的优缺点，Zookeeper是CP模式的可保证高可用，但<strong>吞吐量会比较低</strong>，<strong>Redis这种发布订阅模式没有<code>Ack</code></strong>，发出去后不管是否收到，因为<strong>减少了通讯吞吐量相对来说会比较高</strong>。</p><h4 id="异步下单"><a href="#异步下单" class="headerlink" title="异步下单"></a>异步下单</h4><p>前面的方案，下单时会插入很多张表，</p><ul><li>异步下单可以分流、让服务器处理压力变小、数据库压力减少</li><li>解耦，业务更清晰</li><li>天然排队处理能力</li><li>消息中间件有很多特性可以利用，如订单取消</li></ul><h4 id="订单超时取消"><a href="#订单超时取消" class="headerlink" title="订单超时取消"></a>订单超时取消</h4><ul><li><p><strong>定时任务</strong>：<strong>时间不准确</strong>，定时扫数据库的话消耗性能也很大，效率也会很低，对<strong>数据库压力太大</strong>，集群还需要保证处理的<strong>幂等性</strong>和<strong>分布式</strong>问题</p></li><li><p><strong>消息队列异步取消</strong>：通过<strong>延时消息</strong>实现</p></li></ul><h4 id="何时扣减库存"><a href="#何时扣减库存" class="headerlink" title="何时扣减库存"></a>何时扣减库存</h4><p><strong>下单</strong>时扣减<strong><code>redis</code></strong>中的库存</p><p><strong>支付</strong>时扣减<strong>数据库</strong>中的库存</p><p>扣减<strong>库存系统</strong>中的库存</p><hr><h3 id="秒杀总结"><a href="#秒杀总结" class="headerlink" title="秒杀总结"></a>秒杀总结</h3><p><strong>尽量将请求拦截在系统上游</strong>，后续占据99%的请求，直接Nginx层面拦截掉</p><p><strong>都多写少的场景多使用缓存</strong>，多级缓存保护好数据库</p><p><strong>用消息中间件解决流量削峰</strong>，订单请求写入RocketMQ进行削峰，让RocketMQ轻松抗下高并发压力，让订单系统慢慢消费和处理下单操作</p><h4 id="秒杀商品详细页架构解决方案"><a href="#秒杀商品详细页架构解决方案" class="headerlink" title="秒杀商品详细页架构解决方案"></a>秒杀商品详细页架构解决方案</h4><p><strong>将秒杀活动商品详情页做成静态化</strong></p><p>提前从数据库中把该页面需要的数据都提取出来组装成一份静态数据放在别的地方，避免每次访问都要访问后端数据库，该方案不适用商品比较多的商城如京东，适合商品较少的如小米，因为一旦修改了模板需要全部进行改动。</p><p><strong>CDN+Nginx+Redis多级缓存架构</strong></p><ul><li><strong>第一级缓存</strong>：请求秒杀商品详情页数据时，<strong>从就近<code>CND</code>上加载</strong>，不需要每次请求都到某个机房</li><li><strong>Nginx基于Lua脚本实现本地缓存</strong>：提前把秒杀商品详情页的数据放到Nginx中缓存，不需要把请求转发到商品系统上</li><li><strong>第二级缓存</strong>：Nginx上存在缓存数据过期之类的问题，导致没有找到需要的数据，此时由Nginx中的Lua脚本发送请求到本地缓存</li><li><strong>第三级缓存</strong>：若还没找到，把请求转发到Redis集群中加载提前放入的秒杀商品数据</li></ul><h4 id="秒杀下单TPS压力过大的解决方案"><a href="#秒杀下单TPS压力过大的解决方案" class="headerlink" title="秒杀下单TPS压力过大的解决方案"></a>秒杀下单TPS压力过大的解决方案</h4><ul><li>加数据库服务器方案<ul><li>会导致公司服务器成本急剧飙升</li><li>库存超卖：乐观锁和悲观锁，都会影响性能</li></ul></li><li>用<strong>答题、复杂验证码</strong>的方案<strong>避免作弊</strong>以及<strong>延时下单</strong>：在前端或客户端设置秒杀答题，错开大量人下单的时间，阻止作弊器刷单</li><li><strong>为秒杀独立出一套订单系统</strong>，专门负责秒杀请求：若秒杀下单请求和普通下单请求都由一套订单系统来承载，可能导致秒杀下单请求耗尽订单系统资源，或导致系统不稳定，从而导致其他普通下单请求也出现问题。</li><li><strong>基于Redis实现下单时精准扣减库存</strong>，一旦库存扣减完则秒杀结束：一般会将每个秒杀商品库存提前写入Redis，在下单请求来后直接对Redis中的库存进行扣减</li><li><strong>抢购完毕后提前过滤无效请求，大幅度消减转发到后端的流量</strong><ul><li>在Redis中库存扣减完成后，说明后续其他请求没有必要发送到秒杀系统中了，因为商品已经被抢购完成了，此时可让Nginx接收到后续请求时直接把后续请求过滤掉</li><li>一旦商品抢购完毕，可在Redis或Zookeeper中写入一个秒杀完毕的标志位，然后反向通知Nginx中自己写的Lua脚本，通过Lua脚本将后续请求直接过滤掉</li><li>在网关层或Sentinel做流量控制</li></ul></li><li><strong>瞬时高并发下单请求进入RocketMQ进行削峰，订单系统慢慢拉取消息完成下单操作</strong>：若判断发现通过Redis完成了库存扣减，此时直接发送消息到RocketMQ即可，让普通订单系统从RocketMQ中消费秒杀成功的消息进行常规的流程处理即可，后续订单系统以每秒几千的速率慢慢处理，延迟可能几十秒，这些订单就能被处理完毕</li></ul><h4 id="前端验证问题"><a href="#前端验证问题" class="headerlink" title="前端验证问题"></a>前端验证问题</h4><p><strong>针对前端验证问题</strong>，可通过<strong>提前发<code>Token</code></strong>，在秒杀前设置一个<strong>预约活动</strong>，如一个秒杀活动有<strong><code>20W</code></strong>个商品，可预先准备<strong><code>200W</code></strong>个Token，用户进行预约时，只发放200W个Token，其他人也能预约成功，但是其实没有获得token，后面秒杀直接通过该Token就可过滤掉一大部分人，相当于没有Token的人都只预约了个寂寞。</p><h4 id="针对超卖问题"><a href="#针对超卖问题" class="headerlink" title="针对超卖问题"></a>针对超卖问题</h4><p><strong>针对超卖问题</strong>，可使用<strong><code>Redis</code>分布式锁防超卖</strong>，针对同一个商品ID，使用一把分布式锁，若同时有成千上万个商品要进行秒杀，那就意味着同一时间Redis上锁解锁的操作会要执行成千上万次，这对Redis的性能消耗是相当巨大的，Redis就有可能升级成为新的性能瓶颈。</p><p>可把<strong>秒杀超卖的问题从分布式降级到本地JVM中</strong>，来获取极限性能。<strong>将秒杀服务接入配置中心</strong>，然后在秒杀服务开始前，<strong>由配置中心给每个应用服务实例下发一个库存数量</strong>。然后每次下单，每个服务器只管自己的库存数量，与其他应用服务器<strong>完全不进行库存同步</strong>，在各自的内存里扣减库存，这样就不会有超卖的情况发生。<strong>减少了网络消耗</strong>，性能也能够进一步提升。</p><p>可能给<strong>某服务器上的库存很快消耗完</strong>了，而其他的服务器上仍有库存，整个服务就会表现为你抢不到商品，但是在你后面抢商品的人却能抢到商品，但是这在秒杀这种场景下，完全是可以接受的。</p><p>若<strong>某一个应用服务器挂了</strong>，给他<strong>分配的库存就会丢失</strong>，这时只需要<strong>统计好订单的数量</strong>，可通过MQ来统计，也可通过Redis统计，等秒杀活动30分钟等待支付期过去后，再将没卖出去的库存重新丢回库存池，与没有付款而被取消的订单商品一起返场售卖即可。 </p><hr><h3 id="兜底方案之限流-amp-降级"><a href="#兜底方案之限流-amp-降级" class="headerlink" title="兜底方案之限流&amp;降级"></a>兜底方案之限流&amp;降级</h3><p>对于很多秒杀系统而言，在诸如双十一这样的大流量的迅猛冲击下，都曾经或多或少发生过宕机的情况。当一个系统面临持续的大流量时，它其实<strong>很难单靠自身调整来恢复状态</strong>，必须等待<strong>流量自然下降</strong>或<strong>人为地把流量切走</strong>才行，这无疑会严重影响用户的购物体验。</p><p>在系统<strong>达到不可用状态之前</strong>就做好<strong>流量限制</strong>，防止最坏情况的发生。针对秒杀系统，在遇到大流量时，更多考虑的是<strong>运行阶段</strong>如何保障系统的稳定运行，常用的手段：<strong>限流</strong>，<strong>降级</strong>，<strong>拒绝服务</strong>。</p><p>限流相对降级是一种更极端的保存措施，限流就是当<strong>系统容量达到瓶颈时</strong>，需要通过限制一部分流量来保护系统，并做到既可人工执行开关，也支持自动化保护的措施。</p><p>限流既可在<strong>客户端限流</strong>，也可在<strong>服务端限流</strong>。限流的实现方式既要支持<strong><code>URL</code></strong>以及<strong>方法级别</strong>的限流，也要支持基于 <strong><code>QPS</code></strong>和<strong>线程</strong>的限流。限流必然会导致一部分用户请求失败，因此在系统处理这种异常时<strong>一定要设置超时时间</strong>，防止因被限流的请求不能fast fail（快速失败）而拖垮系统。</p><h4 id="Nginx限流"><a href="#Nginx限流" class="headerlink" title="Nginx限流"></a>Nginx限流</h4><p>可使用<strong><code>ngx_http_limit_conn_module</code></strong>对于一些服务器<strong>流量异常</strong>、<strong>负载过大</strong>，甚至是<strong>大流量的恶意攻击访问</strong>等，进行<strong>并发数的限制</strong>；该模块可<strong>根据定义的键来限制每个键值的连接数</strong>，只有那些正在被处理的请求，这些请求的头信息已被完全读入，所在的连接才会被计数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 限制连接数，客户端的IP地址作为键，</span><br><span class="line"># binary_remote_addr变量长度是固定4字节，在32位平台中占用32字节或64字节，在64位平台中占用64字节</span><br><span class="line"># 1M共享空间可以保存3.2万个32位的状态，1.6万个64位的状态</span><br><span class="line"># 若共享内存空间被耗尽，服务器将会对后续所有的请求返回503即Service Temporarily Unavailable错误</span><br><span class="line">limit_conn_zone $binary_remote_addr zone=addr:10m;</span><br><span class="line">server &#123;</span><br><span class="line">    location /download/ &#123;</span><br><span class="line">        # 指定每个给定键值的最大同时连接数，同一IP同一时间只允许有1个连接</span><br><span class="line">        limit_conn addr 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 缺点：前端做LVS或反向代理，会出现大量的503错误，需要设置白名单对某些ip不做限制</span><br></pre></td></tr></table></figure><p>通过<strong><code>ngx_http_limit_req_module</code></strong>模块可<strong>通过定义的键值来限制请求处理的频率</strong>。特别的可限制来自单个IP地址的请求处理频率。限制的方法如同漏斗，每秒固定处理请求数，推迟过多请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 区域名称为one，大小为10m，平均处理的请求频率不能超过每秒一次。键值是客户端IP</span><br><span class="line">    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">        location /search/ &#123;</span><br><span class="line">            # 允许超出频率限制的请求数为5，默认会被延迟处理，如果不希望延迟处理，可以使用nodelay参数</span><br><span class="line">            limit_req zone=one burst=5 nodelay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/openresty/lua-resty-limit-traffic" rel="external nofollow noopener noreferrer" target="_blank">OpenResty</a>利用Lua限流</p><h4 id="网关接入Sentinel控制台"><a href="#网关接入Sentinel控制台" class="headerlink" title="网关接入Sentinel控制台"></a>网关接入Sentinel控制台</h4><h5 id="Route维度限流"><a href="#Route维度限流" class="headerlink" title="Route维度限流"></a>Route维度限流</h5><h5 id="API维度限流"><a href="#API维度限流" class="headerlink" title="API维度限流"></a>API维度限流</h5><h5 id="应用层限流"><a href="#应用层限流" class="headerlink" title="应用层限流"></a>应用层限流</h5><p>系统第一次上线启动，或系统在Redis故障情况下重新启动，这时在高并发的场景下就会出现所有的流量都打到数据库上，导致数据库崩溃。因此需要通过缓存预热的方案，提前给Redis灌入部分数据后再提供服务。</p><p><img src="../../../../images/Cloud/秒杀/Sentinel流控关联规则配置.png" alt></p><p>可在<strong>流控规则中配置关联模式</strong>，将数据库资源加入限流资源中，<strong>当对数据库访问达到阈值，可对商品详情请求限流</strong>。</p><p><img src="../../../../images/Cloud/秒杀/服务降级总结.png" alt="服务降级总结"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;秒杀业务特性&quot;&gt;&lt;a href=&quot;#秒杀业务特性&quot; class=&quot;headerlink&quot; title=&quot;秒杀业务特性&quot;&gt;&lt;/a&gt;秒杀业务特性&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;秒杀具有瞬时高并发的特点&lt;/strong&gt;，秒杀请求在时间上高度集中于某一特定的时间点（秒杀
      
    
    </summary>
    
      <category term="Cloud" scheme="https://yaoyinglong.github.io/categories/Cloud/"/>
    
    
      <category term="Cloud" scheme="https://yaoyinglong.github.io/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>基础算法</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/基础算法/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-02-23T11:58:47.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h3><p>递归优化：</p><ul><li><strong>使用非递归</strong>：所有递归代码理论上一定可转换成非递归</li><li><strong>加入缓存</strong>：把<strong>中间运算结果保存起来</strong>，这样就可把递归降至为<strong><code>o(n)</code></strong></li><li><strong>尾递归</strong>：<strong>调用函数一定出现在末尾</strong>，没有任何其他操作，编译器在编译代码时，若发现函数末尾已经没有操作了，这时候就不会创建新的栈，且覆盖到前面去。倒着算，每次会把中间结果带下去，不需要再回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fab</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 时间复杂度和空间复杂度都是：O(2^n)</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 递归的终止条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fab(n - <span class="number">1</span>) + fab(n - <span class="number">2</span>); <span class="comment">// 继续递归的过程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">noFab</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 不用递归 O(n)</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 循环</span></span><br><span class="line">        c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fab2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 用数组来做缓存，时间复杂度降为O(n)，空间也降至为O(n)</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (data[n] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = fab2(n - <span class="number">1</span>) + fab2(n - <span class="number">2</span>); <span class="comment">// 继续递归的过程</span></span><br><span class="line">    data[n] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * n    - 是肯定有的</span></span><br><span class="line"><span class="comment"> * res  - 上一次运算出来结果</span></span><br><span class="line"><span class="comment"> * pre  - 上上一次运算出来的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tailfab</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> res, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 时间复杂度和空间复杂度都是：O(n)</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 递归的终止条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tailfab(res, pre + res, n - <span class="number">1</span>); <span class="comment">// JDK源码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 求N的阶乘 用普通递归怎么写 5=5*4*3*2*1=&gt; f(n) =</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * fac(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tailFac</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> res)</span> </span>&#123; <span class="comment">// 尾递归 传结果，res就是我们每次保存的结果</span></span><br><span class="line">    System.out.println(n + <span class="string">":"</span> + res);      <span class="comment">// 这个地方打印出来的值是怎么样的？</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tailFac(n - <span class="number">1</span>, n * res);         <span class="comment">//倒着算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2的整数次幂"><a href="#2的整数次幂" class="headerlink" title="2的整数次幂"></a>2的整数次幂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数据二进制的最高位，低位全部置0，获取小于等于i的最接近的2的整数次幂的数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取大于等于cap的最接近的2的幂的数作为数组的容量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h5 id="Hash应用"><a href="#Hash应用" class="headerlink" title="Hash应用"></a>Hash应用</h5><p><strong>加密</strong>如MD5哈希算法、<strong>判断数据重复</strong>MD5、<strong>相似性检测</strong>如论文检测、指纹算法，把每个论文计算出一个指纹，使用汉明距离，<strong>负载均衡策略</strong>如Nginx可根据ip计算hash值，<strong>分布式系统数据分库分表问题</strong>。<strong>一致性Hash</strong>即<strong>哈希环</strong>。</p><h5 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h5><p>开放寻址法核心思想是，若<strong>出现散列冲突就重新探测一个空闲位置</strong>将其插入，当往散列表中插入数据时，若某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p><strong>缺点</strong>：<strong>删除需要特殊处理</strong>，若插入数据过多会导致散列表<strong>很多冲突查找可能会退化成遍历</strong></p><h5 id="链路地址"><a href="#链路地址" class="headerlink" title="链路地址"></a>链路地址</h5><p>使用链表，链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多，在散列表中，每个key会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。</p><h5 id="常用hash算法"><a href="#常用hash算法" class="headerlink" title="常用hash算法"></a>常用hash算法</h5><p>以下三个Hash散列算法，可将算出的Hash值比较均匀分布到不同的段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash_1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">        hash = <span class="number">33</span> * hash + key.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash) % size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash_2</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">        hash = (hash ^ key.charAt(i)) * p;</span><br><span class="line">    &#125;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">    hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash) % size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash_3</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash, i;</span><br><span class="line">    <span class="keyword">for</span> (hash = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">        hash += key.charAt(i);</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">10</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    hash ^= hash &gt;&gt; <span class="number">11</span>;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash) % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>JDK8</code></strong>中<strong><code>ConcurrentHashMap</code></strong>中因为<strong>数组大小限制导致高位在索引计算中一直用不到</strong>，故在spread方法中将hash的<strong>高16位</strong>利用起来进行<strong>异或转换</strong>，最后与<strong><code>HASH_BITS</code></strong>相与的目的是让得到的hash值总是<strong>正数</strong>，保证正数的目的是，因为<strong><code>hash</code>值为<code>-1</code></strong>表示<strong>哈希表正在扩容中</strong>，该<strong>哈希桶已经被迁移到了新的临时hash表</strong>，此时节点为<strong><code>ForwardingNode</code></strong>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bits;        <span class="comment">// 若为byte那就一个只能存8个数</span></span><br><span class="line">    <span class="keyword">int</span> max;            <span class="comment">// 表示最大的那个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        bits = <span class="keyword">new</span> <span class="keyword">byte</span>[(max &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>];        <span class="comment">//max/8 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;    <span class="comment">// 往bitmap里面添加数字</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; max) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bitsIndex = n &gt;&gt; <span class="number">3</span>; <span class="comment">// 除以8就可知道byte数组下标</span></span><br><span class="line">        <span class="keyword">int</span> loc = n &amp; <span class="number">7</span>;        <span class="comment">// 用&amp;运算，获取bit位</span></span><br><span class="line">        bits[bitsIndex] |= <span class="number">1</span> &lt;&lt; loc; <span class="comment">// 把bit数组中bisIndex下标的byte里面第loc个bit位置为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; max) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bitsIndex = n &gt;&gt; <span class="number">3</span>; <span class="comment">// 除以8就可知道byte数组下标</span></span><br><span class="line">        <span class="keyword">int</span> loc = n &amp; <span class="number">7</span>;        <span class="comment">// 这里其实还可以用&amp;运算</span></span><br><span class="line">        <span class="keyword">int</span> flag = bits[bitsIndex] &amp; <span class="number">1</span> &lt;&lt; loc; <span class="comment">// 若原来那个位置是0 那肯定就是0 只有那个位置是1 才行</span></span><br><span class="line">        <span class="keyword">return</span> flag != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; max) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = n &gt;&gt; <span class="number">3</span>;     <span class="comment">// 除以8就可知道byte数组下标</span></span><br><span class="line">        <span class="keyword">int</span> loc = n &amp; <span class="number">7</span>;        <span class="comment">// 这里其实还可以用&amp;运算</span></span><br><span class="line">        bits[index] &amp;= ~(<span class="number">1</span> &lt;&lt; loc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitMap bitMap = <span class="keyword">new</span> BitMap(<span class="number">200000001</span>); <span class="comment">// 10亿</span></span><br><span class="line">        bitMap.add(<span class="number">2</span>);</span><br><span class="line">        bitMap.add(<span class="number">3</span>);</span><br><span class="line">        bitMap.add(<span class="number">4</span>);</span><br><span class="line">        bitMap.add(<span class="number">63</span>);</span><br><span class="line">        bitMap.add(<span class="number">65</span>);</span><br><span class="line">        System.out.println(bitMap.find(<span class="number">3</span>));</span><br><span class="line">        System.out.println(bitMap.find(<span class="number">64</span>));</span><br><span class="line">        bitMap.delete(<span class="number">3</span>);</span><br><span class="line">        System.out.println(bitMap.find(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    BitSet bits; <span class="comment">// bit数组,bitMap long /64 %34</span></span><br><span class="line">    <span class="comment">// 00000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        bits = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key)</span> </span>&#123;    <span class="comment">// O(1)</span></span><br><span class="line">        <span class="keyword">int</span> hash1 = hash_1(key);</span><br><span class="line">        <span class="keyword">int</span> hash2 = hash_2(key);</span><br><span class="line">        <span class="keyword">int</span> hash3 = hash_3(key);</span><br><span class="line"></span><br><span class="line">        bits.set(hash1, <span class="keyword">true</span>);</span><br><span class="line">        bits.set(hash2, <span class="keyword">true</span>);</span><br><span class="line">        bits.set(hash3, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash1 = hash_1(key);</span><br><span class="line">        <span class="keyword">if</span> (!bits.get(hash1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash2 = hash_2(key);</span><br><span class="line">        <span class="keyword">if</span> (!bits.get(hash2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash3 = hash_3(key);</span><br><span class="line">        <span class="keyword">if</span> (!bits.get(hash3)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash_1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">            hash = <span class="number">33</span> * hash + key.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash) % size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash_2</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            hash = (hash ^ key.charAt(i)) * p;</span><br><span class="line">        &#125;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash) % size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash_3</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash, i;</span><br><span class="line">        <span class="keyword">for</span> (hash = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">            hash += key.charAt(i);</span><br><span class="line">            hash += hash &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            hash ^= hash &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">11</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash) % size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(1000000000) 8bit= 1byte</span></span><br><span class="line">        BloomFilter bloomFilter = <span class="keyword">new</span> BloomFilter(Integer.MAX_VALUE); <span class="comment">// 21亿</span></span><br><span class="line">        System.out.println(bloomFilter.hash_1(<span class="string">"1"</span>));</span><br><span class="line">        System.out.println(bloomFilter.hash_2(<span class="string">"1"</span>));</span><br><span class="line">        System.out.println(bloomFilter.hash_3(<span class="string">"1"</span>));</span><br><span class="line">        bloomFilter.add(<span class="string">"1111"</span>);</span><br><span class="line">        bloomFilter.add(<span class="string">"1123"</span>);</span><br><span class="line">        bloomFilter.add(<span class="string">"11323"</span>);</span><br><span class="line">        System.out.println(bloomFilter.find(<span class="string">"1"</span>));</span><br><span class="line">        System.out.println(bloomFilter.find(<span class="string">"1123"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;斐波那契&quot;&gt;&lt;a href=&quot;#斐波那契&quot; class=&quot;headerlink&quot; title=&quot;斐波那契&quot;&gt;&lt;/a&gt;斐波那契&lt;/h3&gt;&lt;p&gt;递归优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用非递归&lt;/strong&gt;：所有递归代码理论上一定可转换成非递归&lt;/
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue源码</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/PriorityQueue%E6%BA%90%E7%A0%81/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/PriorityQueue源码/</id>
    <published>2021-12-30T16:00:00.000Z</published>
    <updated>2022-01-02T11:19:54.346Z</updated>
    
    <content type="html"><![CDATA[<p>对于<strong><code>PriorityQueue</code>优先队列</strong>最核心的就是其添加元素删除元素后维持元素的顺序的逻辑，其实用的算法其实就是<strong>堆排序</strong>。<strong>堆</strong>其实是一种<strong>特殊的树</strong>，<strong><code>堆</code></strong>是一颗<strong>完全二叉树</strong>，且堆树又分为<strong>大顶堆</strong>和<strong>小顶堆</strong>。</p><p><strong>数组</strong>是<strong>完全二叉树最佳存储结构</strong>，因为完全二叉树有特殊的属性，可<strong>直接利用数组下标</strong>表示<strong>左右节点</strong>，<strong>数组下标为<code>K</code></strong>的元素对应的<strong>完全二叉树中左右子节点在数组中的位置</strong>分别为<strong><code>2*K + 1</code></strong>、<strong><code>2*K+2</code></strong>。</p><p>不论大顶堆还是小顶堆，都是从完全二叉数中<strong>最后一个元素的父节点开始堆化</strong>，将最大或最小的元素排到堆顶，然后遍历整棵树，每一次将堆顶的元素，和<strong>未排序</strong>的<strong>最后一个元素交换</strong>，再进行一次堆化，这样就将数据排好序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSortAsc</span><span class="params">(Integer[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="comment">// len / 2 - 1表示的是从完全二叉数中最后一个元素的父节点开始堆化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = len / <span class="number">2</span> - <span class="number">1</span>; start &gt;= <span class="number">0</span>; start--) &#123;</span><br><span class="line">            maxHeapDown(arr, start, len);  <span class="comment">// 将树中最大的元素排到堆顶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的循环只是将最大的元素排到了堆顶，但是整棵树即数组中的元素不是有序的</span></span><br><span class="line">        <span class="comment">// 每一次将对顶的元素即最大的元素，和未排序的最后一个元素交换，再进行一次堆化，这样就将数据从小到大排序了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = len - <span class="number">1</span>; index &gt; <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[index];</span><br><span class="line">            arr[index] = temp;</span><br><span class="line">            maxHeapDown(arr, <span class="number">0</span>, index); <span class="comment">// len~i已经排好序了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将完全二叉树中最大的元素放到堆顶，end表示最多建到的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapDown</span><span class="params">(Integer[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = start;</span><br><span class="line">        <span class="keyword">int</span> left = parent * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 找到当前节点的左子节点位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = left; <span class="comment">// max表示左右节点大的那一个在数组中的位置</span></span><br><span class="line">            <span class="keyword">if</span> (left + <span class="number">1</span> &lt; end &amp;&amp; arr[left] &lt; arr[left + <span class="number">1</span>]) &#123; <span class="comment">// 比较左右节点和父节点的大小</span></span><br><span class="line">                max = left + <span class="number">1</span>; <span class="comment">// 若右节点比左节点大，则将父节点和右节点交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若左节点比右节点大，则将父节点和左节点交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[parent] &gt; arr[max]) &#123; <span class="comment">// 若父节点大于子节点中最大的那一个，则退出</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若父节点小于子节点中最大的那一个，则交换</span></span><br><span class="line">                <span class="keyword">int</span> tmp = arr[parent];</span><br><span class="line">                arr[parent] = arr[max];</span><br><span class="line">                arr[max] = tmp;</span><br><span class="line">                parent = max;   <span class="comment">// 还原指针，交换数据后，max指向的是被交换下来的父节点，还需要往下遍历，故需要将parent指向需要遍历的数据</span></span><br><span class="line">                left = parent * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 找到之前左右节点大的节点的左子节点在数组中的索引位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSortDesc</span><span class="params">(Integer[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = len / <span class="number">2</span> - <span class="number">1</span>; start &gt;= <span class="number">0</span>; start--) &#123;</span><br><span class="line">            minHeapDown(arr, start, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = len - <span class="number">1</span>; index &gt; <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[index];</span><br><span class="line">            arr[index] = tmp;</span><br><span class="line">            minHeapDown(arr, <span class="number">0</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将完全二叉树中最小的元素放到堆顶，end表示最多建到的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minHeapDown</span><span class="params">(Integer[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = start;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * start + <span class="number">1</span>; <span class="comment">// 找到当前节点的左子节点位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = left; <span class="comment">// min表示左右节点小的那一个在数组中的位置</span></span><br><span class="line">            <span class="keyword">if</span> (left + <span class="number">1</span> &lt; end &amp;&amp; arr[left] &gt; arr[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                min = left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[parent]) &#123;  <span class="comment">// 比较左右节点中小的那一个和父节点的大小</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 若小的那个节点都比父节点大，说明不需要再遍历了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[min];</span><br><span class="line">            arr[min] = arr[parent];</span><br><span class="line">            arr[parent] = tmp;</span><br><span class="line">            parent = min;   <span class="comment">// 还原指针，交换数据后，min指向的是被交换下来的父节点，还需要往下遍历，故需要将parent指向需要遍历的数据</span></span><br><span class="line">            left = <span class="number">2</span> * parent + <span class="number">1</span>;  <span class="comment">// 找到之前左右节点小的节点的左子节点在数组中的索引位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSortTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">74</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">29</span>&#125;;</span><br><span class="line">            heapSortAsc(arr);</span><br><span class="line">            System.err.println(<span class="string">" after:"</span> + Arrays.asList(arr));</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">74</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">29</span>&#125;;</span><br><span class="line">            heapSortDesc(arr);</span><br><span class="line">            System.err.println(<span class="string">" after:"</span> + Arrays.asList(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若传入的集合是一个<strong>排序好的集合</strong>，则直接将数据拷贝到<strong><code>PriorityQueue</code></strong>的内部数组<strong><code>queue</code></strong>中，若传入结合本身就是一个<strong><code>PriorityQueue</code></strong>，则直接赋值<strong><code>queue</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">transient</span> Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">            initElementsFromCollection(ss); <span class="comment">// 直接将数据拷贝到queue中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">            initFromPriorityQueue(pq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">        <span class="keyword">if</span> (a.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">a</span> </span>= Arrays.copyOf(a, a.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.queue = a;</span><br><span class="line">        <span class="keyword">this</span>.size = a.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromPriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == PriorityQueue<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = c.toArray();</span><br><span class="line">            <span class="keyword">this</span>.size = c.size();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆化的关键代码，和上面的堆排序的例子一样，这里是使用的<strong>小顶堆</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从完全二叉数中最后一个元素的父节点开始堆化，之所以右移再减一，是因为数组下标是从0开始的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)<span class="comment">// 若传入的comparator不为空则使用传入的</span></span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123; <span class="comment">// 传入的K必须要小于堆元素个数的一半，因为堆化最多就循环half次</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 找到K节点的左子节点</span></span><br><span class="line">        Object c = queue[child];<span class="comment">// 获取K节点的左子节点值</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;<span class="comment">// 找到K节点的右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right]; <span class="comment">// 若K的左子节点值小于右子节点值，则将C置为右子节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)<span class="comment">// 将目标对象X与K的左右子节点中最小的比较</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 若目标对象X比K的左右子节点最小的值还小，则不用交换直接退出</span></span><br><span class="line">        queue[k] = c; <span class="comment">// 若X比K的左右子节点最小的值还大，则将K对应的值与子节点中最小的值交换</span></span><br><span class="line">        k = child; <span class="comment">// 将K指针恢复，因为上一步做了交换，K指向的交换后的c</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x; <span class="comment">// 将目标值赋值给K</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123; <span class="comment">// 传入的K必须要小于堆元素个数的一半，因为堆化最多就循环half次</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 找到K节点的左子节点</span></span><br><span class="line">        Object c = queue[child];<span class="comment">// 获取K节点的左子节点值</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;<span class="comment">// 找到K节点的右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right]; <span class="comment">// 若K的左子节点值小于右子节点值，则将C置为右子节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)<span class="comment">// 将目标对象X与K的左右子节点中最小的比较</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// 若目标对象X比K的左右子节点最小的值还小，则不用交换直接退出</span></span><br><span class="line">        queue[k] = c;<span class="comment">// 若X比K的左右子节点最小的值还大，则将K对应的值与子节点中最小的值交换</span></span><br><span class="line">        k = child;<span class="comment">// 将K指针恢复，因为上一步做了交换，K指向的交换后的c</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;<span class="comment">// 将目标值赋值给K</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加元素</strong>，若元素个数已经大于等于数组长度了，则进行扩容，若旧的容量小于64，则每次扩容为旧容量的<strong>一倍加<code>2</code></strong>，否则扩容<strong>旧容量的一半</strong>。然后<strong><code>siftUp</code></strong>进行<strong>小顶堆插入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ? (oldCapacity + <span class="number">2</span>) : (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;<span class="comment">// 将插入值从堆尾，的父节点一直比较，直到找到其该放置的位置，退出</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">// 找到K的父节点</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// 若父节点值小于目标节点直接退出循环，将目标值直接复制给K</span></span><br><span class="line">        queue[k] = e;<span class="comment">// 若父节点值大于目标节点，则交换父子节点的额值</span></span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素，若队列中无元素则直接返回null，然后获取第0个元素和最后一个元素，然后删除最后一个元素，这里其实就是<strong>删除第<code>0</code>个元素</strong>，然后<strong>将最后一个元素与第<code>0</code>个元素交换</strong>，然后再<strong>进行一次堆化</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="comment">// 若队列元素为null直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>]; <span class="comment">// 获取第0个元素</span></span><br><span class="line">    E x = (E) queue[s]; <span class="comment">// 获取最后一个元素</span></span><br><span class="line">    queue[s] = <span class="keyword">null</span>;<span class="comment">// 将最后一个元素置空</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123; <span class="comment">// 传入的K必须要小于堆元素个数的一半，因为堆化最多就循环half次</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 找到K节点的左子节点</span></span><br><span class="line">        Object c = queue[child];<span class="comment">// 获取K节点的左子节点值</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;<span class="comment">// 找到K节点的右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right]; <span class="comment">// 若K的左子节点值小于右子节点值，则将C置为右子节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)<span class="comment">// 将目标对象X与K的左右子节点中最小的比较</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 若目标对象X比K的左右子节点最小的值还小，则不用交换直接退出</span></span><br><span class="line">        queue[k] = c; <span class="comment">// 若X比K的左右子节点最小的值还大，则将K对应的值与子节点中最小的值交换</span></span><br><span class="line">        k = child; <span class="comment">// 将K指针恢复，因为上一步做了交换，K指向的交换后的c</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x; <span class="comment">// 将目标值赋值给K</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于&lt;strong&gt;&lt;code&gt;PriorityQueue&lt;/code&gt;优先队列&lt;/strong&gt;最核心的就是其添加元素删除元素后维持元素的顺序的逻辑，其实用的算法其实就是&lt;strong&gt;堆排序&lt;/strong&gt;。&lt;strong&gt;堆&lt;/strong&gt;其实是一种&lt;strong
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PriorityQueue" scheme="https://yaoyinglong.github.io/tags/PriorityQueue/"/>
    
  </entry>
  
</feed>
