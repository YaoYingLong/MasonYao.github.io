<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2024-03-06T14:39:02.513Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim编辑器</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/Linux/Vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/Linux/Vim编辑器/</id>
    <published>2024-03-05T16:00:00.000Z</published>
    <updated>2024-03-06T14:39:02.513Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中文本编辑器有<strong><code>emacs</code></strong>、<strong><code>pico</code></strong>、<strong><code>nano</code></strong>、<strong><code>joe</code></strong>、<strong><code>vim</code></strong>等，所有Unix Like系统都会<strong>内建<code>vi</code>文本编辑器</strong>，其他文本编辑器不一定会存在，很多<strong>个别软件</strong>的<strong>编辑接口</strong>都会主动呼出<strong><code>vi</code></strong>，如<strong><code>crontab</code></strong>、<strong><code>visudo</code></strong>、<strong><code>edquota</code></strong>等指令，且<strong><code>vi</code>程序简单编辑速度快速</strong>；</p><p>vi是老式的文本处理器，<strong><code>vim</code>可视为<code>vi</code>的进阶版</strong>加入了<strong>正规匹配</strong>、<strong>多文件编辑</strong>、<strong>区块复制</strong>等额外功能，且<strong><code>vim</code>具有程序编辑能力</strong>可主动以<strong>字体颜色</strong>辨别<strong>语法正确性</strong>方便程序设计，甚至一些Linux<strong>基础配置文件</strong>内的语法都能用vim来检查；<strong><code>CentOS 7</code></strong>中一般账号<strong>预设<code>vi</code>已被<code>vim</code>取代</strong>。</p><p>vi共分为<strong>一般指令模式</strong>、<strong>编辑模式</strong>、<strong>底行模式</strong>三种工作模式，<strong>一般指令模式</strong>可与<strong>编辑模式</strong>及<strong>底行模式</strong>切换，但<strong>编辑模式</strong>与<strong>底行模式</strong>之间不可互相切换，这三种模式的作用如下：   </p><ul><li><strong>一般指令模式</strong>：以vi打开一个文件就直接进入该工作模式，该模式中可使用<strong>上下左右</strong>按键来<strong>移动光标</strong>，可使用<strong>删除字符</strong>或<strong>删除整行</strong>来处理文件内容，也可使用<strong>复制</strong>、<strong>粘贴</strong>来处理文件数据，无法编辑文件内容；</li><li><strong>编辑模式</strong>：按<strong><code>i</code></strong>、<strong><code>I</code></strong>、<strong><code>o</code></strong>、<strong><code>O</code></strong>、<strong><code>a</code></strong>、<strong><code>A</code></strong>、<strong><code>r</code></strong>、<strong><code>R</code></strong>等任一字母进入编辑模式，且在画面左下方会出现<strong><code>INSERT</code></strong>或<strong><code>REPLACE</code></strong>的字样，按<strong><code>Esc</code></strong>按键即可<strong>退出编辑模式</strong>回到一般指令模式；</li><li><strong>低行模式</strong>：在一般模式中输入<strong><code>:</code></strong>、<strong><code>/</code></strong>、<strong><code>?</code></strong>等任一字符，即可将光标移动到最底下一行，在该模式中可提供<strong>内容搜索</strong>以及<strong>读取</strong>、<strong>存盘</strong>、<strong>大量取代字符</strong>、<strong>离开vi</strong> 、<strong>显示行号</strong>等动作；</li></ul><h3 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h3><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>h</code></strong>或<strong>向左箭头键<code>←</code></strong></td><td>光标<strong>向左</strong>移动<strong>一个字符</strong>，若想<strong>一次移动多个</strong>，加上想要进行的次数，按下动作即可</td></tr><tr><td><strong><code>j</code></strong>或<strong>向下箭头键<code>↓</code></strong></td><td>光标<strong>向下</strong>移动<strong>一个字符</strong>，<strong><code>30j</code></strong>或<strong>30<code>↓</code></strong>向下移动30行</td></tr><tr><td><strong><code>k</code></strong>或<strong>向上箭头键<code>↑</code></strong></td><td>光标<strong>向上</strong>移动<strong>一个字符</strong>，</td></tr><tr><td><strong><code>l</code></strong>或<strong>向右箭头键<code>→</code></strong></td><td>光标<strong>向右</strong>移动<strong>一个字符</strong>，</td></tr><tr><td><strong><code>Ctrl + f</code></strong></td><td><strong>屏幕向</strong>下移动<strong>一页</strong>，相当于<code>Page Down</code>按键</td></tr><tr><td><strong><code>Ctrl + b</code></strong></td><td><strong>屏幕向上</strong>移动<strong>一页</strong>，相当于<strong><code>Page Up</code></strong>按键</td></tr><tr><td><strong><code>Ctrl + d</code></strong></td><td><strong>屏幕向下</strong>移动<strong>半页</strong></td></tr><tr><td><strong><code>Ctrl + u</code></strong></td><td><strong>屏幕向上</strong>移动<strong>半页</strong></td></tr><tr><td><strong><code>+</code></strong></td><td>光标移动到<strong>非空格符的下一行</strong></td></tr><tr><td><strong><code>-</code></strong></td><td>光标移动到<strong>非空格符的上一行</strong></td></tr><tr><td><strong><code>n&lt;space&gt;</code></strong></td><td><strong>n为数字</strong>，光标<strong>向右移动这一行的第n个字符</strong>，如<strong><code>20&lt;space&gt;</code></strong>光标会向后面移动第20个字符处</td></tr><tr><td><strong>数字<code>0</code></strong>或<strong><code>Home</code>功能键</strong></td><td>移动到<strong>行的最前面一个字符</strong>处</td></tr><tr><td><strong><code>$</code></strong>或<strong><code>End</code>功能键</strong></td><td>移动到<strong>行的最后一个字符</strong>处</td></tr><tr><td><strong><code>H</code></strong></td><td>光标移动到<strong>屏幕的最上方那一行</strong>的<strong>第一个字符</strong></td></tr><tr><td><strong><code>M</code></strong></td><td>光标移动到<strong>屏幕的中央那一行</strong>的<strong>第一个字符</strong></td></tr><tr><td><strong><code>L</code></strong></td><td>光标移动到<strong>屏幕的最下方那一行</strong>的<strong>第一个字符</strong></td></tr><tr><td><strong><code>G</code></strong></td><td>移动到<strong>文件最后一行</strong></td></tr><tr><td><strong><code>nG</code></strong></td><td><strong>n为数字</strong>，移动到<strong>文件的第<code>n</code>行</strong>，如<strong><code>20G</code></strong>则会移动到<strong>文件第20行</strong>，可配合<strong><code>set nu</code></strong></td></tr><tr><td><strong><code>gg</code></strong></td><td>光标移动到<strong>文件的第一行</strong>，相当于<strong><code>1G</code></strong></td></tr><tr><td><strong><code>n&lt;Enter&gt;</code></strong></td><td><strong>n为数字</strong>，光标<strong>向下移动<code>n</code>行</strong></td></tr></tbody></table><h4 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h4><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>/word</code></strong></td><td>光标<strong>向下搜索</strong>名称为<strong><code>word</code>的字符串</strong>，如在文件内搜寻vbird字符串即就输入/vbird</td></tr><tr><td><strong><code>?word</code></strong></td><td>光标<strong>向上搜索</strong>名称为<strong><code>word</code>的字符串</strong></td></tr><tr><td><strong><code>n</code></strong></td><td>字母按键<strong><code>n</code></strong>表示<strong>重复前一个搜索动作</strong>，如执行<strong><code>/word</code></strong>，按下n后会<strong>向下继续搜索</strong>名称为word的字符串，<br>若执行<strong><code>?word</code></strong>，按下n则会<strong>向上继续搜索</strong>名称为word的字符串</td></tr><tr><td><strong><code>N</code></strong></td><td><strong>字母按键<code>N</code></strong>表示<strong>反向进行前一个搜寻动作</strong>，如执行/word，按下N则表示向上搜寻word</td></tr><tr><td><strong><code>:n1,n2s/word1/word2/g</code></strong></td><td><strong><code>n1</code></strong>与<strong><code>n2</code></strong>为数字，在<strong>第<code>n1</code>与<code>n2</code>行之间搜索<code>word1</code>字符串</strong>，并将<strong><code>word1</code></strong>替换为<strong><code>word2</code></strong>，<br>如<strong><code>:100,200s/vbird/VBIRD/g</code></strong>表示在100到200行之间搜索vbird并取代为VBIRD</td></tr><tr><td><strong><code>:1,$s/word1/word2/g</code></strong></td><td>从<strong>第一行</strong>到<strong>最后一行</strong>搜索<strong><code>word1</code></strong>字符串，并将<strong><code>word1</code></strong>替换为<strong><code>word2</code></strong></td></tr><tr><td><strong><code>:1,$s/word1/word2/gc</code></strong></td><td>从<strong>第一行</strong>到<strong>最后一行</strong>搜索<strong><code>word1</code></strong>字符串，并将<strong><code>word1</code></strong>替换为<strong><code>word2</code></strong>，<br>且<strong>在取代前显示提示字符给用户确认是否需要取代</strong></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux中文本编辑器有&lt;strong&gt;&lt;code&gt;emacs&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;pico&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;nano&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;joe&lt;/
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/Linux/"/>
    
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux压缩打包备份</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/Linux/%E6%96%87%E4%BB%B6&amp;%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85%E5%A4%87%E4%BB%BD/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/Linux/文件&amp;文件系统压缩打包备份/</id>
    <published>2024-01-06T16:00:00.000Z</published>
    <updated>2024-03-05T14:18:23.569Z</updated>
    
    <content type="html"><![CDATA[<p>计算机最小单位是bits，<strong><code>1byte=8bits</code></strong>这就是所谓的二进制，如<strong>数字1</strong>用二进制表示为<strong><code>00000001</code></strong>，其实数字1只占用了1个bit，而其他的7个bits是自动被填充为0的，只是为了满足目前操作系统数据存储；可以利用一些复杂的计算方式，将这些没有使用的空间压缩出来，然文件占用空间变小，这就是<strong>压缩技术</strong>；<strong>另一种压缩技术</strong>是<strong>将重复的数据进行统计记录</strong>，如数据为<strong><code>111……</code></strong>共100个1，压缩技术会记录100个1而不是真正100个1的位存在；</p><p>虽然Linux扩展名没有什么作用，但由于Linux支持的压缩指令非常多，为了简单明了的指导文件压缩方式，所以通过扩展名来作为区分，<strong><code>gzip</code></strong>是有GNU计划所开发出来的压缩指令，已取代<strong><code>compress</code></strong>指令，后来GNU又开发了<strong><code>bzip2</code></strong>和<strong><code>xz</code></strong>这几个<strong>压缩比更好</strong>的压缩指令，<strong>为了支持windows常见的zip压缩格式</strong>文件Linux也有<strong><code>zip</code></strong>命令，但这些<strong>压缩指令通常仅能针对一个文件来压缩与解压缩</strong>，所以<strong>打包软件<code>tar</code></strong>应运而生，<strong><code>tar</code></strong>可将<strong>多文件</strong>甚至<strong>目录</strong>打包成一个文件，<strong>单纯的tar功能仅是打包并没有提供压缩功能</strong>，后来GNU计划中将整个tar与压缩功能结合到一起：</p><ul><li><strong><code>*.tar</code></strong>：tar程序打包的数据，并没有压缩过</li><li><strong><code>*.tar.gz</code> </strong>：tar程序打包的文件，且经过<strong><code>gzip</code></strong>压缩</li><li><strong><code>*.tar.bz2</code></strong>：tar程序打包的文件，且经过<strong><code>bzip2</code></strong>压缩</li><li><strong><code>*.tar.xz</code></strong>：tar程序打包的文件，且经过xz压缩</li><li><strong><code>*.gz</code></strong>：gzip程序压缩的文件</li><li><strong><code>*.Z</code></strong>：compress程序压缩的文件</li><li><strong><code>*.bz2</code></strong>：bzip2程序压缩的文件</li><li><strong><code>*.xz</code></strong>：xz程序压缩的文件</li><li><strong><code>*.zip</code></strong>：zip程序压缩的文件</li></ul><p><strong><code>gzip</code></strong>是<strong>应用最广</strong>的压缩指令，<strong>可解开<code>compress</code>、<code>zip</code>、<code>gzip</code>等软件所压缩的文件</strong>，所创建的压缩文件后缀名为<strong><code>*.gz</code></strong>，当使用gzip进行压缩时，<strong>预设状态</strong>下原本的文件会被压缩成<strong><code>.gz</code></strong>且<strong>源文件将不在存在</strong>，且<strong><code>gzip -d</code></strong>也会将<strong>原本的<code>.gz</code>删除</strong>恢复到原本的文件，可通过<strong><code>-c</code></strong>选项配合<strong><code>&gt;</code></strong>将原本要转换成压缩文件的内容<strong>变成字符类型从屏幕输出</strong>，再通过<strong><code>&gt;</code></strong>符号转成输出到文件，这样操作文件名需要自己写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gzip [-cdtv#] 文件名</span><br><span class="line">zcat 文件名.gz</span><br><span class="line">选项与参数：</span><br><span class="line">    -c：将压缩的数据输出到屏幕上，可通过数据流重导向来处理</span><br><span class="line">    -d：解压缩的参数</span><br><span class="line">    -t：可用来检验一个压缩文件的一致性，看看文件有无错误</span><br><span class="line">    -v：可显示出原文件/压缩文件案的压缩比等信息</span><br><span class="line">    -#：#为数字代表压缩等级，-1最快，但是压缩比最差-9最慢，但是压缩比最好预设是-6</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 压缩services文件为services.gz</span><br><span class="line">gzip -v services</span><br><span class="line"><span class="meta">#</span> 最佳的压缩比压缩，并保留原文件</span><br><span class="line">gzip -9 -c services &gt; services.gz</span><br></pre></td></tr></table></figure><p>可使用<strong><code>cat</code></strong>、<strong><code>more</code></strong>、<strong><code>less</code></strong>来读取<strong>纯文本文件</strong>，<strong><code>zcat</code></strong>、<strong><code>zmore</code></strong>、<strong><code>zless</code></strong>则可用来<strong>读取纯文本文件被压缩后的压缩文件</strong>，由于<strong><code>gzip</code></strong>压缩指令主要想要用来取代compress，故不但compress的压缩文件可使用gzip来解开，同时<strong>zcat</strong>指令可<strong>同时读取<code>compress</code>与<code>gzip</code>的压缩文件</strong>，若想从<strong>被压缩的纯文本文件</strong>中查找数据，可通过<strong><code>egrep</code></strong>命令来搜索<strong>不需要将文件解压</strong>再通过<strong><code>grep</code></strong>命令来查询；</p><p><strong><code>gzip</code></strong>是为了取代<strong><code>compress</code></strong>并提供<strong>更好的压缩比</strong>而产生，<strong><code>bzip2</code></strong>则是为了<strong>取代<code>gzip</code></strong>并提供更佳的压缩比而产生的，且<strong><code>bzip2</code></strong>的用法与<strong><code>gzip</code></strong>几乎相同；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bzip2 [-cdkzv#] 文件名</span><br><span class="line">bzcat 文件.bz2</span><br><span class="line">选项与参数：</span><br><span class="line">    -c：将压缩的过程产生的数据输出到屏幕上</span><br><span class="line">    -d：解压缩的参数</span><br><span class="line">    -k：保留源文件，而不会删除原始的文件</span><br><span class="line">    -z：压缩的参数，默认值，可不加</span><br><span class="line">    -v：可显示出原文件/压缩文件案的压缩比等信息</span><br><span class="line">    -#：#为数字代表压缩等级，-1最快，但是压缩比最差-9最慢，但是压缩比最好预设是-6</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 压缩services文件</span><br><span class="line">bzip2 -v services</span><br><span class="line"><span class="meta">#</span> 文件内容读取</span><br><span class="line">bzcat services.bz2</span><br><span class="line"><span class="meta">#</span> 解压缩</span><br><span class="line">bzip2 -d services.bz2</span><br><span class="line"><span class="meta">#</span> 最佳的压缩比压缩，并保留原本的文件</span><br><span class="line">bzip2 -9 -c services &gt; services.bz2</span><br></pre></td></tr></table></figure><p><strong><code>xz</code></strong>的用法也与<strong><code>bzip2</code></strong>和<strong><code>gzip</code></strong>几乎相同，虽然<strong><code>xz</code>压缩比非常好</strong>，但<strong><code>xz</code>压缩非常费时间</strong>，可通过<strong><code>time [gzip|bzip2|xz] -c services &gt; services.[gz|bz2|xz]</code></strong>命令统计各个压缩指令压缩时间；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">xz [-dtlkc#] 文件</span><br><span class="line">xcat 文件名.xz</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">    -d：解压缩参数</span><br><span class="line">    -t：测试压缩文件的完整性，看有没有错误</span><br><span class="line">    -l：列出压缩文件的相关信息</span><br><span class="line">    -k：保留源文件，而不会删除原始的文件</span><br><span class="line">    -c：将压缩的过程产生的数据输出到屏幕上</span><br><span class="line">    -#：#为数字代表压缩等级，-1最快，但是压缩比最差-9最慢，但是压缩比最好预设是-6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 压缩</span><br><span class="line">xz -v services</span><br><span class="line"><span class="meta">#</span> 列出这个文件的压缩前后的容量</span><br><span class="line">xz -l services.xz</span><br><span class="line"><span class="meta">#</span> 读取压缩文件内容</span><br><span class="line">xzcat services.xz</span><br><span class="line"><span class="meta">#</span> 解压缩</span><br><span class="line">xz -d services.xz</span><br><span class="line"><span class="meta">#</span> 压缩且保留原文件</span><br><span class="line">xz -k services</span><br></pre></td></tr></table></figure><p>虽然<strong><code>gzip、bzip2、xz</code></strong>也<strong>能针对目录进行压缩</strong>，但对目录的压缩时<strong>将目录内的所有文件分别压缩</strong>，而不像Windows中使用WinRAR这类软件将多数据包成一个文件；tar可将<strong>多个文件</strong>或<strong>目录</strong>打包成一个大文件，<strong>同时</strong>也能通过<strong><code>gzip、bzip2、xz</code></strong>的支持将该文件<strong>同时进行压缩</strong>，且Windows中的<strong><code>WinRAR</code></strong>也支持<strong><code>.tar.gz</code></strong>文件的解压，<strong><code>-f</code></strong>参数一定要<strong>紧挨着文件名</strong>，错误示例<strong><code>tar -zpcfv etc.tar.gz /etc/</code></strong>该命令将<strong>会导致产生的文件名为<code>v</code></strong>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 打包与压缩</span><br><span class="line">tar [-z|-j|-J] [cv] [-f 待建立的新文件名] filename...</span><br><span class="line"><span class="meta">#</span> 查看压缩文件列表</span><br><span class="line">tar [-z|-j|-J] [tv] [-f 既有的tar文件]</span><br><span class="line"><span class="meta">#</span> 解压缩</span><br><span class="line">tar [-z|-j|-J] [xv] [-f 既有的tar文件] [-C 目录]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 注意：-z, -j, -J不可同时出现在一串指令列中</span><br><span class="line"><span class="meta">#</span> 注意：-c, -t, -x不可同时出现在同一指令列中</span><br><span class="line">选项与参数：</span><br><span class="line">    -c：建立打包文件，可搭配-v来察看过程中被打包的文件(filename)</span><br><span class="line">    -t：察看打包文件的内容含有哪些文件，重点在察看被压缩的文件列表</span><br><span class="line">    -x：解压缩，可以搭配-C(大写)在特定目录解开</span><br><span class="line">    -z：通过gzip的支持进行压缩/解压缩，此时档名最好为*.tar.gz</span><br><span class="line">    -j：通过bzip2的支持进行压缩/解压缩，此时档名最好为*.tar.bz2</span><br><span class="line">    -J：通过xz的支持进行压缩/解压缩，此时档名最好为*.tar.xz</span><br><span class="line">    -v：在压缩/解压缩的过程中，将正在处理的文件名显示出来</span><br><span class="line">    -f filename：-f后面要立刻接要被处理的文件名，建议-f单独写一个选项</span><br><span class="line">    -C 目录：该选项用在解压缩，若要在特定目录解压缩，可使用该选项</span><br><span class="line">    -p(小写)：保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件</span><br><span class="line">    -P(大写)：保留绝对路径，亦即允许备份数据中含有根目录</span><br><span class="line">    --exclude=FILE：在压缩的过程中，不要将FILE打包</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用gzip打包压缩etc目录，并保留原本文件的权限与属性</span><br><span class="line">tar -zpcvf etc.tar.gz /etc/</span><br><span class="line">tar -zpcv -f etc.tar.gz /etc/</span><br><span class="line"><span class="meta">#</span> 使用bzip2打包压缩etc目录，并保留原本文件的权限与属性</span><br><span class="line">tar -jpcvf etc.tar.bz2 /etc/</span><br><span class="line"><span class="meta">#</span> 使用xz打包压缩etc目录，并保留原本文件的权限与属性</span><br><span class="line">tar -Jpcvf etc.tar.xz /etc/</span><br><span class="line"><span class="meta">#</span> 查看打包文件内部的文件列表，加上-v参数详细的文件权限和属性也会被列出来</span><br><span class="line">tar -jtvf /root/etc.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将文件根目录也备份下来</span><br><span class="line">tar -zpPcvf testP.tar.gz /root/anaconda-ks.cfg /root/initial-setup-ks.cfg</span><br><span class="line"><span class="meta">#</span> 需要备份根目录需要写绝对路径，相对路径即使加上-P参数也不会备份根目录</span><br><span class="line">tar -zpPcvf testP2.tar.gz anaconda-ks.cfg initial-setup-ks.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 通过-C参数将压缩文件解压到指定目录</span><br><span class="line">tar -zxvf testP2.tar.gz -C /tmp/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压压缩文件中的指定文件，可先通过-jtv找到目标文件</span><br><span class="line">tar -jtvf etc.tar.bz2 | grep shadow</span><br><span class="line">---------- root/root       857 2022-07-31 21:43 etc/gshadow</span><br><span class="line">---------- root/root      1451 2022-07-31 21:45 etc/shadow</span><br><span class="line">---------- root/root       869 2022-07-31 21:43 etc/gshadow-</span><br><span class="line">---------- root/root      1385 2022-07-31 21:43 etc/shadow-</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 仅仅解压etc.tar.bz2中的etc/shadow文件</span><br><span class="line">tar -jxvf /root/etc.tar.bz2 etc/shadow</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打包目录时不包含某些文件：不包含以.gz结尾的文，也不包含隐藏文件</span><br><span class="line">tar -jcvf root.tar.bz2 --exclude=*.gz --exclude=\.*  /root/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查找比/etc/passwd文件还要新的文件</span><br><span class="line">find /etc -newer /etc/passwd</span><br><span class="line"><span class="meta">#</span> 查看/etc/passwd文件的mtime</span><br><span class="line">ll /etc/passwd</span><br><span class="line"><span class="meta">#</span> 由于某系版本的centos查询mtime是通过ll --time=use，所以会不支持</span><br><span class="line">tar -jcvf newer.then.passwd.tar.bz2 --newer-mtime="2022/07/31" /etc</span><br><span class="line"><span class="meta">#</span> 查看压缩文件中结尾为非/的文件列表</span><br><span class="line">tar -jtvf newer.then.passwd.tar.bz2 | grep -v '/$'</span><br></pre></td></tr></table></figure><p>如果<strong>不加<code>-P</code></strong>参数对文件或目录进行打包，打包后的文件名将<strong>不会保留根目录</strong>，<strong>主要是为了安全</strong>，因为如果<strong>保留根目录</strong>，<strong>解压后数据将覆盖原来根目录下得对应数据</strong>；</p><p>使用tar打包出来的文件是<strong>否对文件进行压缩</strong>所<strong>得到的文件称呼不一样</strong>，若<strong>仅打包不压缩</strong>得到的文件称为<strong><code>tarfile</code></strong>，若<strong>进行压缩</strong>称为<strong><code>tarball</code></strong>；tar除了将文件或目录打包以外，还能将文件打包到特别的设备中，如磁带；由于磁带是一次性读写设备，不能使用类似cp等指令来复制，若想备份/home、/root到磁带中，可使用<strong><code>tar -cvf</code></strong>指令；<strong>tar还支持通过标准输入输出的数据流重导向，以及管道命令的方式，将待处理的文件一边打包一边压缩到目标目录中</strong>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将/etc整个目录一边打包一边在/tmp解开，有点类似于cp -r /etc /tmp</span><br><span class="line"><span class="meta">#</span> 输入-f后的输出文件名和输入文件变成了-</span><br><span class="line">cd /tmp</span><br><span class="line">tar -cvf - /etc | tar -xvf -</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将/etc /home /var/spool/mail /var/spool/cron /root这五个目录打包且排除root目录中的压缩文件以及home目录中的loop开头的文件或文件夹</span><br><span class="line">tar -jcv -f /backups/backup-system-20150701.tar.bz2 --exclude=/root/*.bz2 --exclude=/root/*.gz --exclude=/home/loop* /etc /home /var/spool/mail /var/spool/cron /root</span><br></pre></td></tr></table></figure><h3 id="XFS文件系统备份与还原"><a href="#XFS文件系统备份与还原" class="headerlink" title="XFS文件系统备份与还原"></a>XFS文件系统备份与还原</h3><p>由于CentOS 7已<strong>默认</strong>使用<strong><code>XFS</code></strong>文件系统，故好用使用<strong><code>xfsdump</code></strong>与<strong><code>xfsrestore</code></strong>来对文件系统进行备份与还原；<strong><code>xfsdump</code></strong>除了可以进行文件系统的完整备份外，还可以进行增量备份；第一次备份一定是完整备份，完整备份在xfsdump中被定义为<strong><code>level 0</code></strong>；各个<strong><code>level</code></strong>的纪录文件则放置于<strong><code>/var/lib/xfsdump/inventory</code></strong>中；<strong><code>xfsdump</code></strong>预设<strong>仅支持文件系统的备份</strong>，并<strong>不支持特定目录的备份</strong>，故不能用xfsdump去备份/etc，其不是一个独立的文件系统； </p><ul><li><strong><code>xfsdump</code>不支持未挂载的文件系统备份</strong></li><li><strong><code>xfsdump</code></strong>必须使用<strong>root权限才能操作</strong></li><li><strong><code>xfsdump</code></strong>只能备份<strong><code>XFS</code></strong>文件系统</li><li><strong><code>xfsdump</code></strong>备份的数据<strong>只能</strong>被<strong><code>xfsrestore</code></strong>解析</li><li><strong><code>xfsdump</code></strong>是通过<strong>文件系统的UUID</strong>来分辨各个备份的，因此备份的UUID不能相同</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份档] 待备份资料</span><br><span class="line">选项与参数：</span><br><span class="line">    -L ：xfsdump会纪录每次备份的session标头，这里可填写针对此文件系统的简易说明</span><br><span class="line">    -M ：xfsdump可纪录储存媒体的标头，这里可填写此媒体的简易说明</span><br><span class="line">    -l ：是L的小写，指定等级有0~9共10个等级 (预设为0，即完整备份)</span><br><span class="line">    -f ：有点类似tar后面接产生的文件，可接例如/dev/st0设备文件名或其他一般文件名等</span><br><span class="line">    -I ：从/var/lib/xfsdump/inventory列出目前备份的信息状态</span><br><span class="line"></span><br><span class="line">df -h /boot</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sda2       950M  218M  733M   23% /boot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将完整备份的文件名记录成为 /srv/boot.dump</span><br><span class="line">xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot</span><br><span class="line"></span><br><span class="line">xfsdump: using file dump (drive_simple) strategy</span><br><span class="line">xfsdump: version 3.1.7 (dump format 3.0) - type ^C for status and control</span><br><span class="line">xfsdump: level 0 dump of eleven:/boot</span><br><span class="line">xfsdump: dump date: Mon Mar  4 22:43:09 2024</span><br><span class="line">xfsdump: session id: 22886474-04ae-4136-a4f0-3b0d48d72f86</span><br><span class="line">xfsdump: session label: "boot_all"</span><br><span class="line">xfsdump: ino map phase 1: constructing initial dump list</span><br><span class="line">xfsdump: ino map phase 2: skipping (no pruning necessary)</span><br><span class="line">xfsdump: ino map phase 3: skipping (only one dump stream)</span><br><span class="line">xfsdump: ino map construction complete</span><br><span class="line">xfsdump: estimated dump size: 193739648 bytes</span><br><span class="line">xfsdump: /var/lib/xfsdump/inventory created</span><br><span class="line">xfsdump: creating dump session media file 0 (media 0, file 0)</span><br><span class="line">xfsdump: dumping ino map</span><br><span class="line">xfsdump: dumping directories</span><br><span class="line">xfsdump: dumping non-directory files</span><br><span class="line">xfsdump: ending media file</span><br><span class="line">xfsdump: media file size 193761840 bytes</span><br><span class="line">xfsdump: dump size (non-dir files) : 193725016 bytes</span><br><span class="line">xfsdump: dump complete: 0 seconds elapsed</span><br><span class="line">xfsdump: Dump Summary:</span><br><span class="line">xfsdump:   stream 0 /srv/boot.dump OK (success)</span><br><span class="line">xfsdump: Dump Status: SUCCESS</span><br><span class="line"></span><br><span class="line">ll -ah /srv/boot.dump</span><br><span class="line">-rw-r--r-- 1 root root 185M 3月   4 22:43 /srv/boot.dump</span><br><span class="line"></span><br><span class="line">ll /var/lib/xfsdump/inventory</span><br><span class="line">-rw-r--r-- 1 root root 5080 3月   4 22:43 3fe44238-ca6a-4d2b-8e38-86a6ada24006.StObj</span><br><span class="line">-rw-r--r-- 1 root root  312 3月   4 22:43 f0dda9b9-4595-4c0a-b084-b7c87808f83c.InvIndex</span><br><span class="line">-rw-r--r-- 1 root root  576 3月   4 22:43 fstab</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看备份信息</span><br><span class="line">xfsdump -I</span><br><span class="line"></span><br><span class="line">file system 0:</span><br><span class="line">        fs id:          f0dda9b9-4595-4c0a-b084-b7c87808f83c</span><br><span class="line">        session 0:</span><br><span class="line">                mount point:    eleven:/boot</span><br><span class="line">                device:         eleven:/dev/sda2</span><br><span class="line">                time:           Mon Mar  4 22:43:09 2024</span><br><span class="line">                session label:  "boot_all"</span><br><span class="line">                session id:     22886474-04ae-4136-a4f0-3b0d48d72f86</span><br><span class="line">                level:          0</span><br><span class="line">                resumed:        NO</span><br><span class="line">                subtree:        NO</span><br><span class="line">                streams:        1</span><br><span class="line">                stream 0:</span><br><span class="line">                        pathname:       /srv/boot.dump</span><br><span class="line">                        start:          ino 68 offset 0</span><br><span class="line">                        end:            ino 1055490 offset 0</span><br><span class="line">                        interrupted:    NO</span><br><span class="line">                        media files:    1</span><br><span class="line">                        media file 0:</span><br><span class="line">                                mfile index:    0</span><br><span class="line">                                mfile type:     data</span><br><span class="line">                                mfile size:     193761840</span><br><span class="line">                                mfile start:    ino 68 offset 0</span><br><span class="line">                                mfile end:      ino 1055490 offset 0</span><br><span class="line">                                media label:    "boot_all"</span><br><span class="line">                                media id:       22675a7b-a249-4263-b0b5-7b4aa97c5f86</span><br><span class="line">xfsdump: Dump Status: SUCCESS</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 建立一个大约10MB的文件在/boot内</span><br><span class="line">dd if=/dev/zero of=/boot/testing.img bs=1M count=10</span><br><span class="line"><span class="meta">#</span> 建立差异备份档，此时使用level 1 </span><br><span class="line">xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot</span><br><span class="line"></span><br><span class="line">ll /srv/boot*</span><br><span class="line">xfsdump -I</span><br></pre></td></tr></table></figure><p>使用<strong><code>xfsrestore</code></strong>来复原<strong><code>xfsdump</code></strong>指令生成的备份，<strong><code>xfsdump</code></strong>与<strong><code>xfsrestore</code></strong>都会到<strong><code>/var/lib/xfsdump/inventory/</code></strong>里面去查询数据来显示，因此两者输出是相同的；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 察看备份文件信息</span><br><span class="line">xfsrestore -I</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单一文件全系统复原</span><br><span class="line">xfsrestore [-f 备份档] [-L S_label] [-s] 待复原目录</span><br><span class="line"><span class="meta">#</span> 通过累积备份文件来复原系统</span><br><span class="line">xfsrestore [-f 备份文件] -r 待复原目录</span><br><span class="line"><span class="meta">#</span> 进入互动模式</span><br><span class="line">xfsrestore [-f 备份文件] -i 待复原目录</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">    -I：跟xfsdump相同的输出！可查询备份数据，包括Label名称与备份时间等</span><br><span class="line">    -f：后面接的就是备份档！企业界很有可能会接/dev/st0等磁带机！我们这里接档名！</span><br><span class="line">    -L：就是Session的Label name喔！可用-I查询到的数据，在这个选项后输入！</span><br><span class="line">    -s：需要接某特定目录，亦即仅复原某一个文件或目录之意！</span><br><span class="line">    -r：若用文件来储存备份数据就不需要使用。若一个磁带内有多个文件，需要该参数来达成累积复原</span><br><span class="line">    -i：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！</span><br><span class="line">    </span><br><span class="line">xfsrestore -f /srv/boot.dump -L boot_all /boot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将备份资料在 /tmp/boot 底下解开</span><br><span class="line">mkdir /tmp/boot</span><br><span class="line">xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot</span><br><span class="line"></span><br><span class="line">du -sm /boot /tmp/boot</span><br><span class="line">207     /boot</span><br><span class="line">185     /tmp/boot</span><br><span class="line"><span class="meta">#</span> diff -r 可以比较两个目录内的文件差异</span><br><span class="line">diff -r /boot /tmp/boot</span><br><span class="line">只在 /boot 存在：testing.img</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 通过-s参数，仅复原备份档内的grub2到/tmp/boot2/里头去</span><br><span class="line">mkdir /tmp/boot2</span><br><span class="line">xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 继续复原 level 1 到 /tmp/boot当中</span><br><span class="line">xfsrestore -f /srv/boot.dump1 /tmp/boot</span><br></pre></td></tr></table></figure><p>若根本<strong>不知道备份档里面有啥文件</strong>，或<strong>要复原的文件数量太多</strong>时，比较好的方式是使用<strong><code>-i</code></strong>的<strong>互动界面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/boot3</span><br><span class="line">xfsrestore -f /srv/boot.dump -i /tmp/boot3</span><br><span class="line"></span><br><span class="line">xfsrestore: using file dump (drive_simple) strategy</span><br><span class="line">xfsrestore: version 3.1.7 (dump format 3.0) - type ^C for status and control</span><br><span class="line">xfsrestore: searching media for dump</span><br><span class="line">xfsrestore: examining media file 0</span><br><span class="line">xfsrestore: dump description: </span><br><span class="line">xfsrestore: hostname: eleven</span><br><span class="line">xfsrestore: mount point: /boot</span><br><span class="line">xfsrestore: volume: /dev/sda2</span><br><span class="line">xfsrestore: session time: Mon Mar  4 22:43:09 2024</span><br><span class="line">xfsrestore: level: 0</span><br><span class="line">xfsrestore: session label: "boot_all"</span><br><span class="line">xfsrestore: media label: "boot_all"</span><br><span class="line">xfsrestore: file system id: f0dda9b9-4595-4c0a-b084-b7c87808f83c</span><br><span class="line">xfsrestore: session id: 22886474-04ae-4136-a4f0-3b0d48d72f86</span><br><span class="line">xfsrestore: media id: 22675a7b-a249-4263-b0b5-7b4aa97c5f86</span><br><span class="line">xfsrestore: using online session inventory</span><br><span class="line">xfsrestore: searching media for directory dump</span><br><span class="line">xfsrestore: reading directories</span><br><span class="line">xfsrestore: 4 directories and 21 entries processed</span><br><span class="line">xfsrestore: directory post-processing</span><br><span class="line"> ========================== subtree selection dialog ==========================</span><br><span class="line">the following commands are available:</span><br><span class="line">        pwd </span><br><span class="line">        ls [ &lt;path&gt; ]</span><br><span class="line">        cd [ &lt;path&gt; ]</span><br><span class="line">        add [ &lt;path&gt; ]# 可以加入复原文件列表中</span><br><span class="line">        delete [ &lt;path&gt; ]# 从复原列表拿掉档名！并非删除喔</span><br><span class="line">        extract # 开始复原动作！</span><br><span class="line">        quit </span><br><span class="line">        help </span><br><span class="line"><span class="meta"> -&gt;</span> ls</span><br><span class="line">              83 initramfs-3.10.0-1160.53.1.el7.x86_64kdump.img </span><br><span class="line">              73 initramfs-3.10.0-1160.el7.x86_64.img </span><br><span class="line">              82 initramfs-3.10.0-1160.53.1.el7.x86_64.img </span><br><span class="line">              76 initramfs-3.10.0-1160.el7.x86_64kdump.img </span><br><span class="line">              81 vmlinuz-3.10.0-1160.53.1.el7.x86_64 </span><br><span class="line">              80 symvers-3.10.0-1160.53.1.el7.x86_64.gz </span><br><span class="line">              79 config-3.10.0-1160.53.1.el7.x86_64 </span><br><span class="line">              78 System.map-3.10.0-1160.53.1.el7.x86_64 </span><br><span class="line">              77 .vmlinuz-3.10.0-1160.53.1.el7.x86_64.hmac </span><br><span class="line">              75 vmlinuz-0-rescue-3eba91ec1d4f446282dd9fa9353f0f79 </span><br><span class="line">              74 initramfs-0-rescue-3eba91ec1d4f446282dd9fa9353f0f79.img </span><br><span class="line">              72 vmlinuz-3.10.0-1160.el7.x86_64 </span><br><span class="line">              71 symvers-3.10.0-1160.el7.x86_64.gz </span><br><span class="line">              70 config-3.10.0-1160.el7.x86_64 </span><br><span class="line">              69 System.map-3.10.0-1160.el7.x86_64 </span><br><span class="line">              68 .vmlinuz-3.10.0-1160.el7.x86_64.hmac </span><br><span class="line">         1055488 grub/</span><br><span class="line">          524352 grub2/</span><br><span class="line">              67 efi/</span><br><span class="line"><span class="meta"> -&gt;</span> add grub</span><br><span class="line"><span class="meta"> -&gt;</span> add grub2</span><br><span class="line"><span class="meta"> -&gt;</span> extract</span><br><span class="line"> --------------------------------- end dialog ---------------------------------</span><br><span class="line">xfsrestore: restoring non-directory files</span><br><span class="line">xfsrestore: restore complete: 74 seconds elapsed</span><br><span class="line">xfsrestore: Restore Summary:</span><br><span class="line">xfsrestore:   stream 0 /srv/boot.dump OK (success)</span><br><span class="line">xfsrestore: Restore Status: SUCCESS</span><br><span class="line"></span><br><span class="line">ls -l /tmp/boot3</span><br><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x. 2 root root 27 1月  24 2022 grub</span><br><span class="line">drwx------. 2 root root 21 2月  10 2022 grub2</span><br></pre></td></tr></table></figure><h3 id="mkisofs创建镜像文件"><a href="#mkisofs创建镜像文件" class="headerlink" title="mkisofs创建镜像文件"></a>mkisofs创建镜像文件</h3><p>一般预设的情况下，所有要被加到镜像文档中的文件都会被放置到镜像文件中的根目录，可能会造成刻录后的文件分类不易的情况，可使用<strong><code>-graft-point</code></strong>选项来<strong>定义位于映像文件中的目录</strong>；即<strong>映像文件中的目录所在</strong>=<strong>实际Linux文件系统的目录所在</strong>；例：<strong><code>-graft-point /movies/=/srv/movies/</code></strong>表示在Linux的<strong><code>/srv/movies</code></strong>内的文件，加至映像文件中的<strong><code>/movies/</code></strong>目录；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mkisofs [-o 映像档] [-Jrv] [-V vol] [-m file] 待备份文件 -graft-point isodir=systemdir</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">    -o：后面接想要产生的镜像文件的文件名</span><br><span class="line">    -J：产生较兼容于windows机器的文件名结构，可增加文件名长度到64个unicode字符</span><br><span class="line">    -r：透过Rock Ridge产生支持Unix/Linux的文件数据，可记录较多的信息(如UID/GID等) ；</span><br><span class="line">    -v：显示创建ISO文件的过程</span><br><span class="line">    -V vol：建立Volume，有点像Windows在文件资源管理器中看到的CD title的东西</span><br><span class="line">    -m file：-m为排除文件 (exclude) 的意思，后面的文件不备份到映像档中，也能使用*通配符</span><br><span class="line">    -graft-point：graft有转嫁或移植的意思，定义位于映像文件中的目录</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 将/root, /home, /etc等目录内的数据通通刻录起来</span><br><span class="line">mkisofs -r -v -o /tmp/system.img /root /home/ /etc/</span><br><span class="line"></span><br><span class="line">ll -h /tmp/system.img</span><br><span class="line">-rw-r--r-- 1 root root 235M 3月   5 20:34 /tmp/system.img</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将镜像文件挂载到/mnt目录</span><br><span class="line">mount -o loop /tmp/system.img /mnt</span><br><span class="line">df -h /mnt</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/loop1      235M  235M     0  100% /mnt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看镜像文件内容，可以看到并没有将文件归类到目录中，或保持原始目录</span><br><span class="line">ls /mnt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 卸载挂载</span><br><span class="line">umount /mnt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 刻录镜像文件，且设置打包目录映射，再通过上面的挂载命令查询内容</span><br><span class="line">mkisofs -r -V 'linux_file' -o /tmp/system.img -m /root/etc -graft-point /root=/root /home=/home /etc=/etc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看镜像文件信息</span><br><span class="line">isoinfo -d -i /home/CentOS-7-x86_64-Minimal-1503-01.iso</span><br><span class="line">mount /home/CentOS-7-x86_64-Minimal-1503-01.iso /mnt</span><br><span class="line">mkdir /srv/newcd</span><br><span class="line"><span class="meta">#</span> 完整的复制所有的权限属性等数据，也能够进行镜像处理</span><br><span class="line">rsync -a /mnt/ /srv/newcd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 制作可开机一键安装的镜像文件custom.iso</span><br><span class="line">mkisofs -o /custom.iso -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -V 'CentOS 7 x86_64' -boot-load-size 4 -boot-info-table -R -J -v -T .</span><br></pre></td></tr></table></figure><p>新版的CentOS 7使用的是<strong><code>wodim</code></strong>文字界面指令来进行刻录的行为，为了兼容于旧版的cdrecord指令，wodim也有连结到cdrecord指令，因此还是可以使用cdrecord指令；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查询刻录机的 BUS 位置</span><br><span class="line">wodim --devices dev=/dev/sr0...  </span><br><span class="line"><span class="meta">#</span> 抹除重复读写片</span><br><span class="line">wodim -v dev=/dev/sr0 blank=[fast|all]</span><br><span class="line"><span class="meta">#</span> 格式化 DVD+RW</span><br><span class="line">wodim -v dev=/dev/sr0 -format</span><br><span class="line">wodim -v dev=/dev/sr0 [可用选项功能] file.iso</span><br><span class="line">选项与参数：</span><br><span class="line">    --devices：用在扫瞄磁盘总线并找出可用的刻录机，后续的装置为ATA接口</span><br><span class="line">    -v：在cdrecord运作的过程中显示过程</span><br><span class="line">    dev=/dev/sr0：可找出此光驱的bus地址，非常重要</span><br><span class="line">    blank=[fast|all]：blank为抹除可重复写入的CD/DVD-RW，使用fast较快all较完整</span><br><span class="line">    -format：对光盘片进行格式化，但仅针对DVD+RW这种格式的DVD，</span><br><span class="line">可用选项功能主要是写入CD/DVD时可使用的选项，常见的选项包括有：</span><br><span class="line">    -data：指定后面的文件以数据格式写入，不是以CD音轨(-audio)方式写入</span><br><span class="line">    speed=X：指定刻录速度，例如CD可用speed=40为40倍数，DVD则可用speed=4之类</span><br><span class="line">    -eject：指定刻录完毕后自动退出光盘</span><br><span class="line">    fs=Ym：指定多少缓冲存储器，可用在将映像档先暂存至缓冲存储器。预设为4m，一般建议8m，视刻录机而定</span><br><span class="line">针对DVD的选项功能：</span><br><span class="line">    driveropts=burnfree：打开Buffer Underrun Free模式的写入功能</span><br><span class="line">    -sao：支持DVD-RW的格式</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 查找光驱，光驱的文件名为/dev/sr0之类</span><br><span class="line">wodim --devices dev=/dev/sr0</span><br><span class="line"><span class="meta">#</span> 抹除光盘的原始内容</span><br><span class="line">wodim -v dev=/dev/sr0 blank=fast</span><br><span class="line"><span class="meta">#</span> 将/tmp/system.img刻录到CD/DVD</span><br><span class="line">wodim -v dev=/dev/sr0 speed=4 -dummy -eject /tmp/system.img</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 刻录完毕后，测试挂载一下，检验内容</span><br><span class="line">mount /dev/sr0/mnt</span><br></pre></td></tr></table></figure><h3 id="常见压缩备份工具"><a href="#常见压缩备份工具" class="headerlink" title="常见压缩备份工具"></a>常见压缩备份工具</h3><h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p><strong><code>dd</code></strong>指令<strong>不仅可以制作一个文件</strong>，<strong><code>dd</code>指令最大的作用是备份</strong>，dd指令可以<strong>读取磁盘装置的内容</strong>，<strong>几乎是直接读取扇区</strong>，然后将整个装置备份成一个文件；<strong>默认<code>dd</code>是一个一个扇区去读/写的</strong>，且即使<strong>没有用到的扇区也会被写入备份中</strong>，因此该文件会跟原本的磁盘一样大，不像使用<strong><code>xfsdump</code></strong>只备份文件系统中有使用到的部份；<strong>dd不区分文件系统，不论该磁盘内的文件系统是否认识都可以备份还原</strong>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dd if="input_file" of="output_file" bs="block_size" count="number</span><br><span class="line">选项与参数：</span><br><span class="line">    if：就是input file也可以是装置</span><br><span class="line">    of：就是output file也可以是装置</span><br><span class="line">    bs：规划的一个block的大小，若未指定则预设是512 bytes(一个sector的大小)</span><br><span class="line">    count：多少个bs，通过bs*count算出文件大小</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 将/etc/passwd备份到/tmp/passwd.back当中</span><br><span class="line"><span class="meta">#</span> 没有设定bs默认是512 bytes为一个单位，4+1表示有4个完整的512 bytes</span><br><span class="line"><span class="meta">#</span> 以及未满512 bytes的另一个block</span><br><span class="line">dd if=/etc/passwd of=/tmp/passwd.back</span><br><span class="line">记录了4+1 的读入</span><br><span class="line">记录了4+1 的写出</span><br><span class="line">2449字节(2.4 kB)已复制，0.000588542 秒，4.2 MB/秒</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> </span><br><span class="line">ll /etc/passwd /tmp/passwd.back</span><br><span class="line">-rw-r--r-- 1 root root 2449 7月  31 2022 /etc/passwd</span><br><span class="line">-rw-r--r-- 1 root root 2449 3月   5 21:44 /tmp/passwd.back</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将刻录的光驱的内容，再次的备份下来成为镜像文件，要将数据抓下来可以用这个方法</span><br><span class="line">dd if=/dev/sr0 of=/tmp/system.iso</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将映像文件写入USB磁盘，若USB是/dev/sda</span><br><span class="line">lsblk /dev/sda</span><br><span class="line">dd if=/tmp/system.iso of=/dev/sda</span><br><span class="line"></span><br><span class="line">mount /dev/sda /mnt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将/boot整个文件系统透过dd备份下来</span><br><span class="line">df -h /boot</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sda2       950M  228M  723M   24% /boot</span><br><span class="line"></span><br><span class="line">dd if=/dev/sda2 of=/tmp/sda2.img</span><br><span class="line">ll -h /tmp/vda2.img</span><br></pre></td></tr></table></figure><h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><p><strong><code>cpio</code>指令可备份任何东西，包括设备文件</strong>，但cpio指令<strong>不会主动的去找文件来备份</strong>，cpio指令<strong>需要类似find等可以找到文件名的指令</strong>来告知cpio需要被<strong>备份的数据的文件路径</strong>；<strong><code>cpio</code>可备份任何的文件</strong>，包括<strong><code>/dev</code></strong>底下的<strong>任何设备文件</strong>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 备份</span><br><span class="line">cpio -ovcB &gt; [file|device]</span><br><span class="line"><span class="meta">#</span> 还原</span><br><span class="line">cpio -ivcdu &lt; [file|device]</span><br><span class="line"><span class="meta">#</span> 查看</span><br><span class="line">cpio -ivct &lt; [file|device]</span><br><span class="line">备份会使用到的选项与参数：</span><br><span class="line">    -o：将数据copy输出到文件或装置上</span><br><span class="line">    -B：让预设的Blocks可以增加至5120 bytes，预设是512 bytes，好处是可让大文件的储存速度加快</span><br><span class="line">还原会使用到的选项与参数：</span><br><span class="line">    -i：将数据自文件或装置copy出来系统当中</span><br><span class="line">    -d：自动建立目录！使用cpio所备份的数据内容不见得会在同一层目录中，必须要让cpio在还原时可建立新目录</span><br><span class="line">    -u：自动的将较新的文件覆盖较旧的文件</span><br><span class="line">    -t：需配合-i选项，可用在查看以cpio建立的文件或装置的内容</span><br><span class="line">可共享的选项与参数：</span><br><span class="line">    -v：让储存的过程中文件名可以在屏幕上显示</span><br><span class="line">    -c：一种较新的portable format方式储存</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 找出/boot底下的所有文件，然后将他备份到/tmp/boot.cpio</span><br><span class="line">cd /</span><br><span class="line">find boot | cpio -ocvB &gt; /tmp/boot.cpio</span><br><span class="line">ll -h /tmp/boot.cpio</span><br><span class="line">-rw-r--r-- 1 root root 207M 3月   5 22:07 boot.cpio</span><br><span class="line"></span><br><span class="line">file /tmp/boot.cpio</span><br><span class="line">/tmp/boot.cpio: ASCII cpio archive (SVR4 with no CRC)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将的文件解开</span><br><span class="line">cpio -idvc &lt; /tmp/boot.cpio</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> cpio可以将系统的数据完整的备份到磁带机</span><br><span class="line">find / | cpio -ocvB &gt; /dev/st0# 备份</span><br><span class="line">cpio -idvc &lt; /dev/st0#还原</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 系统里面已经含有一个使用cpio建立的文件，即/boot/initramfs-xxx这个文件</span><br><span class="line"><span class="meta">#</span> 查看文件格式</span><br><span class="line">file /boot/initramfs-3.10.0-1160.el7.x86_64.img</span><br><span class="line">/boot/initramfs-3.10.0-1160.el7.x86_64.img: ASCII cpio archive (SVR4 with no CRC)</span><br><span class="line"></span><br><span class="line">mkdir /tmp/initramfs</span><br><span class="line">cd /tmp/initramfs</span><br><span class="line"></span><br><span class="line">cpio -idvc &lt; /boot/initramfs-3.10.0-1160.el7.x86_64.img</span><br><span class="line">.</span><br><span class="line">kernel</span><br><span class="line">kernel/x86</span><br><span class="line">kernel/x86/microcode</span><br><span class="line">kernel/x86/microcode/GenuineIntel.bin</span><br><span class="line">early_cpio</span><br><span class="line">48 块</span><br></pre></td></tr></table></figure><p>注意上面的的命令中，先转换目录到/再去找boot，<strong><code>cpio</code></strong>很笨它不会理会给的是<strong>绝对路径</strong>还是<strong>相对路径</strong>的文件名，若<strong>加上绝对路径</strong>的<strong><code>/</code></strong>开头，未来<strong>解开时会覆盖掉原本的<code>/boot</code></strong>；类似<strong><code>tar</code></strong>的<strong><code>-P</code></strong>选项；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机最小单位是bits，&lt;strong&gt;&lt;code&gt;1byte=8bits&lt;/code&gt;&lt;/strong&gt;这就是所谓的二进制，如&lt;strong&gt;数字1&lt;/strong&gt;用二进制表示为&lt;strong&gt;&lt;code&gt;00000001&lt;/code&gt;&lt;/strong&gt;，其实数字1只
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/Linux/"/>
    
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux非常用命令</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/Linux/Linux%E9%9D%9E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/Linux/Linux非常用命令/</id>
    <published>2023-11-27T16:00:00.000Z</published>
    <updated>2023-11-28T14:23:08.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重要热键"><a href="#重要热键" class="headerlink" title="重要热键"></a>重要热键</h3><h5 id="Tab键"><a href="#Tab键" class="headerlink" title="Tab键"></a>Tab键</h5><p>具有<strong>命令补全</strong>和<strong>文件名补齐</strong>功能，即Tab键<strong>接在一串命令的第一个命令后</strong>，则为<strong>命令补全</strong>；Tab键接在<strong>一串命令的第二个命令以后</strong>，则为<strong>文件名补齐</strong>；</p><h5 id="Ctrl-C"><a href="#Ctrl-C" class="headerlink" title="Ctrl + C"></a>Ctrl + C</h5><p>作用是中断目前程序；</p><h5 id="Ctrl-D"><a href="#Ctrl-D" class="headerlink" title="Ctrl + D"></a>Ctrl + D</h5><p>表示<strong>键盘输入结束</strong>，也<strong>可用来替代<code>exit</code>的输入</strong>；</p><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 当前系统时间</span><br><span class="line">date</span><br><span class="line"><span class="meta">#</span> 当前系统时间：按yyyy-MM-dd格式显示</span><br><span class="line">date +%Y-%m-%d</span><br><span class="line"><span class="meta">#</span> 小时分钟</span><br><span class="line">date +%H:%M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当前月历</span><br><span class="line">cal</span><br><span class="line"><span class="meta">#</span> 年历</span><br><span class="line">cal 2023</span><br><span class="line"><span class="meta">#</span> 某年某月历</span><br><span class="line">cal 11 2023</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打开计算器，默认是整数，可通过scale设置小数位数</span><br><span class="line">bc</span><br></pre></td></tr></table></figure><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>进入man指令的功能后，可按下<strong>空格键</strong>往下翻页，可按下<strong>q按键</strong>来离开man的环境，man page页第一行<strong><code>DATE(1)</code></strong>  ，<strong><code>DATE</code></strong>指命令名称，括号中数字<strong><code>1</code></strong>的含义如下表所示，表中的<strong>1, 5, 8</strong>这三个号码特别重要；</p><p><img src="../../../../../images/Linux/ManPage页面.png" alt="ManPage页面"></p><table><thead><tr><th>代号</th><th>代表内容</th></tr></thead><tbody><tr><td>1</td><td>用户在 shell 环境中可以操作的指令或可执行文件</td></tr><tr><td>2</td><td>系统核心可呼叫的函数与工具等</td></tr><tr><td>3</td><td>一些常用的函数(function)与函式库(library)，大部分为 C 的函式库(libc)</td></tr><tr><td>4</td><td>装置文件的说明，通常在/dev 下的文件</td></tr><tr><td>5</td><td>配置文件或者是某些文件的格式</td></tr><tr><td>6</td><td>游戏(games)</td></tr><tr><td>7</td><td>惯例与协议等，例如 Linux 文件系统、网络协议、ASCII code 等等的说明</td></tr><tr><td>8</td><td>系统管理员可用的管理指令</td></tr><tr><td>9</td><td>跟 kernel 有关的文件</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 精确匹配命令</span><br><span class="line">man -f date</span><br><span class="line">whatis date</span><br><span class="line"><span class="meta">#</span> 模糊匹配命令</span><br><span class="line">man -k date</span><br><span class="line">aprops date</span><br></pre></td></tr></table></figure><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看当前谁在线</span><br><span class="line">who</span><br><span class="line"><span class="meta">#</span> 查看网络联机状态</span><br><span class="line">netstat -a</span><br><span class="line"><span class="meta">#</span> 查看后台进程</span><br><span class="line">ps -aux</span><br><span class="line"><span class="meta">#</span> 正确的关机指令使用</span><br><span class="line">shutdown</span><br><span class="line">reboot</span><br><span class="line"><span class="meta">#</span> 将数据同步写入硬盘</span><br><span class="line">sync</span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">reboot</span><br><span class="line">halt</span><br><span class="line">poweroff</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> shutdown可自由选择关机模式，关机、重启、进入单用户操作模式</span><br><span class="line"><span class="meta">#</span> 设置关机时间</span><br><span class="line"><span class="meta">#</span> 自定义关机消息</span><br></pre></td></tr></table></figure><h3 id="系统执行等级"><a href="#系统执行等级" class="headerlink" title="系统执行等级"></a>系统执行等级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 关机</span><br><span class="line">run level 0</span><br><span class="line"><span class="meta">#</span> 纯命令行模式</span><br><span class="line">run level 3</span><br><span class="line"><span class="meta">#</span> 含有图形界面模式</span><br><span class="line">run level 5</span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">run level 6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可通过init命令切换运行等级</span><br><span class="line"><span class="meta">#</span> 关机</span><br><span class="line">init 0</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong><code>fsck</code></strong>命令用于<strong>文件系统检查</strong>，当文件系统发生错误时可用该命令修复，如<strong><code>fsck /dev/sda7</code></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;重要热键&quot;&gt;&lt;a href=&quot;#重要热键&quot; class=&quot;headerlink&quot; title=&quot;重要热键&quot;&gt;&lt;/a&gt;重要热键&lt;/h3&gt;&lt;h5 id=&quot;Tab键&quot;&gt;&lt;a href=&quot;#Tab键&quot; class=&quot;headerlink&quot; title=&quot;Tab键&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/Linux/"/>
    
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>装修笔记</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/%E8%A3%85%E4%BF%AE%E7%AC%94%E8%AE%B0/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/装修笔记/</id>
    <published>2023-02-20T16:00:00.000Z</published>
    <updated>2023-11-07T14:34:56.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="家电-amp-品牌"><a href="#家电-amp-品牌" class="headerlink" title="家电&amp;品牌"></a>家电&amp;品牌</h3><ul><li>冰箱：荣升BCD-506WKK1FPGZA-GQ51<ul><li>双十一价格：10959</li></ul></li><li>浴霸：奥普Q360A PRO（2个）<ul><li>双十一价格：3643</li></ul></li><li>前置过滤器：惠尔顿p0063plus<ul><li>双十一价格：959</li></ul></li><li>热水器：海尔KN5<ul><li>双十一价格：3219</li></ul></li><li>洗烘套装：小天鹅V88+H36<ul><li>双十一价格：<ul><li>H36：2899</li><li>V88：3059</li></ul></li><li>赖老板：5199</li></ul></li><li>燃气灶：老板JZT-9B1K11<ul><li>双十一价格：3159</li></ul></li><li>油烟机：方太EMQ6T<ul><li>双十一价格：2859</li></ul></li><li>马桶：瑞尔特UX6或GX6P<ul><li>双十一价格：</li></ul></li><li>蒸烤一体机：凯度ZD Pro二代<ul><li>双十一价格：5329</li></ul></li><li>扫地机器人：云鲸j4<ul><li>双十一价格：</li></ul></li></ul><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ul><li><p>个人喜好说明</p><ul><li>注重<strong>方便实用</strong>&amp;<strong>舒适性</strong></li><li>很居家：<strong>做饭比较多</strong></li><li>不喜欢乱糟糟：尽可能多做一点收纳</li><li>有养绿植的爱好：阳台尽可能能养一点绿植</li><li><strong>隐蔽工程</strong>&amp;<strong>水电</strong>：<strong>一定</strong>、<strong>一定</strong>、<strong>一定</strong>要做好</li></ul></li><li><p>水电</p><ul><li>水管全换</li><li>电线：需评估目前开发商的质量如何<ul><li>质量不行：电线也全部换掉</li></ul></li><li>插座一定要留够（这里只是列举了一些可能考虑不到的）<ul><li>入户门里外尽量留插座：后期安装监控</li><li>客厅和主卧室（顶上预留插座）：电动窗帘</li><li>智能马桶插座</li><li>扫地机器人（上下水&amp;插座）</li><li>厨房水槽下方至少三个插座：垃圾处理器、前置过滤器、净水器、洗碗机（考虑）</li><li>电视柜多留</li><li>客厅&amp;餐厅：留地插（吃火锅、沙发上充电之类的）</li></ul></li><li>要做前置过滤</li><li>要做净水器 + 管线机（初步想法放在餐边柜）</li><li>热水器，要做回水循环（零冷水）：<ul><li>要安装回水管</li><li>可能需要预留冷凝结管</li><li>进水、回水、燃气、等位置考虑放在热水器旁边；方便隐藏；防止后期吊柜需要做很长</li></ul></li><li>网络：<ul><li>每个房间要光纤 + 六类网线</li><li>弱电箱：可能需要放<strong>交换机</strong>、<strong>路由器</strong>、<strong>光猫</strong>（预留足够的插座）</li></ul></li></ul></li><li>改&amp;建<ul><li>封阳台</li><li>生活阳台&amp;客厅阳台连接处搭建，墙要去除一部分到连接处</li><li>冰箱位置（待定）</li><li>做餐边柜</li><li><strong>所有飘窗</strong>要打掉，可能涉及一些墙也需要打掉</li><li>厨房阳台门封掉</li><li>进门处：由于不够做鞋柜的宽度，需要<strong>移墙</strong></li><li>电视墙：需要加固，预留50管</li></ul></li><li>全屋智能包含<ul><li>灯</li><li>窗帘</li><li>空调</li><li>后期厨房&amp;厕所：会做一些感应开关灯</li></ul></li><li>其他说明<ul><li>主卧要做一个衣帽间：<strong>是否隐形门待定</strong></li><li>中央空调 + 地暖（锅炉位置待定）</li><li>厕所：墙排</li><li>地板：全屋通铺（地板尺寸待定<strong>亚光75 X 150</strong>）</li><li>厨房：要安装冷风机</li><li>尽量做一些<strong>极简风</strong>：如卧室门、卫生间门等</li><li>无主灯<ul><li>客厅</li><li>主卧室（）考虑</li></ul></li><li>门做到顶</li><li>有一个多功能房间：可能需要在墙上埋支架底座</li></ul></li></ul><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><h5 id="确定预算"><a href="#确定预算" class="headerlink" title="确定预算"></a>确定预算</h5><p>预算 = 设计费 + 人工费 + 材料费(主材和辅材) + 家具软装 + 家电设备 + 备用金</p><h5 id="确认风格"><a href="#确认风格" class="headerlink" title="确认风格"></a>确认风格</h5><p>现代风、轻奢风、法式风等</p><h5 id="选择装修方式"><a href="#选择装修方式" class="headerlink" title="选择装修方式"></a>选择装修方式</h5><p><strong>清包：</strong>省钱但特别耗费精力，业主购买所有的装修材料，装修公司或施工队只负责装修</p><p><strong>半包：</strong>业主购买门窗、瓷砖等主要材料，装修公司负责提供沙子、水泥等辅材以及人工</p><p><strong>全包</strong>：省时、省力、省心、省钱；适合<strong>预算足但没时间精力</strong>的业主，设计、主材、辅材、施工全部由装修公司解决，业主只需要监督工程进度，但是<strong>务必要让装修公司标明主材材料</strong>；</p><h5 id="量房"><a href="#量房" class="headerlink" title="量房"></a>量房</h5><p>对工地进行现场勘测，并进行综合的考察，以便更加科学、合理精准地进行家装设计</p><h5 id="选择装修公司"><a href="#选择装修公司" class="headerlink" title="选择装修公司"></a>选择装修公司</h5><ul><li>营业执照、荣誉等</li><li>看名气口碑案例</li><li>看设计图纸和预算表</li><li>到公司实地考察实力</li></ul><h5 id="签订装修合同"><a href="#签订装修合同" class="headerlink" title="签订装修合同"></a>签订装修合同</h5><p>合同要<strong>附图样</strong>与<strong>报价单</strong>，需要<strong>核对装修材料</strong>、<strong>工期</strong>问题、<strong>保修条款</strong>等</p><h5 id="物业办理装修手续"><a href="#物业办理装修手续" class="headerlink" title="物业办理装修手续"></a>物业办理装修手续</h5><p>开工前需要和新房小区的物业做备案，<strong>办理开工许可证</strong>、<strong>工人出入证明</strong>、<strong>缴纳装修保证金</strong>等</p><h3 id="硬装阶段"><a href="#硬装阶段" class="headerlink" title="硬装阶段"></a>硬装阶段</h3><p>木、瓦、油施工时要按照<strong>谁脏谁先上</strong>的原则，而且还应遵循<strong>从上往下的施工方式</strong>，这样才能保持室内的清洁，不用反复清洁居室</p><h5 id="实地勘察-amp-现场交底"><a href="#实地勘察-amp-现场交底" class="headerlink" title="实地勘察&amp;现场交底"></a>实地勘察&amp;现场交底</h5><p>最好<strong>业主</strong>、<strong>设计师</strong>、<strong>工长</strong>、<strong>监理</strong>都到现场，确定需要改动的地方以及检查房屋情况</p><h5 id="主体拆改建"><a href="#主体拆改建" class="headerlink" title="主体拆改建"></a>主体拆改建</h5><p>拆墙、砌墙、铲墙皮</p><h5 id="水电改造"><a href="#水电改造" class="headerlink" title="水电改造"></a>水电改造</h5><p>首先要对所要安装橱柜的位置进行测量，而且还要预留上水口、插座的位置。水电改造是一个隐蔽工程，所以要特别注意它的每个细节，方便后续的日常生活</p><p><strong>业主</strong>：定全屋瓷砖、木地板、踢脚线、地漏、浴室柜、淋浴房、卫浴五金</p><h5 id="泥瓦工"><a href="#泥瓦工" class="headerlink" title="泥瓦工"></a>泥瓦工</h5><p>填补线槽、包立管、墙地面找平、防水、门槛石瓷砖铺贴</p><p><strong>业主</strong>：定浴霸，水槽龙头，预约全屋定制复尺</p><h5 id="木工"><a href="#木工" class="headerlink" title="木工"></a>木工</h5><p>石膏板吊顶、窗帘盒、全屋柜体、地台、门及门套窗套、墙面护墙、岛台桌子，柜体制作、门板套线制作、木基层施工</p><p><strong>业主：</strong>买灯具、全屋电器，若乳胶漆需要更换则该时期买好</p><h5 id="油漆工"><a href="#油漆工" class="headerlink" title="油漆工"></a>油漆工</h5><p>墙面、顶面、刮腻子、腻子打磨以及现场木制表面的乳胶漆和木器漆</p><p><strong>业主</strong>：购买窗帘、所有成品家具</p><h3 id="安装阶段"><a href="#安装阶段" class="headerlink" title="安装阶段"></a>安装阶段</h3><h5 id="地板"><a href="#地板" class="headerlink" title="地板"></a>地板</h5><ul><li>建议在装地板前，将这些灰渣散落多的项目</li><li>地板装前一定要做找平</li><li>地板安装之前，家里的铺装地板的地面要清扫干净，要保证地面的干燥，所以清扫过程不要用水</li><li>地板的切割一定要在走廊。在室内切割地板对墙面的污染比较严重，类似的还有橱柜的人造石台面的切割</li></ul><h5 id="墙面"><a href="#墙面" class="headerlink" title="墙面"></a>墙面</h5><p>墙纸/墙布、护墙板、踢脚线、开关插座、壁灯、暖气片、室内门/门套</p><h5 id="天花"><a href="#天花" class="headerlink" title="天花"></a>天花</h5><p>灯具、中央空调/新风风口</p><h5 id="全屋"><a href="#全屋" class="headerlink" title="全屋"></a>全屋</h5><p>定制柜体、集成吊顶、厨卫洁具和各种大小家电</p><h5 id="木门安装"><a href="#木门安装" class="headerlink" title="木门安装"></a>木门安装</h5><p>木门必须采用<strong>预留洞口</strong>的安装方法，严禁边安装边砌口的做法，须在安装洞口地面工程安装完毕后，同时在墙面腻子刮完并打磨平整后，方可进行安装作业</p><p><strong>成品门应先于地板安装</strong>，主要因为装门步骤复杂，合页、门锁、门吸、门框等等</p><h5 id="墙面修补"><a href="#墙面修补" class="headerlink" title="墙面修补"></a>墙面修补</h5><p>安装完后墙面有毁坏的进行墙面修补</p><h3 id="收尾阶段"><a href="#收尾阶段" class="headerlink" title="收尾阶段"></a>收尾阶段</h3><h5 id="开荒保洁"><a href="#开荒保洁" class="headerlink" title="开荒保洁"></a>开荒保洁</h5><p>门窗擦拭、清洁装修时不易去掉的污渍、建议找专业保洁人员，以免清洁不当损伤瓷砖、洁具或清洁不干净等</p><p>地板打蜡，蜡要自己买，但一定要用保洁的打蜡机，效率比人工快几十、上百倍</p><h5 id="家具进场"><a href="#家具进场" class="headerlink" title="家具进场"></a>家具进场</h5><p><strong>家电安装</strong>、床、床垫、衣柜、鞋柜、沙发、餐桌；家电等家具进场前应做好成品保护，<strong>最好准备一次性鞋套，地板上铺好保护膜，避免划伤瓷砖和木地板。墙面棱角也要包好防磕碰</strong></p><h5 id="通风"><a href="#通风" class="headerlink" title="通风"></a>通风</h5><h5 id="入住"><a href="#入住" class="headerlink" title="入住"></a>入住</h5><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="拆除新建"><a href="#拆除新建" class="headerlink" title="拆除新建"></a>拆除新建</h4><ul><li>拆除流程：定位→沿线切割→拆除→装袋清运→整理现场</li><li>新建流程：定位→基础梁→润砖→植筋→砌墙→封顶→挂网粉刷→清理→养护</li><li>垃圾清运需要自己找人清理，要付垃圾清运费</li></ul><h4 id="水电施工"><a href="#水电施工" class="headerlink" title="水电施工"></a>水电施工</h4><ul><li>所有家具电器的尺寸位置要提前确认好，防止遮挡开关插座</li><li>施工流程：水电交底→水电预估→材料进场→放线开槽→强弱电布管→给排水布管→强电箱整理→现场清理</li><li>开槽尽量少在墙面开横槽，水电不能同槽、强弱电不能同槽</li><li>施工完一定要测试检查好才能验收</li><li>提早在工地准备好旧毛巾(柔棉的那种，贴完砖擦砖用)、塑料袋(缠在管道接口上，可防脏物堵塞)</li></ul><h4 id="瓦工施工"><a href="#瓦工施工" class="headerlink" title="瓦工施工"></a>瓦工施工</h4><ul><li>包管道施工→墙面基层处理→涂刷墙面防水→铺贴墙砖→涂刷地面防水→闭水试验→铺贴地砖→清理保护 </li><li>瓷砖买多不买少，不同批次会有色差，且要考虑损耗率的事</li><li>瓷砖贴多少泡多少，没泡水的多的可以退</li><li>防水一定要做的三个空间是：<strong>卫生间</strong>、<strong>阳台</strong>、<strong>厨房</strong></li><li>顶楼可以不包水管，因为楼上没有邻居</li><li>厨房卫生间的易潮易湿环境，包立管的材料一定不能用木龙骨，即使木龙骨上刷防腐涂料也不行</li><li>贴砖前，要买好地漏，买专用的洗衣机或淋浴用地漏，而且要防臭功能</li></ul><h4 id="木工施工"><a href="#木工施工" class="headerlink" title="木工施工"></a>木工施工</h4><ul><li>流程：放线定位→轻钢龙骨骨架安装→石膏板饰面→柜体制作→套线、门板制作→木制基层制作→门板安装调试→清理保护</li><li>木地板不是木工活</li></ul><h4 id="油漆施工"><a href="#油漆施工" class="headerlink" title="油漆施工"></a>油漆施工</h4><ul><li>流程：墙面检验→刷界面剂→基层找平→挂网格布→批刮腻子→打磨→涂刷底漆→涂刷面漆</li><li>乳胶漆施工的时间会比较长，因为流程多，且每一遍涂刷都要等完全干透才能刷下一遍</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>确认好时间，如果安装人员跑来了因为你的原因装不了，还是会收跑空费的</li><li>插座买带开关功能的，尤其是厨房，这样电饭锅、微波炉就可免于插拔电源，用开关即可控制</li></ul><h4 id="通风入住"><a href="#通风入住" class="headerlink" title="通风入住"></a>通风入住</h4><ul><li>除甲醛最有效的方法是通风，不要做太多无谓挣扎</li><li>除甲醛最佳时期油漆完全干涸后，上午10:00-下午4:00</li><li>可以通过工业风扇吹增强空气流动，但是不能对着成品墙体、家具吹，防止被吹开裂</li><li>冬季气温过低，防止冻伤墙面，不要开窗通风</li><li>柜体是甲醛大户，通风一定要打开柜门抽屉，且可以用拧干的湿毛巾擦拭柜体表面增加挥发效果</li></ul><h3 id="选材"><a href="#选材" class="headerlink" title="选材"></a>选材</h3><h4 id="瓷砖"><a href="#瓷砖" class="headerlink" title="瓷砖"></a>瓷砖</h4><table><thead><tr><th></th><th>柔光砖</th><th>柔抛砖（柔光大理石砖）</th><th>亮光砖</th><th>亚光砖</th></tr></thead><tbody><tr><td>工艺</td><td>生产时将釉面调整到合适的光泽度，不二次抛光</td><td>大理石瓷砖上完釉面后，在表面进行二次抛光，抛光后釉面的毛细孔漏出来不耐磨容易渗油污</td><td></td><td></td></tr><tr><td>光泽度</td><td>15左右，打光是闪开的</td><td>55-60，打光能清洗可见光源形状</td><td></td><td></td></tr><tr><td>表面</td><td>可能有凹凸小点</td><td>没有凹凸小点</td><td></td><td></td></tr><tr><td>釉面</td><td>肌肤釉（最好打理）、糖果釉、缎光釉、细干粒、数码釉</td><td></td><td></td><td></td></tr><tr><td>触感</td><td>像肌肤</td><td>感觉砖上好像有油</td><td>镜面感</td><td>磨砂感</td></tr></tbody></table><ul><li>选纹理少的，光泽度在15的素色柔光，选全瓷+亚光美缝剂</li><li>浅灰色、米白色、米黄色（奶、白、灰等色系）<strong>柔光砖</strong>，千万别买成了<strong>柔抛砖</strong></li><li><strong>防滑系数</strong>在<strong>0.5</strong>以上</li><li><strong>吸水率小于5%</strong>的</li><li><strong>墙砖吸水率要在10%以上</strong>的</li><li>包不包送货上楼</li><li>退换货是否包运费</li><li>搬运中造成瓷砖损坏怎么赔偿</li><li>金属踢脚线</li></ul><table><thead><tr><th>柔光砖种类</th><th>工艺</th><th>特点</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>细干粒</td><td>在釉面上喷撒一层超细干粒</td><td>轻微颗粒感，易清洁度85%</td><td>防滑</td><td>时间久了藏污</td></tr><tr><td>干粒抛</td><td></td><td>细微凹凸感，易清洁度80%</td><td>防滑</td><td>脏东西需要刷洗</td></tr><tr><td>肌肤釉</td><td>将釉面调整到合适的光泽度，不二次抛光</td><td>平滑细腻，易清洁度95%</td><td></td><td>渗污、不防滑</td></tr><tr><td>亚光刷抛面</td><td>在釉面上喷撒一层超细干粒，再刷抛</td><td>平滑，易清洁度80%</td><td>防滑、好打理</td><td></td></tr><tr><td>缎光釉</td><td></td><td>平滑细腻，易清洁度95%</td><td>可上墙</td><td>渗色</td></tr><tr><td>糖果釉</td><td></td><td>易清洁度85%</td><td>防滑、耐磨</td><td>渗色</td></tr></tbody></table><h4 id="柜子"><a href="#柜子" class="headerlink" title="柜子"></a>柜子</h4><p>通顶衣柜背板和侧板最好做<strong>18mm</strong>的</p><p>可能单独收费项：</p><ul><li>抽屉：一般有免费送，外加收费</li><li>边线顶线：问清是否收费、收多少</li><li>见光板：要和门材质相同，单独计费</li><li>背板厚度：默认五厘米或九厘米</li><li>五金：包括哪些、不包括哪些、哪些需要额外收钱</li><li>套色：是否单独收费</li><li>局部加厚板：是否单独收费</li><li>层板：增加是否加钱、这么计费</li><li>四周封板是否单独收费</li></ul><h3 id="水电"><a href="#水电" class="headerlink" title="水电"></a>水电</h3><h4 id="电线"><a href="#电线" class="headerlink" title="电线"></a>电线</h4><ul><li>厨房单独走6平方的线：因为厨电比较多</li><li>冰箱单独走线</li><li>照明&amp;插座：2.5平方</li><li>洗手间：单独回路，4平方，浴霸排风扇等功率不低</li></ul><h4 id="零冷水"><a href="#零冷水" class="headerlink" title="零冷水"></a>零冷水</h4><ul><li>零冷水热水器（冷凝管、进水管、热水管、回水管），能APP设定时间段<ul><li>应该安装在<strong>阳台</strong>还是<strong>厨房</strong>中</li></ul></li><li>普通热水器+回水器（小厨宝）</li></ul><h4 id="开关插座"><a href="#开关插座" class="headerlink" title="开关插座"></a>开关插座</h4><ul><li>入户门上方<strong>内外</strong>预留电源线，后期安装摄像头</li><li>弱电箱预留插排，光猫、路由器，交换机</li><li>厨房顶上抽油烟机</li><li>厨房台面，多几个插座位置，电饭煲、微波炉、绞肉机（带开关的插座）</li><li>厨房水槽下方至少三个插座：垃圾处理器、净水器、洗碗机</li><li>电视柜：蓝牙音响、路由器、电视电源、外接插排</li><li>卧室：床头两边各两个，床尾两个（加湿器、空气净化器等）</li><li>阳台上：留两个（烧烤、氛围灯、擦窗机器人）</li><li>阳台家政柜里：吸尘器、洗地机</li><li>浴室柜：吹风机、电动牙刷、剃须刀</li><li>马桶旁边：智能马桶、扫地机器人（留上下水）</li><li>阳台（3个）：洗衣机、烘干机、扫地机器人（留上下水）</li><li>餐边柜：饮水机等小家电</li><li>厨房顶部：燃气报警器预留电源</li><li>卫生间开关位置：主卫生放外面、次卫放里面</li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>六类网线、光纤到每个房间、不要接地屏蔽层</p><p>网络方案：</p><h3 id="全屋定制"><a href="#全屋定制" class="headerlink" title="全屋定制"></a>全屋定制</h3><p>全屋定制必须交定金才能上门测量的，所以一定搞清楚计费方式，做全屋定制是<strong>套餐的不要碰，不要碰，不要碰</strong></p><ul><li>一定要了解清楚（不要冲动签合同交定金）<ul><li>有没有增项</li><li>板材</li><li>五金<ul><li>拉手款：配的是什么款的拉手，是否隐形款，隐形款是否要加钱，加多少钱，五金升级怎么收费，数量有什么限制</li><li>高档五金：一般商家不会给你配什么高档五金的，升级的话谈好价格，但是在算钱的时候要先减去原本五金的钱</li></ul></li><li>工期</li><li>售后</li><li>灯带<ul><li>柜体灯带不值什么钱，倒是变压器值钱，但是如果商家一个变压器要收你几百块，赶紧跑就对了。也有一些商家灯带是按照米来收的，也有按照条来收的</li></ul></li></ul></li><li><strong>计费方式，投影最好</strong></li><li>不要兜底预算：用户型图直接让他们估价</li><li>还要看他们工地和案例</li><li>常见隐藏增项<ul><li>抽屉数量：一般有的送两个免费，外加抽屉收费，一定注意若是展开计费，抽屉越多总价会越高，会远远超出当初给的价格</li><li>加层板：<strong>好的定制一定是投影计价，不论你做多少层板都不会加钱的</strong></li><li><strong>边线、顶线</strong>：一般全屋定制中都有这个项目，一定问清是否收费，收费需要多少</li><li>见光板：几乎家家都得有，数量很少，一般需要在设计中解决不同材质的色差问题，因为一般见光板需要和门板同材质，所以几乎都得单独计费</li><li>五金件：一定搞清楚五金件都包括哪些，不包括哪些</li><li><strong>套色以及局部加厚版</strong>：家里定制逃不开套色设计，这里一定问清是否单独收费；局部加厚板，例如书桌面，书架层板用25板是否单独加钱，否则前期给你说的统一18板，后期你只要要求，全得加钱。</li><li><strong>背板厚度</strong>：一般各大定制商默认背板都是<strong>五厘或九厘</strong>板，其它的板是否有达到<strong>18mm</strong></li><li><strong>笼统报价一定问清实际误差</strong>：一定问清到底实际设计出来能差多少</li><li>柜门拉直器：超过<strong>180cm</strong>的柜门都需要拉直器，一定要提前咨询柜门包不包含这个，升级要不要收钱，要多少钱，质保期多久</li><li>超高柜门：一定要问清楚柜门最高可以做多高，加高要不要额外收钱</li><li>高低进深：某些商家餐边柜只做400，一旦出现加高和修改尺寸都要加价，一定要问清楚商家有没有这个费用，商家含糊其词肯定就是大坑，赶紧跑就对了</li><li>斜切拉手收费：斜切拉手有些商家不收钱，有些按条收，有些按米收</li><li>特殊封边：有些柜体会做特殊封边，可能会收钱，问问升级封边怎么收费，也要问问是否统一</li><li>顶封板：顶封板有些商家会算在柜体的价格，有些算在柜门，价格是不一样的，一定要问清楚</li><li>异形费：有些商家做异形是会额外收费的，一定要问清楚</li><li>不足一米按照一米收费：有些商家真的是这样，我们按照实际面积收费一般不会亏</li></ul></li><li>签订合同<ul><li>注意虚报面积：一定要核实清楚面积大小，多一点都是多花的冤枉钱，像上面就提到好几个可能存在虚报的情况，自己察觉不对劲就要提出来，核对清楚先</li><li>质保：查看质保范围，质保是不是全部包括，质保一般在3-5年，五金件1年</li><li>定制时间：要商量好定制时间、安装时间、预期赔偿、补件发货、二次上门时间等等</li><li>安装出错责任：在合同明确安装出错是谁的责任，需要重新花钱的谁负责</li><li>有害气体处理：要约定好有害气体如何处理，费用怎么样之类</li><li>进口板：进口板默认都是假一赔三的，注意在合同标注</li><li>确认套餐含量：购买套餐一定要确认其内五金件数量、抽屉数量、阻尼、拉直器等等，避免后期加价</li><li>其它人员费用：如果施工过程中存在其它非外包人员上楼服务费用如何处理，要商量好</li><li>延期赔偿方案</li></ul></li><li>安装<ul><li>可以提前问问商家，是外包工人还是自养工人</li></ul></li><li>环保等级：不要听商家怎么吹环保，一般用得最多是E1<ul><li>E1级：国家强制性标准国内室内家具板材合格的标准是E1级，甲醛释放量不超过<strong>0.124mg/m</strong></li><li>E0级：甲醛释放限量≤0.5mg/L，没有写进国家标准里，无人监管</li></ul></li><li>板材：环保性最好的板材是欧松板、禾香板，欧松板和禾香板工艺标准很高，其次是多层板<ul><li>橡木板</li><li>密度板：全称为密度纤维板，是以木质纤维或其他植物纤维为原料，经纤维制备，施加合成树脂，在加热加压的条件下，压制成的板材<ul><li>环保性较差</li><li>主要是做柜门，不能做柜体，容易变形</li></ul></li><li>颗粒板：由木材或木杆，原木打碎，两边使用细密木纤维，中间夹长质木纤维，施加胶粘剂后在热力和压力作用下胶合成的人造板，面板饰面通常为三聚氰胺饰面，其截面呈现蜂窝状板材。<ul><li>环保性较差</li><li>可以做柜体、柜门</li><li>不能用在潮湿空间</li></ul></li><li>杉木芯板</li><li>多层板<ul><li>多层板可以做柜体，做柜门的话，要注意高度，超过2米高的柜门不建议做</li></ul></li><li>欧松板<ul><li>稳定性最高</li></ul></li><li>禾香板<ul><li>稳定性和欧松板差不多</li></ul></li><li>实木复合板</li><li>生态板</li><li>大芯板(实木多层)：抗弯压强度差</li><li>三聚氰胺板</li><li>指接板</li><li>实木板：采用完整的木材（原木）制成的木板材</li></ul></li><li>封边<ul><li>激光封边</li><li>PUR封边</li><li>EVA封边</li></ul></li></ul><h3 id="厨房"><a href="#厨房" class="headerlink" title="厨房"></a>厨房</h3><ul><li>台面：不做挡水条，外边缘可以做略高的平板5毫米，做斜角<ul><li>石英石台面</li></ul></li><li>切菜区域高度：使用人高度除2 加5公分</li><li>高度：83公分；宽度：63公分</li><li>吊柜<ul><li>高度：离台面75到80公分高度</li><li>不要做肤感材质</li><li>蜂窝大板吊顶</li></ul></li><li>热水器<ul><li>预留50管：冷凝水、天然气管道<ul><li><strong>燃气热水器管道不能入墙？否则燃气公司不给开燃气？</strong></li></ul></li></ul></li><li>隐藏地轨推拉门或吊柜推拉门</li></ul><h3 id="书房"><a href="#书房" class="headerlink" title="书房"></a>书房</h3><p>电脑桌的墙面加一个护板避免将墙面踢伤</p><h3 id="封窗"><a href="#封窗" class="headerlink" title="封窗"></a>封窗</h3><ul><li>高透纱窗</li><li><strong>可根据生活阳台推拉门位置确定立柱位置</strong></li><li>窗台外面做挡水板，防止雨水渗入屋里<ul><li>几个卧室</li><li>客厅阳台外面</li></ul></li><li>卧室厨房<strong>窗户上面做挡水板</strong>，防止雨水飘进屋里</li></ul><h3 id="吊顶"><a href="#吊顶" class="headerlink" title="吊顶"></a>吊顶</h3><p>螺丝要做防锈处理，即使是防锈螺丝，因为在打的时候可能将防锈层打掉</p><p>石膏板接缝处要做V型槽，且油工挂网，拐角处要整板做L型</p><h3 id="窗帘盒"><a href="#窗帘盒" class="headerlink" title="窗帘盒"></a>窗帘盒</h3><ul><li>要用欧松板打底加固，便于安装窗帘盒轨道</li><li>电动双轨：25cm，单轨：20cm</li></ul><h3 id="隔音"><a href="#隔音" class="headerlink" title="隔音"></a>隔音</h3><ul><li>厕所：<ul><li>下水管：先包金色阻尼片，再包银色隔音棉（注意别用成保温棉了）</li></ul></li><li>吊顶<ul><li>阻尼隔音毡，便宜且薄，夹在两层石膏板中间，地面也可以用</li><li>龙骨减震器（也不贵）</li></ul></li></ul><h3 id="厕所"><a href="#厕所" class="headerlink" title="厕所"></a>厕所</h3><ul><li>地漏<ul><li>铺砖：做旋风地漏</li></ul></li><li>做海棠角</li><li>马桶<ul><li>旁边：插座防溅盒</li><li>注意马桶与墙的距离，否则后期可能马桶安装不上</li><li>是否考虑壁挂式马桶</li></ul></li><li>淋浴房<ul><li>做下沉式</li><li>做半玻璃隔断，不做推拉门</li></ul></li><li>洗手盆：做三代墙排</li><li>次卫：<ul><li>蹲便冲水水箱管子隐藏到墙里</li></ul></li></ul><h3 id="中央空调"><a href="#中央空调" class="headerlink" title="中央空调"></a>中央空调</h3><ul><li>位置：有个外机位放不下中央空调外机</li></ul><h3 id="合同注意事项"><a href="#合同注意事项" class="headerlink" title="合同注意事项"></a>合同注意事项</h3><ul><li>重点看违约条款<ul><li>约定工期内违约怎么算</li><li>没有按合同约定的材料和品牌型号来供应，以次充好</li><li>没有按合同规定的工艺标准施工、验收不合格的怎么处理</li><li>没有做到安全文明施工造成房子直接间接损失，责任怎么担<ul><li>成品保护</li><li>住人</li><li>消防</li><li>漏电</li><li>泡水</li></ul></li></ul></li><li>合同得盖齐缝章</li><li>合同附件<ul><li>设计施工图</li><li>施工工艺标准和方案</li><li>预算报价清单<ul><li>水电增项</li><li>施工做法描述</li><li>单价</li><li>数量</li><li>材料的<strong>品牌规格型号</strong>（不能只写品牌不写型号）</li></ul></li></ul></li><li>增项<ul><li>故意遗漏的增项：合同一定埋伏有按实际量或情况结算<ul><li>本合同额包含附件图纸和报价清单所含所有施工和措施项目如有遗漏施工方自行负责</li></ul></li><li>瓷砖薄贴会有增加</li></ul></li><li>保修<ul><li>家装保修就是两年保修，多了没用</li></ul></li><li>付款<ul><li>一定少预付</li><li>一定先做后付，验收合格后付</li><li>什么买材料费不够之类的一定不要动摇</li><li>最后5-10%，等保修单签订完成后再付</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;家电-amp-品牌&quot;&gt;&lt;a href=&quot;#家电-amp-品牌&quot; class=&quot;headerlink&quot; title=&quot;家电&amp;amp;品牌&quot;&gt;&lt;/a&gt;家电&amp;amp;品牌&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;冰箱：荣升BCD-506WKK1FPGZA-GQ51&lt;ul&gt;
&lt;li&gt;双
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>装修笔记</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/%E8%A3%85%E4%BF%AE%E7%AC%94%E8%AE%B0%20-%20%E5%AF%B9%E5%A4%96/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/装修笔记 - 对外/</id>
    <published>2023-02-20T16:00:00.000Z</published>
    <updated>2023-09-10T11:43:32.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ul><li>个人喜好说明<ul><li>注重<strong>方便实用</strong>&amp;<strong>舒适性</strong></li><li>很居家：<strong>做饭比较多</strong></li><li>不喜欢乱糟糟：尽可能多做一点收纳</li><li>有养绿植的爱好：阳台尽可能能养一点绿植</li><li><strong>隐蔽工程</strong>&amp;<strong>水电</strong>：<strong>一定</strong>、<strong>一定</strong>、<strong>一定</strong>要做好</li></ul></li><li>水电<ul><li>水管全换</li><li>电线：能复用就复用不能不用再局改</li><li>插座一定要留够（这里只是列举了一些可能考虑不到的）<ul><li>入户门里外尽量留插座：后期安装监控</li><li>客厅和主卧室（顶上预留插座）：电动窗帘（占时可能不装预留点位）</li><li>智能马桶插座</li><li>阳台扫地机器人（上下水&amp;插座）</li><li>厨房水槽下方至少三个插座：<strong>蒸烤一体机</strong>、前置过滤器、净水器、电动机械手臂（用于关水闸）</li><li>电视柜多留：路由器、小爱音响、电视</li><li>餐厅厨房外的墙上：留几个插座（以后吃火锅）</li></ul></li><li>要做前置过滤</li><li>不做管线机</li><li>热水器，要做回水<strong>大循环</strong>（<strong>零冷水</strong>）：<ul><li>要安装回水管</li><li>热水器处需要预留冷凝结管（预埋一根50关：放燃气管和冷凝水关）</li><li>进水、回水、燃气、等位置考虑放在热水器旁边；方便隐藏；防止后期吊柜需要做很长</li></ul></li><li>网络（<strong>光纤</strong> + <strong>超六类不带屏蔽层</strong>的网线）：<ul><li>每个房间都要网线和光纤线</li><li>弱电箱：可能需要放<strong>交换机</strong>、<strong>路由器</strong>、<strong>光猫</strong>（预留足够的插座）</li><li>弱电箱到书房：两根网线</li><li>弱电箱到客厅电视柜：：两根网线</li></ul></li></ul></li><li>改&amp;建<ul><li>封阳台</li><li>生活阳台&amp;客厅阳台<strong>连接处搭建</strong>，墙要去除一部分到连接处</li><li>冰箱位置放厨房外面</li><li>做餐边柜</li><li><strong>所有飘窗</strong>要打掉，可能涉及一些墙也需要打掉</li><li><strong>主卧</strong>和<strong>主卧挨着的次卧</strong>空调机位打掉</li><li>厨房阳台门封掉：该墙上有预留水电，放洗衣机（无烘干机）和扫地机器人</li><li>进门处：由于不够做鞋柜的宽度，需要<strong>移墙</strong>，原来的门洞位置不改</li><li>电视墙：需要加固，预留50管</li><li>封窗：可以与生活阳台的推拉门结合</li><li>门洞调整到一样高：以书房的门动为标准</li></ul></li><li>全屋智能包含<ul><li>灯</li><li>窗帘</li><li>空调</li><li>厨房&amp;厕所：会做一些感应开关灯</li><li>客厅和厨房多预留一个底盒做红外感应器</li></ul></li><li>其他说明<ul><li>主卧要做一个衣帽间：<strong>是否隐形门待定</strong></li><li>中央空调</li><li>厕所：墙排</li><li>地板：全屋通铺（亮光700 X 1500 或 800 X 800）根据排版情况再确定</li><li>厕所：墙地用600 X 1200 或 400 X 800</li><li>尽量做一些<strong>极简风</strong>：如卧室门、卫生间门等</li><li>门洞加高</li><li>书房三联动吊轨推拉门</li><li>厨房门做吊轨三联动</li></ul></li><li>卫生间<ul><li>主卫：<ul><li>下沉式淋浴，做一个玻璃隔断即可</li><li>马桶</li></ul></li><li>次卫：<ul><li>蹲便</li><li>不额外做淋雨隔断</li></ul></li></ul></li><li>不做<ul><li>不做全屋吊顶：只吊顶中央空调的地方</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本要求&quot;&gt;&lt;a href=&quot;#基本要求&quot; class=&quot;headerlink&quot; title=&quot;基本要求&quot;&gt;&lt;/a&gt;基本要求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;个人喜好说明&lt;ul&gt;
&lt;li&gt;注重&lt;strong&gt;方便实用&lt;/strong&gt;&amp;amp;&lt;strong&gt;舒适性&lt;/
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>装修笔记</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/%E8%A3%85%E4%BF%AE%E7%AC%94%E8%AE%B0%20-%20%E5%AF%B9%E5%86%85/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/装修笔记 - 对内/</id>
    <published>2023-02-20T16:00:00.000Z</published>
    <updated>2023-09-10T11:38:25.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ul><li>个人喜好说明<ul><li>注重<strong>方便实用</strong>&amp;<strong>舒适性</strong></li><li>很居家：<strong>做饭比较多</strong></li><li>不喜欢乱糟糟：尽可能多做一点收纳</li><li>有养绿植的爱好：阳台尽可能能养一点绿植</li><li><strong>隐蔽工程</strong>&amp;<strong>水电</strong>：<strong>一定</strong>、<strong>一定</strong>、<strong>一定</strong>要做好</li></ul></li><li>水电<ul><li>水管全换</li><li>电线：能复用就复用不能不用再局改</li><li>插座一定要留够（这里只是列举了一些可能考虑不到的）<ul><li>入户门里外尽量留插座：后期安装监控</li><li>客厅和主卧室（顶上预留插座）：电动窗帘（占时可能不装预留点位）</li><li>智能马桶插座</li><li>阳台扫地机器人（上下水&amp;插座）</li><li>厨房水槽下方至少三个插座：<strong>蒸烤一体机</strong>、前置过滤器、净水器、电动机械手臂（用于关水闸）</li><li>电视柜多留：路由器、小爱音响、电视</li><li>餐厅厨房外的墙上：留几个插座（以后吃火锅）</li></ul></li><li>要做前置过滤</li><li>不做管线机</li><li>热水器，要做回水<strong>大循环</strong>（<strong>零冷水</strong>）：<ul><li>要安装回水管</li><li>热水器处需要预留冷凝结管（预埋一根50关：放燃气管和冷凝水关）</li><li>进水、回水、燃气、等位置考虑放在热水器旁边；方便隐藏；防止后期吊柜需要做很长</li></ul></li><li>网络（<strong>光纤</strong> + <strong>超六类不带屏蔽层</strong>的网线）：<ul><li>每个房间都要网线和光纤线</li><li>弱电箱：可能需要放<strong>交换机</strong>、<strong>路由器</strong>、<strong>光猫</strong>（预留足够的插座）</li><li>弱电箱到书房：两根网线</li><li>弱电箱到客厅电视柜：：两根网线</li></ul></li></ul></li><li>改&amp;建<ul><li>封阳台</li><li>生活阳台&amp;客厅阳台<strong>连接处搭建</strong>，墙要去除一部分到连接处</li><li>冰箱位置放厨房外面</li><li>做餐边柜</li><li><strong>所有飘窗</strong>要打掉，可能涉及一些墙也需要打掉</li><li><strong>主卧</strong>和<strong>主卧挨着的次卧</strong>空调机位打掉</li><li>厨房阳台门封掉：该墙上有预留水电，放洗衣机（无烘干机）和扫地机器人</li><li>进门处：由于不够做鞋柜的宽度，需要<strong>移墙</strong>，原来的门洞位置不改</li><li>电视墙：需要加固，预留50管</li><li>封窗：可以与生活阳台的推拉门结合</li><li>门洞调整到一样高：以书房的门动为标准</li></ul></li><li>全屋智能包含<ul><li>灯</li><li>窗帘</li><li>空调</li><li>厨房&amp;厕所：会做一些感应开关灯</li><li>客厅和厨房多预留一个底盒做红外感应器</li></ul></li><li>其他说明<ul><li>主卧要做一个衣帽间：<strong>是否隐形门待定</strong></li><li>中央空调</li><li>厕所：墙排</li><li>地板：全屋通铺（亮光700 X 1500 或 800 X 800）根据排版情况再确定</li><li>厕所：墙地用600 X 1200 或 400 X 800</li><li>尽量做一些<strong>极简风</strong>：如卧室门、卫生间门等</li><li>门洞加高</li><li>书房三联动吊轨推拉门</li><li>厨房门做吊轨三联动</li></ul></li><li>卫生间<ul><li>主卫：<ul><li>下沉式淋浴，做一个玻璃隔断即可</li><li>马桶</li></ul></li><li>次卫：<ul><li>蹲便</li><li>不额外做淋雨隔断</li></ul></li></ul></li><li>不做<ul><li>不做全屋吊顶：只吊顶中央空调的地方</li></ul></li></ul><h3 id="装修概图"><a href="#装修概图" class="headerlink" title="装修概图"></a>装修概图</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>优点：不门对门</p><p><img src="../../images/装修/装修图1.png" alt></p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p><img src="C:/Users/90627/AppData/Roaming/Typora/typora-user-images/image-20230402182445563.png" alt="image-20230402182445563"></p><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p><img src="C:/Users/90627/AppData/Roaming/Typora/typora-user-images/image-20230402182510582.png" alt="image-20230402182510582"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本要求&quot;&gt;&lt;a href=&quot;#基本要求&quot; class=&quot;headerlink&quot; title=&quot;基本要求&quot;&gt;&lt;/a&gt;基本要求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;个人喜好说明&lt;ul&gt;
&lt;li&gt;注重&lt;strong&gt;方便实用&lt;/strong&gt;&amp;amp;&lt;strong&gt;舒适性&lt;/
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>CPP基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AF%AD%E8%A8%80/CPP/CPP%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/语言/CPP/CPP基础/</id>
    <published>2022-09-09T16:00:00.000Z</published>
    <updated>2022-12-04T10:58:19.466Z</updated>
    
    <content type="html"><![CDATA[<p>C++是一种<strong>静态类型</strong>的、<strong>编译式</strong>的、<strong>通用</strong>的、<strong>大小写敏感</strong>的、<strong>不规则</strong>的编程语言，<strong>支持过程化编程</strong>、<strong>面向对象编程</strong>和<strong>泛型编程</strong>，被认为是一种<strong>中级</strong>语言，它综合了<strong>高级语言</strong>和<strong>低级语言</strong>的特点；C++是C的一个<strong>超集</strong>，任何合法的C程序都是合法的C++程序。使用<strong>静态类型</strong>的编程语言是在<strong>编译时</strong>执行<strong>类型检查</strong>，<strong>而不是</strong>在<strong>运行时</strong>执行类型检查；标准的C++由<strong>三个重要部分</strong>组成：</p><ul><li><strong>核心语言</strong>：提供了<strong>所有构件块</strong>，包括<strong>变量</strong>、<strong>数据类型</strong>和<strong>常量</strong>等</li><li><strong><code>C++</code>标准库</strong>：提供了<strong>大量的函数</strong>，用于<strong>操作文件</strong>、<strong>字符串</strong>等</li><li><strong>标准模板库<code>STL</code></strong>：提供了<strong>大量的方法</strong>，用于<strong>操作数据结构</strong>等</li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在同一条定义语句中，可以使用先定义的变量值去初始化后定义的其他变量，在C++中初始化和赋值时两个完全不同的操作，初始化不是赋值，<strong>初始化</strong>的含义是<strong>创建变量时赋予其一个初始值</strong>，而<strong>赋值的含义</strong>是<strong>把对象的当前值擦除</strong>，<strong>以一个新的值来替代</strong>，C++初始化有好几种不同的形式，用<strong>花括号<code>{}</code></strong>来初始化变量是<strong><code>C++11</code>新标准</strong>的一部份，这种初始化的形式被称为<strong>列表初始化</strong>，无论是初始化对象还是为对象赋新值都可以使用一组由花括号括起来的初始值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>当用于内置类型的变量时，若使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.141592653</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="comment">// 错误：转换未执行，因为存在丢失信息的危险</span></span><br><span class="line">int c(ld), d = ld; // 正确：转换执行，且确实丢失了部分值</span><br></pre></td></tr></table></figure><p>为了支持分离式编译，C++将<strong>声明</strong>和<strong>定义</strong>区分开，<strong>声明</strong>是<strong>使得名字为程序所知</strong>，<strong>定义</strong>是负责<strong>创建与名字关联的实体</strong>；若想声明一个变量而非定义，可在变量名前加<strong><code>extern</code></strong>关键字；在<strong>函数体内若初始化一个由<code>extern</code>标记的变量将引发错误</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ival;  <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">int</span> j;  <span class="comment">// 定义 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ival2 = <span class="number">122</span>;  <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure><h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p>默认情况下，const对象仅在文件内有效，当多个文件同时出现同名const变量时，等同于在不同文件中分别定义了独立的变量；若要多个文件共享const对象，必须在变量的定义之前添加extern关键字；某些时候const变量<strong>不是一个常量表达式</strong>，但<strong>需要文件间共享</strong>，可以在const变量<strong>声明和定义处都添加extern关键字</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;</span><br><span class="line"><span class="comment">// file_1.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = fcn();</span><br></pre></td></tr></table></figure><p>const引用，对常量的引用不能被用作修改它所绑定的对象；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;</span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">// 错误：r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;   <span class="comment">// 错误：不能让一个非常量引用指向一个常量对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span> ik = r1 * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = i;</span><br><span class="line">r4 = <span class="number">30</span>;</span><br><span class="line">r1 = <span class="number">20</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p><strong>指向常量的指针，不能改变其所指向的值，允许一个指向常量的指针，指向一个非常量对象</strong>；允许把指针本身定义为常量，即<strong>常量指针</strong>；指针本身是一个对象，它可以指向另一个对象，指针本身是不是常量以及指针所指向是不是一个常量是两个相互独立的问题；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi; <span class="comment">// 错误：ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;</span><br><span class="line">*cptr = <span class="number">8.88</span>;<span class="comment">// 错误：不能给*cptr赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">// 不能修改pip存储的地址和其指向的对象</span></span><br><span class="line"></span><br><span class="line">*curErr = <span class="number">2.2</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p><strong>顶层const</strong>表示<strong>指针本身是一个常量</strong>，<strong>底层const</strong>表示<strong>指针所指向的对象是一个常量</strong>；顶层const可以表示任意的对象是常量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;<span class="comment">// 不能改变p1的值，顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">// 不能改变ci的值，顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">// 允许改变p2的值，底层const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;   <span class="comment">// 靠右的const是顶层，靠左的const是底层</span></span><br></pre></td></tr></table></figure><h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>有两种方式可以定义类型别名，传统方法是使用<strong><code>typedef</code></strong>关键字，新标准可以使用<strong><code>using</code></strong>关键字；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">// wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base是double的同义词，p是double*的同义词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> dalise =  <span class="keyword">double</span>;</span><br></pre></td></tr></table></figure><h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><p><strong><code>auto</code></strong>能让编译器通过<strong>初始值来推算</strong>，从而替我们去分析表达式所属类型，故auto定义的变量必须要有初始值；auto能在一条语句中声明多个变量，且只能有一个基本数据类型；auto一般会<strong>忽略顶层const保留底层const</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>; <span class="comment">// 错误：sz和pi类型不一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;h1 = <span class="number">42</span>;       <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;h2 = <span class="number">42</span>;        <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;h3 = <span class="number">42</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;h4 = <span class="number">42</span>;   <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p2 = &amp;ci;  <span class="comment">// 错误，i的类型是int，&amp;ci的类型是const int</span></span><br></pre></td></tr></table></figure><h5 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h5><p><strong><code>decltype</code></strong>的作用是选择并返回操作数的数据类型，编译器分析表达式并得到他的类型，但不实际计算表达式的值；<strong><code>decltype</code></strong>的表达式若是<strong>加上括号的变量，则结果则是引用</strong>；即<strong><code>decltype((veriable))</code></strong>的结果永远是引用，<strong><code>decltype(veriable)</code></strong>结果只有veriable本身就是一个引用时才是引用；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;  <span class="comment">// sun的类型是函数f返回的类型，编译器不实际执行函数f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">// y的类型是const int&amp;，y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">// 错误：z是一个引用，必须初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">// 正确：加法结果是int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;   <span class="comment">// 错误：c是int&amp;，必须初始化</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>((i)) d;<span class="comment">// 错误：d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;<span class="comment">// 正确：e是一个int</span></span><br></pre></td></tr></table></figure><h5 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h5><p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>，当预处理器遇到#include标记时就会用指定的头文件的内容代替#include；C++还会用到一项预处理功能即<strong>头文件保护符</strong>，头文件保护符依赖于<strong>预处理变量</strong>即<strong><code>#define</code></strong>定义的变量，<strong>预处理变量</strong>有<strong>已定义</strong>和<strong>未定义</strong>两种状态；<strong><code>#ifdef</code></strong>当且仅当变量一定义时为正，<strong><code>#ifndef</code></strong>当且仅当变量未定义时为真，一旦检测到为真，则执行后续操作直到遇到<strong><code>#endif</code></strong>指令为止；</p><p><strong>整个程序中预处理变量包括头文件保护符必须唯一</strong>，通常做法是基于头文件中类的名字来构建保护符名字，以确保唯一性，为了避免与程序中的其他实体发生名字冲突，<strong>一般预处理器变量名称全部大写</strong>；</p><h4 id="引用-amp-指针"><a href="#引用-amp-指针" class="headerlink" title="引用&amp;指针"></a>引用&amp;指针</h4><p><strong>引用必须被初始化</strong>，初始化变量时，初始值会被<strong>拷贝</strong>到新建的对象中，但定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，而不是将初始值拷贝给引用；<strong>引用并非对象</strong>，只是为一个已存在的对象起的一个别名；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal2; <span class="comment">// 错误：引用必须被初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = <span class="number">10</span>;  <span class="comment">// 错误：引用类型的初始值必须是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal4 = dval; <span class="comment">// 错误：这里引用类型的初始值必须是int对象</span></span><br></pre></td></tr></table></figure><p>指针是指向另一种类型的复合类型，其<strong>本身就是一个对象</strong>，<strong>允许对指针赋值和拷贝</strong>，无需在定义时赋初值；和其他类型一样在<strong>块作用域内</strong>定义的指针若没有被初始化，将拥有一个<strong>不确定的值</strong>；指针<strong>存放某个对象的地址</strong>，若想获取地址，需使用<strong>取地址符<code>&amp;</code></strong>；声明语句中<strong>指针的类型</strong>实际上<strong>被用于指定它所指向对象的类型</strong>，<strong>二者必须匹配</strong>；指针指向了一个对象允许用<strong>解引用符<code>*</code></strong>来访问对象；引用本身不是一个对象，因此<strong>不能定义指向引用的指针</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">// p存放变量ival的地址</span></span><br><span class="line"><span class="keyword">int</span> *p2 = p;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *p3 = p;  <span class="comment">// 错误：指针p3的类型和p类型不匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="literal">nullptr</span>;<span class="comment">// 等价于int *p4 = 0;</span></span><br><span class="line"><span class="keyword">int</span> *p5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p6 = <span class="literal">NULL</span>;  <span class="comment">// 需要#include cstdlib，等价于int *p6 = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p7, p8; <span class="comment">// p7是指向int的指针，p8是int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **p9 = &amp;p;  <span class="comment">// p9是指向指针p的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;  <span class="comment">// r是一个对指针p的引用</span></span><br><span class="line">r = &amp;ival;    <span class="comment">// r引用了一个指针，这里其实就是令p指向了ival</span></span><br><span class="line">*r = <span class="number">0</span>;       <span class="comment">// 将ival值改变为0</span></span><br></pre></td></tr></table></figure><p><strong>void<code>*</code></strong>是一种特殊的指针类型，可用于存放任意对象的地址，但比较局限，只能用于和别的指针比较，作为函数的输入输出，或赋值给另一个<strong>void<code>*</code></strong>指针，<strong>不能直接操作该指针指向的对象</strong>；</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>C++提供<strong>七种基本的数据类型</strong>，且一个基本类型可以使用一个或多个<strong>类型修饰符<code>signed</code>、<code>unsigned</code>、<code>short</code>、<code>long</code></strong>来修饰：</p><table><tr><th style="text-align:center;">关键字</th><th style="text-align:center;">类型</th><th style="text-align:center;">具体类型</th><th style="text-align:center;">占位</th><th style="text-align:center;">范围</th><th style="text-align:center;">备注</th></tr><tr><td style="text-align:center;">bool</td><td style="text-align:center;">布尔型</td><td style="text-align:center;"><strong><code>bool</code></strong></td><td style="text-align:center;"><strong><code>1</code>字节</strong></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;" rowspan="3">char</td><td style="text-align:center;" rowspan="3">字符型</td><td style="text-align:center;"><strong><code>char</code></strong></td><td style="text-align:center;"><strong><code>1</code>字节</strong></td><td style="text-align:center;">-128到127或0到255</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>unsigned char</code></strong></td><td style="text-align:center;"><strong><code>1</code>字节</strong></td><td style="text-align:center;">0到255</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>signed char</code></strong></td><td style="text-align:center;"><strong><code>1</code>字节</strong></td><td style="text-align:center;">-128到127</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;" rowspan="9">int</td><td style="text-align:center;" rowspan="9">整型</td><td style="text-align:center;"><strong><code>int</code></strong></td><td style="text-align:center;"><strong><code>4</code>字节</strong></td><td style="text-align:center;">-2^31到2^31-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>signed int</code></strong></td><td style="text-align:center;"><strong><code>4</code>字节</strong></td><td style="text-align:center;">-2^31到2^31-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>unsigned int</code></strong></td><td style="text-align:center;"><strong><code>4</code>字节</strong></td><td style="text-align:center;">0到2^32-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>short int</code></strong></td><td style="text-align:center;"><strong><code>2</code>字节</strong></td><td style="text-align:center;">-2^15到2^15-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>signed short int</code></strong></td><td style="text-align:center;"><strong><code>2</code>字节</strong></td><td style="text-align:center;">-2^15到2^15-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>unsigned short int</code></strong></td><td style="text-align:center;"><strong><code>2</code>字节</strong></td><td style="text-align:center;">0到2^16-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>long int</code></strong></td><td style="text-align:center;"><strong><code>8</code>字节</strong></td><td style="text-align:center;">-2^63到2^63-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>signed long int</code></strong></td><td style="text-align:center;"><strong><code>8</code>字节</strong></td><td style="text-align:center;">-2^63到2^63-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong><code>unsigned long int</code></strong></td><td style="text-align:center;"><strong><code>8</code>字节</strong></td><td style="text-align:center;">0到2^64-1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">float</td><td style="text-align:center;">浮点型</td><td style="text-align:center;"><strong><code>float</code></strong></td><td style="text-align:center;"><strong><code>4</code>字节</strong></td><td style="text-align:center;"></td><td style="text-align:center;">1位符号<br>8位指数<br>23位小数</td></tr><tr><td style="text-align:center;" rowspan="2">double</td><td style="text-align:center;" rowspan="2">双浮点型</td><td style="text-align:center;"><strong><code>double</code></strong></td><td style="text-align:center;"><strong><code>8</code>字节</strong></td><td style="text-align:center;"></td><td style="text-align:center;">1位符号<br>11位指数<br>52位小数</td></tr><tr><td style="text-align:center;"><strong><code>long double</code></strong></td><td style="text-align:center;"><strong><code>16</code>字节</strong></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">void</td><td style="text-align:center;">无类型</td><td style="text-align:center;"><strong><code>void</code></strong></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">表示类型的缺失</td></tr><tr><td style="text-align:center;">wchar_t</td><td style="text-align:center;">宽字符型</td><td style="text-align:center;"><strong><code>wchar_t</code></strong></td><td style="text-align:center;"><strong><code>2</code>或<code>4</code>字节</strong></td><td style="text-align:center;"></td><td style="text-align:center;">1个宽字符</td></tr></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某个类型的最大最小值</span></span><br><span class="line">(numeric_limits&lt;<span class="keyword">bool</span>&gt;::max)();</span><br><span class="line">(numeric_limits&lt;<span class="keyword">bool</span>&gt;::min)();</span><br><span class="line"><span class="comment">// 获取类型或变量所占字节数</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line"><span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(a);</span><br></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举类型是C++中的<strong>一种派生数据类型</strong>，它是<strong>由用户定义</strong>的<strong>若干枚举常量的集合</strong>，枚举类型的一般形式为，若枚举没有初始化即省掉<strong>=整型常数</strong>时，则从第一个标识符开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123;</span><br><span class="line">    标识符[=整型常数], </span><br><span class="line">    标识符[=整型常数], </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; [枚举变量];</span><br><span class="line"><span class="comment">// 默认第一个名称的值为0，第二个名称的值为1，第三个名称的值为2</span></span><br><span class="line"><span class="keyword">enum</span> color &#123; red, green, blue &#125; c, d, e; <span class="comment">// 不管red是多少，c默认为0，但d和e并非0，且可同时定义多个枚举变量</span></span><br><span class="line">c = blue; <span class="comment">// c = 2</span></span><br><span class="line"><span class="function">color <span class="title">c1</span><span class="params">(blue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给名称赋予一个特殊的值，blue的值为6，默认每个名称都会比它前面一个名称大1，但red的值依然为0</span></span><br><span class="line"><span class="keyword">enum</span> color &#123; red, green=<span class="number">5</span>, blue &#125;;</span><br><span class="line">color light, g, h;  <span class="comment">// 不管red是多少，light默认为0</span></span><br><span class="line"></span><br><span class="line">light = <span class="number">1</span>; <span class="comment">// 不可以，int不能转为枚举常量</span></span><br><span class="line">light = <span class="number">200</span>;  <span class="comment">// 不可以, 200不是color枚举常量</span></span><br><span class="line">red++; <span class="comment">// 错误</span></span><br><span class="line">color b = red + green; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">num = blue + <span class="number">2</span>; <span class="comment">// 可以，枚举常量可以提升为int</span></span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在<strong>函数</strong>或<strong>一个代码块内</strong>部声明的变量称为<strong>局部变量</strong>，在<strong>函数参数的定义中</strong>声明的变量称为<strong>形式参数</strong>，在<strong>所有函数外部声明的变量</strong>称为<strong>全局变量</strong>。<strong>局部变量</strong>被定义时<strong>系统不会对其初始化</strong>，<strong>全局变量</strong>系统会<strong>自动初始化</strong>为下列值：</p><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">初始化默认值</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">‘\0’</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">pointer</td><td style="text-align:left">NULL</td></tr></tbody></table><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>可使用<strong><code>#define</code></strong> 预处理器和<strong><code>const</code></strong>关键字两种方式定义<strong>常量</strong>，<strong><code>#define</code>宏定义</strong>其最大的特点是<strong>语义替换</strong>，其定义的常量值<strong>没有类型限定</strong>也<strong>不做类型检查</strong>，<strong>在宏出现的地方直接展开</strong>，在<strong>预处理阶段完成</strong>；<strong><code>#define</code>只是替换不会做表达式运算</strong>；<strong><code>#define</code>宏仅仅是展开</strong>，有多少地方使用就展开多少次，<strong>不会分配内存</strong>；<strong><code>#define</code></strong>定义的宏常量在内存中有<strong>若干个拷贝</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1 + 2 <span class="comment">// 预想的N值是3，我们这样使用N </span></span></span><br><span class="line"><span class="keyword">double</span> a = N/<span class="number">2</span>; <span class="comment">// 预想的a的值是1.5，可实际上：a = 1+2/2 = 2 结果是2</span></span><br></pre></td></tr></table></figure><p><strong><code>const</code></strong>是<strong>编译器编译运行时</strong>完成的，时间上<strong><code>define</code></strong>早于<strong><code>const</code></strong>，<strong><code>const</code></strong>是关键字它会<strong>在编译时检查数据类型</strong>，会在内存中分配，const定义的只读变量在程序运行过程中只有<strong>一份拷贝</strong>；就<strong>空间效率</strong>而言<strong><code>const</code></strong>优于<strong><code>define</code></strong>；</p><h3 id="常见关键字用法"><a href="#常见关键字用法" class="headerlink" title="常见关键字用法"></a>常见关键字用法</h3><h5 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h5><p>允许在C++程序中嵌入汇编代码</p><h5 id="auto-1"><a href="#auto-1" class="headerlink" title="auto"></a>auto</h5><p><strong>存储类型标识符</strong>，但<strong>从C++ 17开始</strong>，auto关键字<strong>不再是C++存储类说明符</strong>，表明<strong>变量自动具有本地范围</strong>，<strong>块范围的变量声明</strong>，如for循环体内的变量声明默认为auto存储类型；auto关键字用于<strong>声明变量时</strong>根据<strong>初始化表达式自动推断该变量的类型</strong>、<strong>声明函数时</strong>函数<strong>返回值的占位符</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="number">3.14</span>;          <span class="comment">// double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;        <span class="comment">// const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">9</span>);   <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3 = <span class="string">'r'</span>;    <span class="comment">// 错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure><h5 id="register"><a href="#register" class="headerlink" title="register"></a>register</h5><p>register声明的变量称为<strong>寄存器变量</strong>，在可能的情况下会直接存放在<strong>机器的寄存器中</strong>；但对<strong><code>32</code>位编译器不起作用</strong>，当<strong>全局优化<code>global optimizations</code>打开时</strong>，它会选择是否放在自己的寄存器中；不过其它与register关键字有关的其它符号都对32位编译器有效；</p><h5 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h5><p>显示的，作用是<strong>禁止单参数构造函数</strong>被用于<strong>自动类型转换</strong></p><h5 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h5><p>用来修改类型的<strong><code>const</code></strong>或<strong><code>volatile</code></strong>属性，<strong>常量指针</strong>被转化成<strong>非常量指针</strong>，并且<strong>仍然指向原来的对象</strong>；<strong>常量引用</strong>被转换成<strong>非常量引用</strong>，并且仍然指向原来的对象；<strong>常量对象</strong>被转换成<strong>非常量对象</strong>，用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;type_id&gt; (expression)</span><br></pre></td></tr></table></figure><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p><strong>释放程序动态申请的内存空间</strong>，delete后面通常是一个<strong>指针</strong>或<strong>数组<code>[]</code></strong>，且<strong>只能<code>delete</code>通过<code>new</code>关键字申请的指针</strong>，否则会发生错误</p><h5 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h5><p>动态转换，允许在<strong>运行时进行类型转换</strong>，从而使程序能够在一个类层次结构安全地转换类型，提供了<strong>把基类指针转换成派生类指针</strong>或<strong>把指向基类的左值转换成派生类的引用</strong>两种转换方式</p><h5 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h5><p>用于操作符重载</p><h5 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h5><p><strong>typedef</strong>可以为一个<strong>已有的类型取一个新的名字</strong>，语法：<strong><code>typedef type newname;</code></strong> ，如<strong><code>typedef int feet;</code></strong>，即feet是int的另一个名称，然后则可以通过feet声明整型变量；</p><h5 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h5><p>指出<strong>指针</strong>或<strong>引用</strong>指向的对象的<strong>实际派生类型</strong></p><h5 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h5><p>该关键字<strong>告诉编译器把一个特殊的名字解释成一个类型</strong></p><h5 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h5><p>声明<strong>变量</strong>或<strong>函数</strong>为<strong>外部链接</strong>，即该变量或函数名<strong>在其它文件中可见</strong>，<strong>被其修饰的变量</strong>是<strong>静态分配空间</strong>的，即程序开始时分配，结束时释放，用其声明的变量或函数应该在<strong>别的文件</strong>或<strong>同一文件的其它地方定义实现</strong>。在<strong>文件内声明一个变量或函数默认为可被外部使用</strong>。在C++中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用，目前仅支持<strong>C</strong>转换标记，来支持C编译器链接，使用这种情况有两种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> 声明语句</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123; 声明语句块 &#125;</span><br></pre></td></tr></table></figure><h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><p>为了访问<strong>其他编译单元</strong>中的<strong>变量</strong>或<strong>对象</strong>，对普通类型包括<strong>基本数据类</strong>、<strong>结构</strong>和<strong>类</strong>，可利用关键字<strong><code>extern</code></strong>，来使用这些变量或对象时；但<strong>模板类型</strong>则必须在<strong>定义这些模板类对象</strong>和<strong>模板函数</strong>时，使用标准C++新增加的关键字<strong><code>export</code></strong>导出；</p><h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><p>联合，类似于<strong><code>enum</code></strong>，不同的是enum实质上是int类型的，而<strong><code>union</code>可用于所有类型</strong>，并且其<strong>占用空间是随着实际类型大小变化的</strong></p><h5 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h5><p>友元，<strong>声明友元关系</strong>，<strong>友元可以访问</strong>与其<strong>有<code>friend</code>关系</strong>的<strong>类</strong>中的<strong><code>private</code></strong>和<strong><code>protected</code></strong>成员，通过友元直接访问类中的<strong><code>private</code></strong>和<strong><code>protected</code></strong>成员的主要目的是<strong>提高效率</strong>，友元包括<strong>友元函数</strong>和<strong>友元类</strong>；</p><h5 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h5><p>内联，<strong>函数的定义</strong>将在<strong>编译时</strong>在<strong>调用处展开</strong>，inline函数一般由<strong>短小</strong>的语句组成，可以<strong>提高程序效率</strong></p><h5 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h5><p>易变的，<strong>只能</strong>用于<strong>类</strong>的<strong>非静态</strong>和<strong>非常量数据成员</strong>，若需要在<strong>该类函数中</strong>对<strong>类的数据成员进行赋值</strong>，这时就需要用到<strong><code>mutable</code></strong>关键字</p><h5 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h5><p><strong><code>type-id</code></strong>必须是一个<strong>指针</strong>、<strong>引用</strong>、<strong>算术类型</strong>、<strong>函数指针</strong>或<strong>成员指针</strong>。它<strong>可以把一个指针转换成一个整数</strong>，<strong>也可以把一个整数转换成一个指针</strong>，先把一个指针转换成一个整数，再<strong>把该整数转换成原类型的指针</strong>，还可以得到原先的指针值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reinpreter_cast&lt;type-id&gt; (expression)</span><br></pre></td></tr></table></figure><h5 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h5><p>由于C++每种类型的大小都是<strong>由编译器自行决定的</strong>，为了<strong>增加可移植性</strong>，可以用<strong><code>sizeof</code></strong>运算符<strong>获得该数据类型占用的字节数</strong></p><h5 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h5><p>宽字符类型，每个wchar_t类型占2个字节16位宽，<strong>汉字的表示</strong>就要用到<strong><code>wchar_t</code></strong></p><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量，对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++是一种&lt;strong&gt;静态类型&lt;/strong&gt;的、&lt;strong&gt;编译式&lt;/strong&gt;的、&lt;strong&gt;通用&lt;/strong&gt;的、&lt;strong&gt;大小写敏感&lt;/strong&gt;的、&lt;strong&gt;不规则&lt;/strong&gt;的编程语言，&lt;strong&gt;支持过程化编程
      
    
    </summary>
    
      <category term="语言" scheme="https://yaoyinglong.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="CPP" scheme="https://yaoyinglong.github.io/categories/%E8%AF%AD%E8%A8%80/CPP/"/>
    
    
      <category term="C++" scheme="https://yaoyinglong.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AF%AD%E8%A8%80/%E5%89%8D%E7%AB%AF/TypeScript%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/语言/前端/TypeScript基础/</id>
    <published>2022-09-06T16:00:00.000Z</published>
    <updated>2022-09-09T14:53:26.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong><code>TypeScript</code></strong>是由<strong>微软</strong>开发的<strong>自由</strong>和<strong>开源</strong>的编程语言<strong>是JavaScript的一个超集</strong>，TypeScript可编译出<strong>纯净</strong>、 <strong>简洁</strong>的JavaScript代码，且可运行在<strong>任何浏览器上</strong>、<strong>Node.js环境中</strong>和<strong>任何支持ECMAScript3或更高版本的JavaScript引擎</strong>中；<strong><code>TypeScript</code></strong>优势在于<strong>有更多的规则</strong>和<strong>类型限制</strong>，代码具有<strong>更高的预测性</strong>、<strong>可控性</strong>，<strong>易于维护</strong>和<strong>调试</strong>；对<strong>模块</strong>、<strong>命名空间</strong>和<strong>面向对象</strong>的支持，更容易组织代码开发大型复杂程序，且<strong>编译</strong>步骤可捕获<strong>运行之前的错误</strong>；</p><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"bob"</span>; <span class="comment">// 可以使用单引号或双引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版字符串：可定义多行文本和内嵌表达式，以$&#123; expr &#125;这种形式嵌入表达式</span></span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br><span class="line"><span class="comment">// 与下面定义sentence的方式效果相同</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">"Hello, my name is "</span> + name + <span class="string">".\n\n"</span> +</span><br><span class="line">    <span class="string">"I'll be "</span> + (age + <span class="number">1</span>) + <span class="string">" years old next month."</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 使用数组泛型Array&lt;元素类型&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想传入一个string或null或undefined，可以使用联合类型string | null | undefined</span></span><br></pre></td></tr></table></figure><h5 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h5><p>可以使用<strong><code>...name</code></strong>语法创建一个<strong>剩余变量列</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input; <span class="comment">// 解构数组赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">f(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用...name语法创建一个剩余变量列</span></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="string">"foo"</span>,</span><br><span class="line">    b: <span class="number">12</span>,</span><br><span class="line">    c: <span class="string">"bar"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = o;</span><br><span class="line"><span class="keyword">let</span> &#123;a: newName1, b: newName2&#125; = o; <span class="comment">// 也可以给属性以不同的名字，这里的冒号不是指示类型的</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, b&#125;: &#123;a: <span class="built_in">string</span>, b: <span class="built_in">number</span>&#125; = o; <span class="comment">//  想指定它的类型， 仍然需要在其后写上完整的模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于函数声明</span></span><br><span class="line"><span class="keyword">type</span> C = &#123;a: <span class="built_in">string</span>, b?: <span class="built_in">number</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;a, b&#125;: C</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;a, b&#125; = &#123;a: "", b: 0&#125;</span>): <span class="title">void</span> </span>&#123; <span class="comment">// 默认值</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// ok, default to &#123;a: "", b: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;a, b = 0&#125; = &#123;a: ""&#125;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">f(&#123;a: <span class="string">"yes"</span>&#125;) <span class="comment">// ok, default b = 0</span></span><br><span class="line">f() <span class="comment">// ok, default to &#123;a: ""&#125;, which then defaults b = 0</span></span><br><span class="line">f(&#123;&#125;) <span class="comment">// error, 'a' is required if you supply an argument</span></span><br></pre></td></tr></table></figure><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keepWholeObject</span>(<span class="params">wholeObject: &#123;a: <span class="built_in">string</span>, b?: <span class="built_in">number</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;a, b = <span class="number">1001</span>&#125; = wholeObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组类型允许表示一个已知元素数量和类型的数组，访问和数组一样</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>]; </span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举类型，默认情况下，从0开始为元素编号</span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>]; <span class="comment">// 由枚举的值得到它的名字</span></span><br></pre></td></tr></table></figure><h5 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意值</span></span><br><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">"maybe a string instead"</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn't check)</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">"free"</span>];</span><br></pre></td></tr></table></figure><h5 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空值，某种程度上来说，void类型像是与any类型相反，它表示没有任何类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明一个void类型的变量没有什么大用，因为只能为它赋予undefined和null</span></span><br><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h5 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined和null两者各自有自己的类型分别叫做undefined和null</span></span><br><span class="line"><span class="comment">// 默认情况下null和undefined是所有类型的子类型，如可以把null和undefined赋值给number类型的变量</span></span><br><span class="line"><span class="comment">// 若指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h5 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h5><p>never类型表示<strong>永不存在的值的类型</strong>，如那些<strong>总是会抛出异常</strong>或<strong>根本就不会有返回值的函数表达式或箭头函数</strong>表达式的返回值类型，<strong>变量也可能是never类型</strong>，当其<strong>被永不为真的类型保护所约束时</strong>，never类型<strong>是任何类型的子类型</strong>，也<strong>可以赋值给任何类型</strong>，但<strong>没有类型是never的子类型或可赋值给never类型</strong>，<strong>即使<code>any</code>也不可以</strong>赋值给never</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h5><p>类型断言好比其它语言里的<strong>类型转换</strong>，但是<strong>不进行特殊的数据检查和解构</strong>，没有运行时的影响，<strong>只是在编译阶段起作用</strong>，可以使用尖<strong>括号<code>&lt;&gt;</code></strong>或<strong><code>as</code></strong>语法来实现断言；当在TypeScript里使用<strong><code>JSX</code></strong>时，只有<code>as</code>语法断言是被允许的；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求labelledObj对象参数有一个名为label类型为string的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: &#123; label: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myObj = &#123; size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span> &#125;;</span><br><span class="line">printLabel(myObj);</span><br><span class="line"><span class="comment">// 使用接口来描述：必须包含一个label属性且类型为string</span></span><br><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h5><p>接口里的属性不全都是必需的，有些是只在某些条件下存在，或者根本不存在，在<strong>可选属性名字定义的后面</strong>加一个<strong><code>?</code>符号</strong>，可以<strong>对可能存在的属性进行预定义</strong>，可以<strong>捕获引用了不存在的属性时的错误</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的&#123;color: string; area: number&#125;是返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123;color: <span class="built_in">string</span>; area: <span class="built_in">number</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">let</span> newSquare = &#123;color: <span class="string">"white"</span>, area: <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">        newSquare.color = config.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">        newSquare.area = config.width * config.width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;color: <span class="string">"black"</span>&#125;);</span><br></pre></td></tr></table></figure><h5 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h5><p>对象属性只能在对象刚刚创建的时候修改其值，对于<strong>数组</strong>，TypeScript提供<strong><code>ReadonlyArray&lt;T&gt;</code>类型</strong>其与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保<strong>数组创建后再也不能被修改</strong>；<strong>也不可以把整个<code>ReadonlyArray</code>赋值到一个普通数组</strong>，但可以用类型断言重写；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    readonly x: <span class="built_in">number</span>;</span><br><span class="line">    readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1: Point = &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">// 断言重写</span></span><br><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><h5 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error: 'colour' not expected in type 'SquareConfig'</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言绕开检查</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; width: <span class="number">100</span>, opacity: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个字符串索引签名</span></span><br><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将这个对象赋值给一个另一个变量：因为squareOptions不会经过额外属性检查，所以编译器不会报错</span></span><br><span class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>接口也可以描述<strong>函数类型</strong>，为了使用接口表示函数类型，需要<strong>给接口定义一个调用签名</strong>，它就像是一个<strong>只有参数列表</strong>和<strong>返回值类型</strong>的<strong>函数定义</strong>，参数列表里的<strong>每个参数</strong>都需要<strong>名字</strong>和<strong>类型</strong>；定义后就可以像使用其它接口一样使用这个函数类型的接口，然后<strong>创建一个函数类型的变量</strong>，并<strong>将一个同类型的函数赋值给该变量</strong>。对于<strong>函数类型</strong>的类型检查来说，<strong>函数的参数名不需要与接口里定义的名字相匹配</strong>，要求<strong>对应位置</strong>上的<strong>参数类型是兼容</strong>的；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h5><p>可以描述那些<strong>能够通过索引得到的类型</strong>，如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>，<strong>可索引类型</strong>具有一个<strong>索引签名</strong>，它描述了<strong>对象索引的类型</strong>，还有<strong>相应的索引返回值类型</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>共有支持<strong>字符串</strong>和<strong>数字</strong>两种索引签名，可<strong>同时</strong>使用两种类型的索引，但是<strong>数字索引</strong>的返回值必须是<strong>字符串索引返回值类型的子类型</strong>，当使用<code>number</code>来索引时，会将其转换成<code>string</code>然后再去索引对象；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: indexing with a 'string' will sometimes get you a Dog!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">    [x: <span class="built_in">number</span>]: Animal;</span><br><span class="line">    [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为字符串索引声明了obj.property和obj["property"]两种形式都可以</span></span><br><span class="line"><span class="comment">// name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示</span></span><br><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">    length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">    name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型不是索引类型的子类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">    readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">"Alice"</span>, <span class="string">"Bob"</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">"Mallory"</span>; <span class="comment">// error! 因为索引签名是只读的</span></span><br></pre></td></tr></table></figure><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><p>接口描述了<strong>类的公共部分</strong>，<strong>而不是公共和私有两部分</strong>，其<strong>不会检查类是否具有某些私有成员</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态部分和实例部分"><a href="#静态部分和实例部分" class="headerlink" title="静态部分和实例部分"></a>静态部分和实例部分</h5><p>类是具有<strong>静态部分类型</strong>和<strong>实例的类型</strong>两个类型，当<strong>用构造器签名去定义一个接口</strong>并试图定义一个类去实现这个接口时会得到一个错误，当一个类实现了一个接口时，<strong>只对其实例部分进行类型检查</strong>，<strong><code>constructor</code></strong>存在于类的<strong>静态部分</strong>，不在检查的范围内；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)中会检查AnalogClock是否符合构造函数签名；<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    tick();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor: ClockConstructor, hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span></span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    tick() &#123;<span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    tick() &#123;<span class="built_in">console</span>.log(<span class="string">"tick tock"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure></p><h5 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h5><p>接口也可以相互扩展，能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里，<strong>一个接口可继承多个接口</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h5 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h5><p>一个接口可以同时做为函数和对象使用，并带有额外的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    interval: <span class="built_in">number</span>;</span><br><span class="line">    reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;;</span><br><span class="line">    counter.interval = <span class="number">123</span>;</span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h5 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h5><p>当<strong>接口继承</strong>了一个<strong>类</strong>时，<strong>它会继承类的成员但不包括其实现</strong>，就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样，接口同样会继承到类的private和protected成员，创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    greeting: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>构造函数的派生类必须调用<strong><code>super()</code></strong>，它会<strong>执行基类的构造方法</strong>，<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">    move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123; <span class="comment">// 0是默认参数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Snake <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="keyword">super</span>(name); &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">5</span>) &#123; <span class="comment">//重写父类的方法，5是默认参数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Slithering..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Horse <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="keyword">super</span>(name); &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">45</span>) &#123; <span class="comment">// 重写父类的方法，45是默认参数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Galloping..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">"Sammy the Python"</span>);</span><br><span class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">"Tommy the Palomino"</span>);</span><br><span class="line">sam.move();</span><br><span class="line">tom.move(<span class="number">34</span>);</span><br></pre></td></tr></table></figure></p><p><strong>成员都默认为<code>public</code></strong>，也可以明确的将一个成员标记成<code>public</code>，当成员被标记成<code>private</code>时，它就<strong>不能在声明它的类的外部访问</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">"Cat"</span>).name; <span class="comment">// Error: 'name' is private;</span></span><br></pre></td></tr></table></figure><p>TypeScript使用的是结构性类型系统，若所有成员的类型都是兼容的，则认为它们的类型是兼容的；若一个类型里包含一个<code>private</code>或<code>protected</code>成员，则只有当另外一个类型中也存在这样一个<code>private</code>成员， 且它们都是来自同一处声明时，才认为这两个类型兼容；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123; <span class="keyword">super</span>(<span class="string">"Rhino"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Goat"</span>);</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; <span class="comment">// Error: Animal and Employee are not compatible</span></span><br></pre></td></tr></table></figure><p><code>protected</code>成员<strong>在派生类中仍然可以访问</strong>，<strong>构造函数</strong>也可以被标记成<code>protected</code>，意味着该类不能在包含它的类外被实例化，但能被继承；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Employee can extend Person</span></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>); <span class="comment">// Error: The 'Person' constructor is protected</span></span><br></pre></td></tr></table></figure><p>可以使用<code>readonly</code>关键字将属性设置为只读的。 只读属性<strong>必须在声明时</strong>或<strong>构造函数里被初始化</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dad = <span class="keyword">new</span> Octopus(<span class="string">"Man with the 8 strong legs"</span>);</span><br><span class="line">dad.name = <span class="string">"Man with the 3-piece suit"</span>; <span class="comment">// error! name is readonly.</span></span><br></pre></td></tr></table></figure><h5 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h5><p>参数属性可以方便地<strong>在一个地方定义并初始化一个成员</strong>，仅在构造函数里使用<code>private name: string</code>参数来创建和初始化<code>name</code>成员，<strong>把声明和赋值合并至一处</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123; &#125; <span class="comment">// 定义并初始化成员name</span></span><br><span class="line">    move(distanceInMeters: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h5><p>TypeScript支持通过getters/setters来截取对对象成员的访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">"secret passcode"</span>;</span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">"secret passcode"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Error: Unauthorized update of employee!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    alert(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h5><p>静态成员属性<strong>存在于类本身上</strong>而不是类的实例上，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Grid &#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;;</span><br><span class="line">    calculateDistanceFromOrigin(point: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>;&#125;) &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = (point.x - Grid.origin.x);</span><br><span class="line">        <span class="keyword">let</span> yDist = (point.y - Grid.origin.y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> scale: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>);  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>);  <span class="comment">// 5x scale</span></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;x: <span class="number">10</span>, y: <span class="number">10</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;x: <span class="number">10</span>, y: <span class="number">10</span>&#125;));</span><br></pre></td></tr></table></figure><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类做为其它派生类的基类使用，一般不会直接被实例化，抽象类可以包含成员的实现细节，<code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。抽象类中的抽象方法不包含<strong>具体实现并且必须在派生类中实现</strong>，抽象方法的<strong>语法与接口方法相似</strong>，两者都是<strong>定义方法签名</strong>但不包含方法体，抽象方法必须包含<code>abstract</code>关键字并且<strong>可以包含访问修饰符</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Department &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    printName(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Department name: '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span>; <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> AccountingDepartment <span class="keyword">extends</span> Department &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'Accounting and Auditing'</span>); <span class="comment">// constructors in derived classes must call super()</span></span><br><span class="line">    &#125;</span><br><span class="line">    printMeeting(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'The Accounting Department meets each Monday at 10am.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    generateReports(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Generating accounting reports...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> department: Department; <span class="comment">// ok to create a reference to an abstract type</span></span><br><span class="line">department = <span class="keyword">new</span> Department(); <span class="comment">// error: cannot create an instance of an abstract class</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment(); <span class="comment">// ok to create and assign a non-abstract subclass</span></span><br><span class="line">department.printName();</span><br><span class="line">department.printMeeting();</span><br><span class="line">department.generateReports(); <span class="comment">// error: method doesn't exist on declared abstract type</span></span><br></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>当调用<code>new</code>并执行了这个函数后，便会得到一个类的实例，这个构造函数也包含了类的所有静态属性，使用<code>typeof Greeter</code>意思是取Greeter类的类型，而不是实例的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    <span class="keyword">static</span> standardGreeting = <span class="string">"Hello, there"</span>;</span><br><span class="line">    greeting: <span class="built_in">string</span>;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.greeting) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Greeter.standardGreeting;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter1: Greeter; <span class="comment">// 被赋值为构造函数</span></span><br><span class="line">greeter1 = <span class="keyword">new</span> Greeter();</span><br><span class="line"><span class="built_in">console</span>.log(greeter1.greet());</span><br><span class="line"><span class="keyword">let</span> greeterMaker: <span class="keyword">typeof</span> Greeter = Greeter;</span><br><span class="line">greeterMaker.standardGreeting = <span class="string">"Hey there!"</span>;</span><br><span class="line"><span class="keyword">let</span> greeter2: Greeter = <span class="keyword">new</span> greeterMaker();</span><br><span class="line"><span class="built_in">console</span>.log(greeter2.greet());</span><br></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>可给每个参数<strong>添加类型</strong>再为函数本身添加<strong>返回值类型</strong>，TypeScript能够<strong>根据返回语句自动推断出返回值类型</strong>，因此通常省略返回值类型；只要参数类型是匹配的就认为它是有效的函数类型，而不在乎参数名是否正确；在函数和返回值类型之前使用<strong><code>=&gt;</code>符号</strong>指定<strong>返回值类型</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x+y; &#125;;</span><br><span class="line"><span class="comment">// 写出完整函数类型</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x+y; &#125;;</span><br><span class="line"><span class="comment">// 在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue:<span class="built_in">number</span>, increment:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><p>JavaScript中每个参数<strong>都是可选</strong>的，可传可不传，没传参时其值是<strong><code>undefined</code></strong>，在TypeScript中可在参数名旁使用<strong><code>?</code></strong>实现<strong>可选参数</strong>的功能，<strong>可选参数必须跟在必须参数后面</strong>；且可为参数提供一个<strong>默认值</strong>当用户<strong>没有传递该参数</strong>或<strong>传递的值是<code>undefined</code>时</strong>默认值生效，也叫<strong>有默认初始化值的参数</strong>；在所有必须参数后面的<strong>带默认初始化的参数都是可选的</strong>；带默认值的参数不需要放在必须参数的后面；若带默认值的参数出现在必须参数前面，用户必须<strong>明确的传入<code>undefined</code>值来获得默认值</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = "Smith"</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);                  <span class="comment">// works correctly now, returns "Bob Smith"</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="literal">undefined</span>);       <span class="comment">// still works, also returns "Bob Smith"</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// ah, just right</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName = "Will", lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="literal">undefined</span>, <span class="string">"Adams"</span>);     <span class="comment">// okay and returns "Will Adams"</span></span><br></pre></td></tr></table></figure><p>若想同时操作多个参数，或不知道会有多少参数传递进来，在JavaScript里可通过<code>arguments</code>来访问所有传入的参数，在TypeScript中可<strong>把所有参数收集到一个变量</strong>；<strong>剩余参数</strong>会被当做<strong>个数不限的可选参数</strong>；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">"Joseph"</span>, <span class="string">"Samuel"</span>, <span class="string">"Lucas"</span>, <span class="string">"MacKinzie"</span>);</span><br></pre></td></tr></table></figure><p>JavaScript中<strong><code>this</code>的值</strong>在<strong>函数被调用时才会指定</strong>，TypeScript中<strong>箭头函数</strong>能保存<strong>函数创建时的<code>this</code>值</strong>，<strong>而不是调用时的值</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">    suit: <span class="built_in">string</span>;</span><br><span class="line">    card: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">    suits: <span class="built_in">string</span>[];</span><br><span class="line">    cards: <span class="built_in">number</span>[];</span><br><span class="line">    createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// return function() &#123; // this在函数调用时指定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// this在函数创建时就指定了</span></span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker(); <span class="comment">// 若不是实用箭头函数，这里调用this为Window对象</span></span><br></pre></td></tr></table></figure><p>this参数在回调函数中，<code>this: void</code>表示<code>addClickListener</code>期望<code>onclick</code>是一个<strong>不需要<code>this</code>类型的函数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">    addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">    info: <span class="built_in">string</span>;</span><br><span class="line">    onClickBad(<span class="keyword">this</span>: Handler, e: Event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = e.message;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;[]</span>): <span class="title">number</span></span>; <span class="comment">// 重载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;;   <span class="comment">// 重载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123; <span class="comment">// 注意这并不是重载列表的一部分</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;, &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;, &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;code&gt;TypeScript&lt;/code&gt;&lt;/strong&gt;是由&lt;strong&gt;微软&lt;/strong&gt;开发的&lt;strong&gt;自由&lt;/strong&gt;和&lt;strong&gt;开源&lt;/strong&gt;的编程语言&lt;strong&gt;是JavaScript的一个超集&lt;/str
      
    
    </summary>
    
      <category term="语言" scheme="https://yaoyinglong.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="前端" scheme="https://yaoyinglong.github.io/categories/%E8%AF%AD%E8%A8%80/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="TypeScript" scheme="https://yaoyinglong.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AF%AD%E8%A8%80/%E5%89%8D%E7%AB%AF/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/语言/前端/JavaScript基础/</id>
    <published>2022-09-03T16:00:00.000Z</published>
    <updated>2022-09-06T15:51:13.996Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript能够以不同方式显示数据：使用<strong><code>window.alert()</code>写入警告框</strong>、使用<strong><code>document.write()</code>写入HTML输出</strong>（在HTML文档完全加载后使用<strong><code>document.write()</code></strong>将删除所有已有的HTML）、使用<strong><code>innerHTML</code>写入HTML元素</strong>、使用<strong><code>console.log()</code>写入浏览器控制台</strong>;</p><p>使用<code>var</code>关键词来声明变量，所有JavaScript标识符<strong>对大小写敏感</strong>，容易申明变量未赋值则其值是<strong><code>undefined</code></strong>，若再次声明某JavaScript变量，其值不会丢失，<strong><code>var</code>关键字</strong>声明的变量<strong>没有块作用域</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">"porsche"</span>;</span><br><span class="line"><span class="keyword">var</span> carName; <span class="comment">// 此时carName值还是porsche</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************全局作用域**********************/</span></span><br><span class="line"><span class="keyword">var</span> carName = <span class="string">"porsche"</span>;</span><br><span class="line"><span class="comment">// 此处的代码可以使用 carName</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处的代码也可以使用 carName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************var声明的变量没有块作用域**********************/</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处可以使用 x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************函数作用域**********************/</span></span><br><span class="line"><span class="comment">// 此处的代码不可以使用 carName</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> carName = <span class="string">"porsche"</span>;</span><br><span class="line">  <span class="comment">// code here CAN use carName</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处的代码不可以使用 carName</span></span><br></pre></td></tr></table></figure><p>使用<code>var</code>关键字<strong>重新声明变量</strong>会带来问题，<strong>在块中重新声明变量</strong>也<strong>将重新声明块外的变量</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 此处 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 此处 x 为 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处 x 为 6</span></span><br></pre></td></tr></table></figure><p><strong><code>ES2015</code></strong>引入了<strong><code>let</code>关键字</strong>用于<strong>定义块作用域</strong>的<strong>变量</strong>和<strong><code>const</code>关键字</strong>用于定义<strong>块作用域</strong>的<strong>常量</strong>； <code>const</code>定义的变量与<code>let</code>变量类似但<strong>不能重新赋值</strong>，<strong><code>const</code>没有定义常量值其定义了对值的常量引用</strong>，不能更改常量原始值，但<strong>可以更改常量对象的属性</strong>；在<strong>函数内声明变量</strong>和<strong>在块外声明变量</strong>时使用<strong><code>var</code></strong>和<strong><code>let</code></strong>很相似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处不可以使用 x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 此处 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 此处 x 为 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处 x 为 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 一些语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处 i 为 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建const对象：</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">"porsche"</span>, <span class="attr">model</span>:<span class="string">"911"</span>, <span class="attr">color</span>:<span class="string">"Black"</span>&#125;;</span><br><span class="line"><span class="comment">// 可以更改属性</span></span><br><span class="line">car.color = <span class="string">"White"</span>;</span><br><span class="line"><span class="comment">// 可以添加属性</span></span><br><span class="line">car.owner = <span class="string">"Bill"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建常量数组</span></span><br><span class="line"><span class="keyword">const</span> cars = [<span class="string">"Audi"</span>, <span class="string">"BMW"</span>, <span class="string">"porsche"</span>];</span><br><span class="line"><span class="comment">// 可以更改元素</span></span><br><span class="line">cars[<span class="number">0</span>] = <span class="string">"Honda"</span>;</span><br><span class="line"><span class="comment">// 可以添加元素</span></span><br><span class="line">cars.push(<span class="string">"Volvo"</span>);</span><br></pre></td></tr></table></figure><p>使用JavaScript的情况下全局作用域是JavaScript环境，<strong>在<code>HTML</code>中全局作用域是<code>window</code>对象</strong>，通过<code>var</code>关键词定义的<strong>全局变量</strong>属于<strong><code>window</code></strong>对象，通过<code>let</code>关键词定义的全局变量<strong>不属于<code>window</code>对象</strong>，在<strong>相同作用域</strong>或<strong>相同块</strong>中，<strong>不允许</strong>通过<code>let</code>重新声明一个<code>var</code>变量，且<strong>不允许</strong>通过<code>let</code>重新声明一个<code>let</code>变量，且<strong>不允许</strong>通过<code>var</code>重新声明一个<code>let</code>变量，在<strong>不同作用域</strong>或<strong>块</strong>中<strong>允许</strong>通过<code>let</code>重新声明变量；<strong>同一作用域</strong>或<strong>块</strong>中，<strong>不允许</strong>将已有的 <code>var</code> 或 <code>let</code> 变量重新声明或重新赋值给 <code>const</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">"Audi"</span>;</span><br><span class="line"><span class="comment">// 此处的代码能够使用 window.carName</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carName = <span class="string">"porsche"</span>;</span><br><span class="line"><span class="comment">// 此处的代码不可使用 window.carName</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;      <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">6</span>;       <span class="comment">// 不允许</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;    <span class="comment">// 允许</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">6</span>;     <span class="comment">// 不允许</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;       <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">6</span>;        <span class="comment">// 不允许</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;   <span class="comment">// 允许</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">6</span>;    <span class="comment">// 不允许</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;       <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">6</span>;        <span class="comment">// 不允许</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;   <span class="comment">// 允许</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">6</span>;    <span class="comment">// 不允许</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">6</span>;       <span class="comment">// 允许</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">7</span>;   <span class="comment">// 允许</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">8</span>;   <span class="comment">// 允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>var</code>声明的变量会<strong>提升到顶端</strong>，即可以在声明变量之前就使用它，通过<code>let</code>定义的变量<strong>不会被提升到顶端</strong>，在声明<code>let</code>变量之前就使用它会导致<strong><code>ReferenceError</code></strong>，变量从块的开头一直处于<strong>暂时死区</strong>直到<strong>声明为止</strong>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">carName = <span class="string">"Volvo"</span>;<span class="comment">// 在此处可以使用 carName</span></span><br><span class="line"><span class="keyword">var</span> carName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此处不可以使用 carName</span></span><br><span class="line"><span class="keyword">let</span> carName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此处不可以使用 carName</span></span><br><span class="line"><span class="keyword">const</span> carName = <span class="string">"Volvo"</span>;</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><strong><code>==</code></strong>：等于</li><li><strong><code>===</code></strong>：<strong>等值等型</strong></li><li><strong><code>!=</code></strong>：不等于</li><li><strong><code>!==</code></strong>：<strong>不等值或不等型</strong></li><li><strong><code>typeof</code></strong>：返回<strong>变量的类型</strong></li><li><strong><code>instanceof</code></strong>：若<strong>对象是对象类型的实例</strong>返回true</li><li><code>**</code>：幂，属于ECMAScript 2016 proposal (ES7) 实验部分，<strong>跨浏览器表现并不稳定</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> z = x ** <span class="number">2</span>;   <span class="comment">// 结果是 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的次序会产生不同的结果</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">911</span> + <span class="number">7</span> + <span class="string">"Porsche"</span>; <span class="comment">// 918Porsche</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"Porsche"</span> + <span class="number">911</span> + <span class="number">7</span>; <span class="comment">// Porsche9117</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超大或超小的数值可以用科学计数法</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">123e5</span>;      <span class="comment">// 12300000</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="number">123e-5</span>;     <span class="comment">// 0.00123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有值的变量，其值是undefined，typeof也返回undefined</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="number">7</span>)            <span class="comment">// 返回 "number"</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="number">7</span> + <span class="number">8</span>)        <span class="comment">// 返回 "number"</span></span><br><span class="line">person = <span class="literal">undefined</span>;   <span class="comment">// 值是 undefined，类型是 undefined</span></span><br><span class="line"><span class="comment">// null 的数据类型是对象</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="literal">null</span>;    <span class="comment">// 值是 null，但是类型仍然是对象</span></span><br><span class="line"><span class="comment">// Undefined与null的值相等，但类型不相等</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>              <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>                   <span class="comment">// object</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>            <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>             <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>typeof</code>运算符可返回<strong><code>string</code></strong>、<strong><code>number</code></strong>、<strong><code>boolean</code></strong>、<strong><code>undefined</code></strong>四种<strong>原始类型</strong>之一，可返回<strong><code>function</code></strong>、<strong><code>object</code></strong>两种<strong>复杂数据类型</strong>，把<strong>对象</strong>、<strong>数组</strong>或<strong><code>null</code></strong>返回<code>object</code>，但不会把函数返回<code>object</code>；</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (x == y) 为 true，因为 x 和 y 的值相等</span></span><br><span class="line"><span class="comment">// (x === y) 为 false，因为 x 和 y 的类型不同（字符串与对象）</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"Bill"</span>;             </span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (x === y) 为 false，因为 x 和 y 是不同的对象</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>);             </span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Bill"</span>);</span><br><span class="line"></span><br><span class="line">str = <span class="string">"Please visit Microsoft!"</span>;</span><br><span class="line"><span class="keyword">var</span> n = str.replace(<span class="regexp">/MICROSOFT/i</span>, <span class="string">"W3School"</span>); <span class="comment">// 大小写不敏感的替换</span></span><br><span class="line"><span class="keyword">var</span> n = str.replace(<span class="regexp">/Microsoft/g</span>, <span class="string">"W3School"</span>); <span class="comment">// 替换所有匹配</span></span><br><span class="line">str.indexOf(<span class="string">"vis"</span>, <span class="number">15</span>)    <span class="comment">// 第二个参数作为搜索的开始位置</span></span><br><span class="line">str.lastIndexOf(<span class="string">"vis"</span>, <span class="number">15</span>)    <span class="comment">// 第二个参数作为搜索的开始位置</span></span><br></pre></td></tr></table></figure><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul><li><p>length：返回字符串的长度</p></li><li><p>indexOf：返回字符串中指定文本<strong>首次</strong>出现的<strong>索引位置</strong>，无法设置更强大的搜索值，若正则表达式</p></li><li><p>lastIndexOf：返回指定文本在字符串中<strong>最后</strong>一次出现的索引位置，从末尾到开头</p></li><li><p>search：搜索特定值的字符串，并返回匹配的位置，无法设置第二个开始位置参数</p></li><li><p>slice(start, end)：提取字符串的某个部分并在新字符串中返回被提取的部分</p></li><li><p>substring(start, end)：同slice，无法接受负的索引</p></li><li><p>substr(start, length)：同slice，第二个参数规定被提取部分的<strong>长度</strong></p></li><li><p>replace：用另一个值替换在字符串中指定的值，使用正则表达式<strong><code>/i</code></strong>执行<strong>大小写不敏感的替换</strong></p></li><li><p>toLowerCase：把字符串转换为小写</p></li><li><p>trim：删除字符串两端的空白符，Internet Explorer 8或更低版本不支持<code>trim()</code>方法</p></li><li><p>charAt：返回字符串中指定下标位置的字符串</p></li><li><p>charCodeAt：回字符串中指定索引的字符unicode编码</p></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>没有<strong><code>()</code></strong>的函数将<strong>返回函数定义</strong>，在函数定义中<strong><code>this</code></strong>引用<strong>该函数的拥有者</strong>，方法实际上是<strong>以属性值</strong>的形式<strong>存储的函数定义</strong>，通过关键词<strong><code>new</code></strong>来声明变量，则该变量会<strong>被创建为对象</strong>，<strong>请避免字符串、数值或逻辑对象</strong>，会增加代码的复杂性并降低执行速度；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">String</span>();        <span class="comment">// 把 x 声明为 String 对象</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Number</span>();        <span class="comment">// 把 y 声明为 Number 对象</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="built_in">Boolean</span>();       <span class="comment">//把 z 声明为 Boolean 对象</span></span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><table><thead><tr><th style="text-align:left">事件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">onchange</td><td style="text-align:left">HTML元素已被改变</td></tr><tr><td style="text-align:left">onclick</td><td style="text-align:left">用户点击了HTML元素</td></tr><tr><td style="text-align:left">onmouseover</td><td style="text-align:left">用户把鼠标移动到HTML元素上</td></tr><tr><td style="text-align:left">onmouseout</td><td style="text-align:left">用户把鼠标移开HTML元素</td></tr><tr><td style="text-align:left">onkeydown</td><td style="text-align:left">用户按下键盘按键</td></tr><tr><td style="text-align:left">onload</td><td style="text-align:left">浏览器已经完成页面加载</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript能够以不同方式显示数据：使用&lt;strong&gt;&lt;code&gt;window.alert()&lt;/code&gt;写入警告框&lt;/strong&gt;、使用&lt;strong&gt;&lt;code&gt;document.write()&lt;/code&gt;写入HTML输出&lt;/strong&gt;（在HTML文
      
    
    </summary>
    
      <category term="语言" scheme="https://yaoyinglong.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="前端" scheme="https://yaoyinglong.github.io/categories/%E8%AF%AD%E8%A8%80/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://yaoyinglong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>IO流</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AF%AD%E8%A8%80/CPP/IO%E6%B5%81/"/>
    <id>https://yaoyinglong.github.io/Blog/语言/CPP/IO流/</id>
    <published>2022-08-25T16:00:00.000Z</published>
    <updated>2022-08-26T14:54:39.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong>流</strong>是<strong>一连串连续不断</strong>的<strong>数据集合</strong></p><ul><li><strong>输入流</strong>：从<strong>输入设备</strong>流向<strong>内存</strong>的流</li><li><strong>输出流</strong>：从<strong>内存</strong>流向<strong>输出设备</strong>的流</li></ul><p>输入&amp;输出流类：</p><p><img src="../../../../../images/语言/CPP/CPP IO流类关系.png" alt></p><ul><li><strong><code>iostream</code></strong>：<ul><li><strong><code>istream</code></strong>：用于<strong>输入的流类</strong>，<strong><code>cin</code></strong>就是该类的对象</li><li><strong><code>ostream</code></strong>：用于<strong>输出的流类</strong>，<strong><code>cout</code></strong>就是该类的对象</li><li><strong><code>iostream</code></strong>：既能<strong>用于输入</strong>，又能<strong>用于输出</strong>的类</li></ul></li><li><strong><code>fstream</code></strong>：<ul><li><strong><code>ifstream</code></strong>：用于<strong>从文件读取数据的类</strong></li><li><strong><code>ofstream</code></strong>：用于<strong>向文件写入数据的类</strong></li><li><strong><code>fstream</code></strong>：既能<strong>从文件读取数据</strong>，又能<strong>向文件写入数据</strong>的类</li></ul></li><li><strong><code>strstream</code></strong>：<ul><li><strong><code>istrstream</code></strong>：用于<strong>输入字符串</strong>的类</li><li><strong><code>ostrstream</code></strong>：用于<strong>输出字符串</strong>的类</li><li><strong><code>strstream</code></strong>：既能<strong>用于字符串输入</strong>，又能<strong>用于字符串输出</strong>的类</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;流&lt;/strong&gt;是&lt;strong&gt;一连串连续不断&lt;/strong&gt;的&lt;strong&gt;数据集合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入流&lt;/strong&gt;：从&lt;strong&gt;输入设备&lt;/strong&gt;流向&lt;strong&gt;内存&lt;/s
      
    
    </summary>
    
      <category term="语言" scheme="https://yaoyinglong.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="CPP" scheme="https://yaoyinglong.github.io/categories/%E8%AF%AD%E8%A8%80/CPP/"/>
    
    
      <category term="C++" scheme="https://yaoyinglong.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Shell基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/Linux/Shell%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/Linux/Shell基础/</id>
    <published>2022-07-30T16:00:00.000Z</published>
    <updated>2022-08-01T14:48:16.748Z</updated>
    
    <content type="html"><![CDATA[<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>定义变量时等号两边不能有空格，定义shell脚本时开头一定要以<strong><code>#!/bin/bash</code></strong>开头</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 注意："="号两边不能有空格</span><br><span class="line">demo="hello world"</span><br><span class="line"><span class="meta">#</span> 在终端输出变量demo，也就是hello world</span><br><span class="line">echo $demo</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>使用<strong>括号<code>()</code></strong>来定义数组，且数组元素通过<strong>空格</strong>来分割</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 一对括号表示是数组，数组元素用“空格”符号分割开。</span><br><span class="line">a=(1 2 3 4 5)</span><br><span class="line"><span class="meta">#</span> 用$&#123;#数组名[@或*]&#125; 可以得到数组长度</span><br><span class="line">echo $&#123;#a[@]&#125;</span><br><span class="line">echo $&#123;#a[*]&#125;</span><br><span class="line"><span class="meta">#</span> 用$&#123;数组名[@或*]&#125;可以得到整个数组内容</span><br><span class="line">echo $&#123;a[@]&#125;</span><br><span class="line">echo $&#123;a[*]&#125;</span><br><span class="line"><span class="meta">#</span> 用$&#123;数组名[下标]&#125; 可以得到指定下标的值，下标是从0开始</span><br><span class="line">echo $&#123;a[2]&#125;</span><br></pre></td></tr></table></figure><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>直接通过<strong>数组名[下标]</strong>，就可以对其进行引用赋值，若下标不存在，则自动<strong>追加数组元素末尾</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=(1 2 3 4 5)</span><br><span class="line"><span class="meta">#</span> 直接通过数组名[下标]，就可以对其进行引用赋值</span><br><span class="line">a[1]=100</span><br><span class="line"><span class="meta">#</span> 若下标不存在，自动添加新一个数组元素</span><br><span class="line">a[1000]=1000</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>通过<strong><code>unset</code> 数组[下标]</strong>即可<strong>清除数组相应下标的元素</strong>，<strong><code>unset</code> 数组</strong>清楚<strong>整个数组</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=(1 2 3 4 5)</span><br><span class="line"><span class="meta">#</span> unset 数组[下标] 可以清除相应的元素</span><br><span class="line">unset a[1]</span><br><span class="line"><span class="meta">#</span> unset 数组[下标] 不带下标，清除整个数据。</span><br><span class="line">unset a</span><br></pre></td></tr></table></figure><h5 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h5><p>如下从下标0开始，截取长度为3，<strong>切片原先数组返回中间用空格分割的字符串</strong>，若将结果加上<strong>括号<code>()</code></strong>即可产生新的数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=(1 2 3 4 5)</span><br><span class="line"><span class="meta">#</span> 截取数组 $&#123;数组名[@或*]:起始位置:长度&#125;，从下标0开始，截取长度为3，切片原先数组，返回是字符串，中间用“空格”分开</span><br><span class="line">echo $&#123;a[@]:0:3&#125;</span><br><span class="line"><span class="meta">#</span> 如果加上”()”，将得到切片数组，c 就是一个新数组</span><br><span class="line">c=($&#123;a[@]:1:4&#125;)</span><br></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p>该操作不会改变原先数组内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=(1 2 3 4 5)</span><br><span class="line"><span class="meta">#</span> $&#123;数组名[@或*]/查找字符/替换字符&#125; 该操作不会改变原先数组内容</span><br><span class="line">echo $&#123;a[@]/3/100&#125;</span><br><span class="line"><span class="meta">#</span> 如果需要修改，重新赋值给变量a</span><br><span class="line">a=($&#123;a[@]/3/100&#125;)</span><br></pre></td></tr></table></figure><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><h5 id="ifelse"><a href="#ifelse" class="headerlink" title="ifelse"></a>ifelse</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 打印终端命令行的所有参数</span><br><span class="line">echo $*;</span><br><span class="line"><span class="meta">#</span> 打印终端命令行的所有参数的个数</span><br><span class="line">echo $#;</span><br><span class="line"><span class="meta">#</span> 如果终端命令行的所有参数的个数小于3，就输出所有参数</span><br><span class="line">if [ $# -lt 3 ]; then</span><br><span class="line">    echo $*;</span><br><span class="line">else</span><br><span class="line">    echo $0;</span><br><span class="line">    echo "参数过多不在控制台显示";</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="case"><a href="#case" class="headerlink" title="case"></a>case</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">    start | begin)</span><br><span class="line">        echo "start something"  </span><br><span class="line">    ;;</span><br><span class="line">    stop | end)</span><br><span class="line">        echo "stop something"  </span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">        echo "Ignorant"  </span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select ch in "begin" "end" "exit"; do</span><br><span class="line">    case $ch in</span><br><span class="line">        "begin")</span><br><span class="line">            echo "start something"  </span><br><span class="line">        ;;</span><br><span class="line">        "end")</span><br><span class="line">            echo "stop something"  </span><br><span class="line">        ;;</span><br><span class="line">        "exit")</span><br><span class="line">            echo "exit"  </span><br><span class="line">            break;</span><br><span class="line">        ;;</span><br><span class="line">        *)</span><br><span class="line">            echo "Ignorant"  </span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">i=10;</span><br><span class="line">while [[ $i -gt 5 ]]; do</span><br><span class="line">    echo $i;</span><br><span class="line">    ((i--));</span><br><span class="line">done;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 循环读取/etc/hosts文件内容</span><br><span class="line">while read line; do</span><br><span class="line">    echo $line;</span><br><span class="line">done &lt; /etc/hosts;</span><br></pre></td></tr></table></figure><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for((i=1;i&lt;=10;i++)); do</span><br><span class="line">    echo $i;</span><br><span class="line">done;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> seq 10 产生 1 2 3 。。。。10空格分隔字符串</span><br><span class="line">for i in $(seq 10); do</span><br><span class="line">    echo $i;</span><br><span class="line">done;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 根据终端输入的文件名来检查当前目录该文件是否存在</span><br><span class="line">for file in $*; do</span><br><span class="line">    if [ -f "$file" ]; then</span><br><span class="line">        echo "INFO: $file exists"</span><br><span class="line">    else</span><br><span class="line">        echo "ERROR: $file not exists"</span><br><span class="line">    fi</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><h5 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=10;</span><br><span class="line">until [[ $a -lt 0 ]]; do</span><br><span class="line">    echo $a;</span><br><span class="line">    ((a--));</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>所有函数在使用前必须定义</strong>，必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可，通过<strong><code>$?</code></strong>来获得<strong>函数返回值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">    echo "Hello!";</span><br><span class="line">&#125;</span><br><span class="line">function hello_param() &#123;</span><br><span class="line">    echo "Hello $1 !";</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span> 函数调用</span><br><span class="line">hello;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 函数传参调用</span><br><span class="line">hello_param ben;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 函数文件调用，调用(包含)函数文件，点和demo_call之间有个空格</span><br><span class="line">. demo_call.sh;</span><br><span class="line"><span class="meta">#</span> 调用函数</span><br><span class="line">callFunction ben;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用unset functionname 取消载入</span><br><span class="line"><span class="meta">#</span> unset callFunction;</span><br><span class="line"><span class="meta">#</span> 因为已经取消载入，所以会出错</span><br><span class="line"><span class="meta">#</span> callFunction ben;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 参数读取的方式和终端读取参数的方式一样</span><br><span class="line"><span class="meta">#</span> 注意：$10不能获取第10个参数，因为当n&gt;=10时候，要用$(n)来获取参数。</span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo "The value of the first parameter is $1 !"</span><br><span class="line">    echo "The value of the second parameter is $2 !"</span><br><span class="line">    echo "The value of the tenth parameter is $10 !"</span><br><span class="line">    echo "The value of the tenth parameter is $&#123;10&#125; !"</span><br><span class="line">    echo "The value of the eleventh parameter is $&#123;11&#125; !"</span><br><span class="line">    echo "The amount of the parameters is $# !"</span><br><span class="line">    echo "The string of the parameters is $* !"</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo "The function is to get the sum of two numbers..."</span><br><span class="line">    echo -n "Input first number: "</span><br><span class="line">    read aNum</span><br><span class="line">    echo -n "Input another number: "</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo "The two numbers are $aNum and $anotherNum !"</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line"><span class="meta">#</span> 函数返回值在调用该函数后通过$?来获得</span><br><span class="line">echo "The sum of two numbers is $? !"</span><br></pre></td></tr></table></figure><p><strong><code>demo_call.sh</code></strong>文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">function callFunction() &#123;</span><br><span class="line">    echo "callFunction $1 !";</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;变量定义&quot;&gt;&lt;a href=&quot;#变量定义&quot; class=&quot;headerlink&quot; title=&quot;变量定义&quot;&gt;&lt;/a&gt;变量定义&lt;/h4&gt;&lt;p&gt;定义变量时等号两边不能有空格，定义shell脚本时开头一定要以&lt;strong&gt;&lt;code&gt;#!/bin/bash&lt;/code
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/Linux/"/>
    
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HTTPs协议</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/HTTPs%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/协议族/HTTPs协议/</id>
    <published>2022-07-25T16:00:00.000Z</published>
    <updated>2022-07-27T13:45:35.823Z</updated>
    
    <content type="html"><![CDATA[<p>虽然HTTP协议具有<strong>相当优秀</strong>和<strong>方便</strong>的一遍，但<strong><code>HTTP</code>协议</strong>可能存在<strong>信息窃听</strong>或<strong>身份伪装</strong>等安全问题，HTTP有如下不足：</p><ul><li>HTTP本身不具备加密功能，<strong>通信使用明文</strong>，内容<strong>可能会被窃听</strong></li><li><strong>不验证通信方的身份</strong>，因此有<strong>可能遭遇伪装</strong></li><li><strong>无法证明报文的完整性</strong>，所以有<strong>可能已遭篡改</strong></li></ul><p>按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视，<strong>即使已经过加密处理的通信</strong>，<strong>也会被窥视到通信内容</strong>，只是说若通信经过加密，就有可能让人无法破解报文信息的含义，但<strong>加密处理后的报文信息本身还是会被看到</strong>。为了防止窃听保护信息，最普及的就是加密技术。</p><p>HTTP协议中的请求和响应<strong>不会对通信方进行确认</strong>，<strong>任何人都可以发起请求</strong>，服务器只要接收到请求，<strong>不管对方是谁都会返回一个响应</strong>，这样就存在如下隐患：</p><ul><li><strong>无法确定</strong>请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器，<strong>可能是已伪装的Web服务器</strong></li><li><strong>无法确定</strong>响应返回到的客户端是否是按真实意图接收响应的那个客户端，<strong>可能是已伪装的客户端</strong></li><li><strong>无法确定</strong>正在<strong>通信的对方是否具备访问权限</strong></li><li>无法判定请求是来自何方、出自谁手</li><li><strong>即使是无意义的请求也会接收</strong>，无法阻止海量请求下的<strong><code>DoS</code>攻击</strong>即<strong><code>Denial of Service</code>拒绝服务攻击</strong></li></ul><p>HTTP协议无法证明通信报文的完整性，没有任何办法确认发出的请求和接收到的响应是前后相同的，像这样请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为<strong><code>Man-in-the-Middle attack</code>中间人攻击</strong>即<strong><code>MITM</code></strong>。  </p><p><img src="../../../../../images/网络/HTTP/MITM.png" alt></p><p>虽然可使用<strong><code>MD5</code></strong>、<strong><code>SHA-1</code></strong>等<strong>散列值校验</strong>的方法或<strong>确认文件的数字签名</strong>，来确定HTTP报文的完整性，但这些方法<strong>并不便捷可靠</strong>，提供文件下载服务的Web网站也会提供相应的以<strong><code>PGP</code></strong>即完美隐私创建的数字签名及MD5算法生成的散列值，不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件，浏览器无法自动帮用户检查，且这些方法依然无法百分百保证确认结果正确，因为若<strong><code>PGP</code></strong>和<strong><code>MD5</code></strong>本身被改写，用户是没有办法意识到的。</p><h4 id="通信加密"><a href="#通信加密" class="headerlink" title="通信加密"></a>通信加密</h4><p><strong>将通信加密</strong>，HTTP协议中没有加密机制，但可通过和<strong><code>Secure Socket Layer</code>安全套接层</strong>即<strong><code>SSL</code></strong>或<strong><code>Transport Layer Security</code>安全层传输协议</strong>即<strong><code>TLS</code></strong>的<strong>组合使用</strong>，从而加密HTTP的通信内容，与<strong><code>SSL</code></strong>组合使用的<strong><code>HTTP</code></strong>被称为<strong><code>HTTPs</code></strong>即<strong><code>HTTP Secure</code>超文本传输安全协议</strong>或<strong><code>HTTP over SSL</code></strong>。</p><p>SSL技术最初是由浏览器开发商<strong>网景通信公司</strong>率先倡导的，开发过<strong><code>SSL3.0</code>之前的版本</strong>，目前主导权已转移到<strong>Internet Engineering Task Force</strong>即<strong><code>IETF</code></strong>的Internet工程任务组，<strong><code>IETF</code></strong>以<strong><code>SSL3.0</code></strong>为基准制定了<strong><code>TLS1.0</code></strong>、 <strong><code>TLS1.1</code></strong>和<strong><code>TLS1.2</code></strong>，<strong><code>TSL</code>是以<code>SSL</code>为原型开发的协议</strong>，有时会统一称该协议为SSL，当前<strong>主流的版本</strong>是<strong><code>SSL3.0</code></strong>和<strong><code>TLS1.0</code></strong>。  </p><p><strong><code>SSL</code></strong>不仅<strong>提供加密处理</strong>，且还使用<strong>证书</strong>手段，<strong>可用于确定通信方</strong>，<strong>证书由值得信任的第三方机构颁发</strong>，用以证明服务器和客户端是实际存在的，伪造证书从技术角度来说是异常困难的一件事。SSL提供<strong>认证</strong>和<strong>加密处理</strong>及<strong>摘要功能</strong>，仅靠HTTP确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。</p><h4 id="内容加密"><a href="#内容加密" class="headerlink" title="内容加密"></a>内容加密</h4><p>将<strong>参与通信的内容本身加密</strong>，客户端需要对HTTP报文进行加密处理后再发送，且也<strong>只能加密报文主体</strong>，不能加密报文首部，为了做到有效的内容加密，前提是要求<strong>客户端和服务器同时具备加密和解密机制</strong>，但还是存在被篡改的风险。</p><h4 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h4><p><strong>数字证书</strong>是为了解决<strong>SSL协议</strong>在给客户端发送真正的公开密钥时，防止公钥被攻击者替换掉，<strong>防止中间人攻击</strong>时重新生成一套秘钥对，使得客户端与伪装服务器通信。</p><p><strong>数字证书认证机构</strong>处于客户端与服务器双方都可信赖的<strong>第三方机构</strong>的立场上，首先<strong>服务器</strong>运营人员向<strong>数字证书认证机构</strong>提出公开密钥的申请，<strong>数字证书认证机构</strong>在判明提出申请者的身份之后，<strong>对已申请的公开密钥做数字签名</strong>，然后<strong>分配该已签名的公开密钥</strong>，并将<strong>该公开密钥放入公钥证书后绑定在一起</strong>；服务器会将这份<strong>由数字证书认证机构颁发的公钥证书发送给客户端</strong>，以进行公开密钥加密方式通信；接到证书的客户端可使用数字证书认证机构的公开密钥， 对那张证书上的数字签名进行验证，一旦验证通过，则客户端便知道<strong>认证服务器的公开密钥的是真实有效的数字证书认证机构</strong>，且<strong>服务器的公开密钥是值得信赖的</strong>。</p><p>认证机关的公开密钥必须安全地转交给客户端，因此多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p><p>证书的一个作用是用来<strong>证明作为通信一方的服务器是否规范</strong>，另外一个作用是可<strong>确认对方服务器背后运营的企业是否真实存在</strong>，拥有该特<br>性的证书就是<strong><code>EV SSL</code></strong>证书即<strong><code>Extended Validation SSL Certificate</code></strong>。持有<strong><code>EV SSL</code></strong>证书的Web网站的浏览器<strong>地址栏处背景色是绿色</strong>的，且地址栏左侧会显示SSL证书中记录的<strong>组织名称</strong>以及<strong>颁发证书的认证机构名称</strong>。</p><h5 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a>客户端证书</h5><p>HTTPS中还可以使用<strong>客户端证书</strong>，以客户端证书进行客户端认证，但想获取证书时用户得自行安装客户端证书，但证书是收费的，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。且客户端证书只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性，即只要获得了安装客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限。</p><p>如果使用OpenSSL这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书，但该服务器证书在互<br>联网上不可作为证书使用。</p><p>独立构建的认证机构叫做<strong>自认证机构</strong>，由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性，值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实性。</p><h5 id="证书验证-1"><a href="#证书验证-1" class="headerlink" title="证书验证"></a>证书验证</h5><p>浏览器在发起HTTPs请求时，服务器会返回网站的SSL证书，浏览器需要对证书做一下验证：</p><ul><li>验证证书上的<strong>域名</strong>、<strong>有效期</strong>等信息是否正确</li><li>判断证书来源是否合法，<strong>每份签发证书</strong>都可以<strong>根据验证链</strong>查找到对应的<strong>根证书</strong>，<strong>操作系统</strong>和<strong>浏览器</strong>会<strong>本地存</strong>储权威机构的<strong>根证书</strong>，<strong>利用根证书可对对应机构签发证书完成来源验证</strong></li><li>与<strong><code>CA</code>服务器</strong>进行校验，<strong>判断证书是否被篡改</strong></li><li>通过<strong><code>CRL</code>证书注销列表</strong>和<strong><code>OCSP</code>在线证书状态协议</strong>，<strong>判断证书是否已吊销</strong></li></ul><h3 id="HTTPs安全通信机制"><a href="#HTTPs安全通信机制" class="headerlink" title="HTTPs安全通信机制"></a>HTTPs安全通信机制</h3><p><strong><code>HTTPs</code></strong>并非应用层的一种新协议，只是<strong><code>HTTP</code>通信接口部分</strong>用<strong><code>SSL</code></strong>和<strong><code>TLS</code></strong>协议代替而已，<strong><code>HTTP</code>是直接和<code>TCP</code>通信</strong>，当使用<strong><code>SSL</code></strong>时，则<strong><code>HTTP</code>先与<code>SSL</code>通信再由<code>SSL</code>与<code>TCP</code>通信</strong>，所谓<strong><code>HTTPs</code>其实就是身披<code>SSL</code>协议外壳的<code>HTTP</code></strong>。</p><p><img src="../../../../../images/网络/HTTP/HTTP与HTTPs.png" alt></p><p><strong><code>SSL</code>是独立于HTTP协议的</strong>，不光是HTTP协议，其他运行在应用层的<strong><code>SMTP</code></strong>和<strong><code>Telnet</code></strong>等协议<strong>均可配合<code>SSL</code>协议</strong>使用，<strong><code>SSL</code></strong>是当今世界上<strong>应用最为广泛的网络安全技术</strong>。  </p><p><strong><code>SSL</code></strong>采用的是<strong>非对称加密</strong>即<strong>公开秘钥加密</strong>，如果使用<strong>对称加密</strong>，必须将秘钥发送给对方，如果通信被监听秘钥可能会别攻击者窃取，也就失去了加密的意义，还得设法安全的保管接收到的秘钥，非对称加密则很好的解决了该问题，因为非对称加密是使用公钥加密，私钥解密，不需要发送用来解密的私钥，不必担心秘钥被攻击者窃取。</p><p>HTTPs采用<strong>对称加密</strong>和<strong>非对称加密</strong>两者<strong>并用</strong>的<strong>混合加密机制</strong>，<strong>非对称加密</strong>处理速度<strong>慢</strong>于<strong>对称加密</strong>，故<strong><code>HTTPs</code></strong>利用两者的优势，在<strong>交换密钥环节</strong>使用<strong>非对称加密方式</strong>，<strong>建立通信交换报文阶段</strong>则使用<strong>对称加密方式</strong>。</p><p><img src="../../../../../images/网络/HTTP/HTTP加密算法.png" alt></p><p>即使如此对称加密还是存在一些问题，即<strong>无法证明公开密钥本身就是货真价实的公开密钥</strong>，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥，或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了，可使用由<strong>数字证书认证机构<code>CA</code></strong>即<strong><code>Certificate Authority</code></strong>和其相关机关颁发的<strong>公开密钥证书</strong>来解决该问题。</p><p>HTTPs之所以使用对称加密传输数据：</p><ul><li><strong>非对称加密</strong>相对于<strong>对称加密</strong>的<strong>加解密效率是非常低</strong></li><li>只有服务端保存了私钥，<strong>一对公私钥只能实现单向的加解密</strong>，否则需要两对秘钥，这就涉及到<strong>客户端证书</strong>问题</li></ul><h5 id="HTTPs通信步骤"><a href="#HTTPs通信步骤" class="headerlink" title="HTTPs通信步骤"></a>HTTPs通信步骤</h5><p><img src="../../../../../images/网络/HTTP/HTTPs安全通信机制.png" alt></p><p>首先<strong>客户端</strong>发送一个<strong><code>ClientHello</code></strong>消息给<strong>服务端</strong>，<strong>发起建立<code>SSL</code>会话</strong>的请求，并告诉服务端自己<strong>支持</strong>的<strong><code>Cipher Suite</code>加密组件列表</strong>包括所使用的<strong>加密算法</strong>及<strong>秘钥长度</strong>、<strong><code>SSL</code>指定的版本</strong>，且产生一个随机数，用于以后<strong>生成对称密钥</strong>，发送给服务端。</p><p>服务端首次响应会<strong>确定</strong>加密协议<strong><code>SSL</code>版本</strong>以及从接收的客户端加密组件中赛选出的<strong>加密组件</strong>，也会生成一个<strong>随机数</strong>响应给客户端，以<strong><code>ServerHello</code></strong>报文作为响应。</p><p>服务端把自己的<strong><code>Certificate</code>证书</strong>及<strong>公钥</strong>发送给客户端，让客户端进行校验，且<strong>公钥</strong>被用于加密后面握手过程中生成的<strong>对称密钥</strong>。</p><p>服务器发送<strong><code>ServerHelloDone</code></strong>报文通知客户端，告知<strong>最初阶段的<code>SSL</code>握手协商部分结束</strong>。</p><p><strong><code>SSL</code></strong>第一次握手结束之后，客户端以<strong><code>Client Key Exchange</code></strong>报文作为回应，<strong>通知服务器此消息以后客户端会以加密方式发送数据</strong>，是使用的一种被称为<strong><code>Pre-master secret</code></strong>的<strong>随机密码串</strong>进行对称加密。</p><p>接着客户端继续发送<strong><code>Change Cipher Spec</code></strong>报文，且通知服务端<strong>此报文之后</strong>的通信会采用<strong><code>Pre-master secret</code></strong>密钥加密，即使用上面的<strong>随机密码串</strong>做对称加密。</p><p>客户端发送<strong><code>Finished</code></strong>报文，该报文包含连<strong>接至今全部报文的整体校验值</strong>，若<strong>服务器是否能够正确解密该报文作</strong>，则说明本次握手协商成功。</p><p>服务器同样发送<strong><code>Change Cipher Spec</code></strong>报文，<strong>通知客户端此消息以后服务器会以加密方式发送数据</strong>。</p><p>服务端发送<strong><code>Finished</code></strong>报文阶段，且服务端使用<strong>对称秘钥加密</strong>之前发送的<strong>所有握手消息的hash值</strong>给客户端，让客户端校验。</p><p><strong>服务器</strong>和<strong>客户端</strong>的<strong><code>Finished</code></strong>报文<strong>交换完毕</strong>后，<strong><code>SSL</code>连接就算建立完成</strong>，然后进行应用层协议通信即发送HTTP响应。</p><p>最后<strong>由客户端断开连接</strong>，断开连接时发送<strong><code>close_notify</code></strong>报文，然后再发送<strong><code>TCP FIN</code></strong>报文来关闭与TCP的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做<strong><code>MAC</code></strong>即<strong><code>Message Authentication Code</code></strong>的<strong>报文摘要</strong>，MAC能够<strong>查知报文是否被篡改</strong>，从而保护报文的完整性。  </p><p><img src="../../../../../images/网络/HTTP/HTTPs建立通信过程.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然HTTP协议具有&lt;strong&gt;相当优秀&lt;/strong&gt;和&lt;strong&gt;方便&lt;/strong&gt;的一遍，但&lt;strong&gt;&lt;code&gt;HTTP&lt;/code&gt;协议&lt;/strong&gt;可能存在&lt;strong&gt;信息窃听&lt;/strong&gt;或&lt;strong&gt;身份伪装&lt;/stron
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="协议族" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="网络" scheme="https://yaoyinglong.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/协议族/HTTP协议/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2022-07-31T03:39:02.793Z</updated>
    
    <content type="html"><![CDATA[<p>由<strong>欧洲孩子研究组织CERN</strong>的<strong>蒂姆伯纳斯李</strong>博士提出的一种能让远隔两地的研究者们共享知识的设想，最初设想的基本理念是，<strong>借助多文档之间的相互关联形成的超文本</strong>，连成可相互参阅的WWW万维网。</p><p>WWW万维网的三项构建技术：把标准通用标记语言<strong><code>SGML</code></strong>作为页面的文本标记语言的<strong><code>HTML</code>超文本标记语言</strong>；作为文档传输协议的<strong><code>HTTP</code></strong>；指定文档所在地址的<strong>统一资源定位符<code>URL</code></strong>。</p><p><img src="../../../../../images/网络/协议.png" alt></p><p>为了更快地处理大量事务，确保协议的可伸缩性，HTTP协议是一种无状态协议，其自身不对请求和响应之间的通信状态进行保存，为了实现期望的保持状态功能，引入了<strong><code>Cookie</code></strong>技术。Cookie技术通过在<strong>请求</strong>和<strong>响应</strong>报文中<strong>写入Cookie信息来控制客户端的状态</strong>，Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往服务端发送请求时，会自动在请求报文中加入Cookie值后发送出去；服务端接收到Cookie后，会检查对比服务器上的记录，得到之前的状态信息。</p><p>两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端是服务端。且是先从客户端开始建立通信。</p><p><strong>请求报文</strong>是由<strong>请求方法</strong>、<strong>请求URI</strong>、<strong>协议版本号</strong>、可选的<strong>请求首部字段</strong>和<strong>内容实体</strong>构成。</p><p><strong>响应报文</strong>是由<strong>协议版本</strong>、<strong>状态码</strong>、用于<strong>解释状态码的原因短语</strong>、可选的<strong>响应首部字段</strong>以及<strong>实体主体</strong>构成。</p><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>URI统一资源标识符，<strong>由某个协议方案表示的资源的定位标识符</strong>，<strong>协议方案</strong>是指访<strong>问资源</strong>所使用的<strong>协议类型名称</strong>，如采用HTTP协议时，协议方案就是HTTP。URI用字符串标识某一互联网资源。常见的几种URI：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ftp://ftp.is.co.za/rfc/rfc1808.txt</span></span><br><span class="line"><span class="attribute">http://www.ietf.org/rfc/rfc2396.txt</span></span><br><span class="line">ldap://[2001:db8::7]/c=GB?objectClass?one</span><br><span class="line"><span class="attribute">mailto:John.Doe@example.com</span></span><br><span class="line"><span class="attribute">news:comp.infosystems.www.servers.unix</span></span><br><span class="line"><span class="attribute">tel:+1-816-555-1212</span></span><br><span class="line"><span class="attribute">telnet://192.0.2.16:80/</span></span><br><span class="line"><span class="attribute">urn:oasis:names:specification:docbook:dtd:xml:4.1.2</span></span><br></pre></td></tr></table></figure><p>绝对URI格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</span><br></pre></td></tr></table></figure><p><strong><code>http:</code></strong>为协议名<strong>不区分大小写</strong>最后附一个冒号，<strong><code>user:pass</code></strong>为登录认证信息即用户名和密码，<strong><code>www.example.jp</code></strong>为服务地址也可以是<strong><code>IPv4</code></strong>地址或<strong><code>IPv6</code></strong>地址，<strong><code>80</code></strong>为端口号<strong>若省略自动使用默认端口号</strong>，<strong><code>dir/index.htm</code></strong>带层次的文件路径<strong>来定位特指的资源</strong>，<strong><code>uid=1</code></strong>查询字符串<strong>可选</strong>，<strong><code>ch1</code></strong>为片段标识符即<strong>文档内某个位置</strong>；</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL统一资源定位符，<strong>表示资源的地点</strong>，URL<strong>是URI的子集</strong>。</p><h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>为了更符合人类的记忆习惯，故用字母配合数字的表示形式来指定计算机名，但这种方式计算机理解不了，故通过<strong>DNS协议提供通过域名查找IP地址</strong>，或<strong>逆向从IP地址反查域名的服务</strong>。</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>向请求URI指定的资源发送请求报文时，采用称为方法的命令，方法的作用在于，可以<strong>指定请求的资源按期望产生某种行为</strong>，且区分大小写，注意使用大写。</p><table><thead><tr><th>方法</th><th>说明</th><th>支持的HTTP协议版本</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td><td>1.0、1.1</td></tr><tr><td>POST</td><td>传输实体主体</td><td>1.0、1.1</td></tr><tr><td>PUT</td><td>传输文件</td><td>1.0、1.1</td></tr><tr><td>HEAD</td><td>获取报文首部</td><td>1.0、1.1</td></tr><tr><td>DELETE</td><td>删除文件</td><td>1.0、1.1</td></tr><tr><td>OPTIONS</td><td>询问支持的方法</td><td>1.1</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>1.1</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td><td>1.1</td></tr><tr><td>LINK</td><td>建立和资源之间的联系</td><td>1.0</td></tr><tr><td>UNLINK</td><td>断开连接关系</td><td>1.0</td></tr></tbody></table><h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>GET是用来<strong>获取资源</strong>，<strong>用来请求访问已经被URI识别的资源</strong>，如果请求的资源是文本则原样返回，若是通用网关接口那样的程序，则返回执行后的输出结果。</p><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>POST是<strong>用来传输实体的主体</strong>，虽然GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是使用POST方法，虽然POST功能与GET相似，但<strong>POST的主要目的并不是获取响应的主体内容</strong>。</p><h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><p>PUT用于<strong>传输文件</strong>，像FTP协议的文件上传一样，要求在<strong>请求报文的主体中包含文件内容</strong>，然后<strong>保存到请求URI指定的位置</strong>，但是鉴于<strong><code>HTTP/1.1</code></strong>的PUT方法<strong>自身不带验证机制</strong>，任何人都可以上传文件，<strong>存在安全问题</strong>，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST表征状态转移标准的同类Web网站，就可能会开放使用PUT方法。</p><h5 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h5><p>HEAD方法和GET方法一样，只是<strong>不返回报文主体部分</strong>，用于<strong>确认URI的有效性</strong>、通信状态及<strong>资源更新的日期时间</strong>等</p><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>DELETE方法用于<strong>删除文件</strong>，与PUT方法相反，DELETE方法<strong>按请求URI删除指定的资源</strong>，一样<strong>不带验证机制</strong>。</p><h5 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h5><p>OPTIONS方法用于<strong>询问支持的方法</strong>，用来<strong>查询针对请求URI指定的资源支持的方法</strong>。</p><h5 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h5><p>TRACE用于<strong>追踪路径</strong>，让Web服务器<strong>将之前的请求通信返回给客户端的方法</strong>。发送请求在<strong><code>Max-Forwards</code>首部字段</strong>中填入数值，每经过一个服务器端，就将该<strong>数字减一</strong>，当数值<strong>刚好减到0时</strong>，就<strong>停止继续传输</strong>，<strong>最后接收到请求的服务器端则返回状态码200 OK的响应</strong>。客户端可以通过TRACE方法查询发送出去的请求时怎样被加工修改的，因为请求想要链接到源目标服务器可能会通过代理中转，<strong><code>TRACE</code></strong>方法就是<strong>用来确认连接过程中发生的一系列操作</strong>。<strong>容易引发<code>XST</code>跨站追踪</strong>。</p><h5 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h5><p>CONNECT方法<strong>要求在与代理服务器通信时建立隧道</strong>，<strong>实现用隧道协议进行TCP通信</strong>，主要使用<strong><code>SSL</code>安全套接层</strong>和<strong><code>TLS</code>传输安全层</strong>协议吧通信<strong>内容加密后经过网络隧道传输</strong>。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP协议<strong>初始版本</strong>中，<strong>每进行一次HTTP通信就要断开一次TCP连接</strong>，使用浏览器浏览一个包含多个张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源，<strong>每次请求都会造成无所谓的TCP连接建立和断开</strong>。 </p><p>为了解决TCP连接问题，<strong><code>HTTP/1.1</code></strong>和一<strong>部分<code>HTTP/1.0</code></strong>想出了<strong>持久连接</strong>即<strong><code>HTTP keep-alive</code></strong>或<strong><code>HTTP connection reuse</code></strong>的方法，<strong>任意一端</strong>没有<strong>明确提出断开连接</strong>，则<strong>保持连接状态</strong>。</p><p>持<strong>久连接</strong>减少了<strong>TCP连接</strong>的<strong>重复建立</strong>和<strong>断开</strong>所造成的额外开销，<strong>减轻了服务器端的负载</strong>，减少开销的那部分时间，<strong>使HTTP请求和响应能更早的结束</strong>，使Web页面的显示速度也得以提高。<strong><code>HTTP/1.1</code></strong>中<strong>所有连接默认都是持久连接</strong>，但<strong><code>HTTP/1.0</code></strong>内并未标准化。虽然一部分服务器通过非标准手段实现了持久连接，但服务器不一定能支持持久连接，且还需要客户端也支持持久连接。</p><p><strong>持久连接</strong>使得<strong>多数请求以管线化方式发送成为可能</strong>，管线化技术出现后，<strong>不用等待响应亦可直接发送下一个请求</strong>。</p><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文是HTTP协议交互的信息，由<strong>多行数据</strong>构成的<strong>字符串文本</strong>， 且<strong>以<code>CR</code>（回车）+ <code>LF</code>（换行） 作换行符</strong>，分为<strong>请求报文</strong>和<strong>响应报文</strong>。 HTTP报文分为<strong>首部</strong>和<strong>主体</strong>两块，两者由<strong>首个<code>CR+LF</code>分割</strong>。</p><p><img src="../../../../../images/网络/HTTP/请求报文和响应报文结构.png" alt="请求报文和响应报文结构"></p><p><strong>请求报文首部</strong>含有<strong>请求行</strong>、<strong>请求首部字段</strong>、<strong>通用首部字段</strong>、<strong>实体首部字段</strong>、<strong>其他</strong>；</p><p><img src="../../../../../images/网络/HTTP/请求报文实例.png" alt></p><p><strong>响应报文首部</strong>含有<strong>状态行</strong>、<strong>响应首部字段</strong>、<strong>通用首部字段</strong>、<strong>实体首部字段</strong>、<strong>其他</strong>。</p><p><img src="../../../../../images/网络/HTTP/响应报文实例.png" alt></p><p><strong>请求行</strong>包含用户<strong>请求的方法</strong>、<strong>请求URI</strong>、<strong>HTTP版本</strong>；<strong>状态行</strong>包含表明响应结果的<strong>状态码</strong>、<strong>原因短语</strong>、<strong>HTTP版本</strong>。</p><p><strong>首部字段</strong>包含表示<strong>请求</strong>和<strong>响应</strong>的<strong>各种条件</strong>和<strong>属性</strong>的<strong>各类首部</strong>，一般包含<strong><code>4</code>类</strong>首部，分别是<strong>通用首部</strong>、<strong>请求首部</strong>、<strong>响应首部</strong>和<strong>实体首部</strong>、<strong>其他</strong>可能包含<strong>HTTP的RFC里未定义的首部</strong>，如<strong><code>Cookie</code></strong>等。</p><h5 id="编码提示传输效率"><a href="#编码提示传输效率" class="headerlink" title="编码提示传输效率"></a>编码提示传输效率</h5><p>HTTP在传输数据时<strong>可按照数据原貌直接传输</strong>，也可在传输过程中<strong>通过编码提升传输速率</strong>，通过在传输时编码，能有效地处理大量<br>访问请求，但编码操作需要计算机来完成，因此会消耗更多CPU等资源。  </p><p>HTTP协议中有一种被称为<strong>内容编码</strong>的功能，内容编码<strong>指明应用在实体内容上的编码格式</strong>，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码。常用内容编码有以下几种：</p><ul><li><strong><code>gzip</code></strong>：GNU zip</li><li><strong><code>compress</code></strong>：UNIX 系统的标准压缩</li><li><strong><code>deflate</code></strong>：zlib</li><li><strong><code>identity</code></strong>：不进行编码</li></ul><p>HTTP通信过程中，请求编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，在传输大容量数据时，通过把数据分割<br>成多块，能够让浏览器逐步显示页面，这种把<strong>实体主体分块</strong>的功能称为<strong>分块传输编码<code>Chunked Transfer Coding</code></strong>，每一块都会用<br><strong>十六进制来标记块的大小</strong>，而实体主体的最后一块会使用<strong><code>0(CR+LF)</code></strong>来标记；<strong><code>HTTP/1.1</code></strong>中存在一种称为<strong>传输编码<code>Transfer Coding</code></strong>的机制，可<strong>在通信时按某种编码方式传输</strong>，但<strong>只定义作用于分块传输编码中</strong>。  </p><h5 id="发送多种数据"><a href="#发送多种数据" class="headerlink" title="发送多种数据"></a>发送多种数据</h5><p>发送邮件时可在邮件里写入文字并添加多份附件，  因为采用了<strong><code>MIME</code></strong>即<strong><code>Multipurpose Internet Mail Extensions</code>多用途因特网邮件扩展机制</strong>，它允许邮件处理文本、图片、视频等多个不同类型的数据。在MIME扩展中会使用一种称为<strong>多部分对象集合<code>Multipart</code></strong>的方法来容纳多份不同类型的数据。   </p><p>HTTP协议中也采纳了多部分对象集合，发送报文主体内可含多种类型实体，通常是在图片、文本、文件等上传时使用，多部分对象集合包含的对象如下：</p><ul><li><strong><code>multipart/form-data</code></strong>：Web表单<strong>文件上传</strong>时使用</li><li><strong><code>multipart/byteranges</code></strong>：状态码206即Partial Content部分内容，<strong>响应报文包含了多个范围的内容</strong>时使用</li></ul><p>HTTP报文中使用多部分对象集合时，需在首部字段里加上<strong><code>Content-type</code></strong>，且使用<strong><code>boundary</code></strong>字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入<strong><code>--</code>标记</strong>，如–AaB03x、–THIS_STRING_SEPARATES等，在多部分对象集合对应的字符串的<strong>最后插入<code>--</code>标记</strong>，如： –AaB03x–、 –THIS_STRING_SEPARATES–等<strong>作为结束</strong>。多部分对象集合的每个部分类型中，都可含有首部字段，<strong>可在某个部分中嵌套使用多部分对象集合</strong>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=AaB03x</span><br><span class="line">--AaB03x</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="field1"</span><br><span class="line">Joe Blow</span><br><span class="line">--AaB03x</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="pics"; filename="file1.txt"</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br><span class="line">...（file1.txt的数据）...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Date</span>: Fri, 13 Jul 2012 02:45:26 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span>: Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/byteranges; boundary=THIS_STRING_SEPARATES</span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line"><span class="attribute">Content-Type</span>: application/pdf</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 500-999/8000</span><br><span class="line">...（范围指定的数据）...</span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line"><span class="attribute">Content-Type</span>: application/pdf</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 7000-7999/8000</span><br><span class="line">...（范围指定的数据）...</span><br><span class="line">--THIS_STRING_SEPARATES--</span><br></pre></td></tr></table></figure><h5 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h5><p>指定范围发送的请求叫做<strong>范围请求<code>Range Request</code></strong>，  对一份10000字节大小的资源，若使用范围请求，可只请求5001~10000字节内的资源。执行范围请求时会用到首部字段<strong><code>Range</code></strong>来指定资源的byte范围：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 5001~10000字节</span><br><span class="line"><span class="attribute">Range</span>: bytes=5001-10000</span><br><span class="line"># 从5001字节之后全部的</span><br><span class="line"><span class="attribute">Range</span>: bytes=5001-</span><br><span class="line"># 从一开始到3000字节和5000~7000字节的多重范围</span><br><span class="line"><span class="attribute">Range</span>: bytes=-3000, 5000-7000</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/tip.jpg</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.usagidesign.jp</span><br><span class="line"><span class="attribute">Range</span>: bytes =5001-10000</span><br></pre></td></tr></table></figure><p>针对范围请求，响应会返回<strong>状态码</strong>为<strong><code>206 Partial Content</code></strong>的响应报文，对于<strong>多重范围的范围请求</strong>，响应会在<strong>首部字段<code>Content-Type</code>标明<code>multipart/byteranges</code></strong>后返回响应报文。若<strong>服务端无法响应范围请求</strong>， 则会<strong>返回状态码<code>200 OK</code></strong>和<strong>完整的实体内容</strong>。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Date</span>: Fri, 13 Jul 2012 04:39:17 GMT</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</span><br><span class="line"><span class="attribute">Content-Length</span>: 5000</span><br><span class="line"><span class="attribute">Content-Type</span>: image/jpeg</span><br></pre></td></tr></table></figure><h5 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h5><p>同一Web网站可能存在着<strong>多份内容相同</strong>但使用<strong>语言不同</strong>的页面，如英语版和中文版的Web页面，当浏览器默认语言为英语或中文， 访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面。</p><p><strong>内容协商机制</strong>是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，内容协商会以响应资源的<strong>语言</strong>、<strong>字符集</strong>、<strong>编码方式</strong>等作为判断的基准，在请求报文中的以下首部字段就是判断的基准：</p><ul><li><strong><code>Accept</code></strong></li><li><strong><code>Accept-Charset</code></strong></li><li><strong><code>Accept-Encoding</code></strong></li><li><strong><code>Accept-Language</code></strong></li><li><strong><code>Content-Language</code></strong></li></ul><p>内容协商技术有：<strong>服务器驱动协商</strong>、<strong>客户端驱动协商</strong>、<strong>透明协商</strong>三种类型</p><ul><li><strong>服务器驱动协商</strong>：以请求首部字段为参考，在服务器端自动处理</li><li><strong>客户端驱动协商</strong>：用户从浏览器显示的可选项列表中手动选择，也可利用JS脚本在Web页面上自动选择，如PC版与手机版的选择</li><li><strong>透明协商</strong>：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法</li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><strong>状态码</strong>以<strong>3位数字</strong>和<strong>原因短语</strong>组成，数字中的<strong>第一位指定了响应类别</strong>后两位无分类，响应类别有以下5种：</p><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td><strong><code>1XX</code></strong></td><td>Informational（<strong>信息性</strong>状态码）</td><td><strong>接收的请求正在处理</strong></td></tr><tr><td><strong><code>2XX</code></strong></td><td>Success（<strong>成功</strong>状态码）</td><td><strong>请求正常处理完毕</strong></td></tr><tr><td><strong><code>3XX</code></strong></td><td>Redirection（<strong>重定向</strong>状态码）</td><td><strong>需要进行附加操作以完成请求</strong></td></tr><tr><td><strong><code>4XX</code></strong></td><td>Client Error（<strong>客户端错误</strong>状态码）</td><td><strong>服务器无法处理请求</strong></td></tr><tr><td><strong><code>5XX</code></strong></td><td>Server Error（<strong>服务器错误</strong>状态码）</td><td><strong>服务器处理请求出错</strong></td></tr></tbody></table><h4 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h4><p><strong><code>2XX</code></strong>的响应结果表明请求被正常处理了，在响应报文内， 随状态码一起返回的信息会因<strong>方法的不同</strong>而发生改变。如使用GET方法时，对应请求资源的实体会作为响应返回；使用HEAD方法时，对应请求资源的实体首部不随报文主体作为响应返回。</p><h5 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h5><p>服务器接收的请求<strong>已成功处理</strong>，但在返回的<strong>响应报文</strong>中<strong>不含实体的主体部分</strong>，也<strong>不允许</strong>返回任何<strong>实体的主体</strong>，当从浏览器发出请求处理后， 返回204响应则浏览器显示页面不发生更新；一般在<strong>只需要从客户端往服务器发送信息</strong>， 而对<strong>客户端不需要发送新信息内容</strong>的情况下使用。</p><h5 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h5><p>表示<strong>客户端进行了范围请求</strong>，而服务器成功执行了这部分GET请求，响应报文中包含由<strong><code>Content-Range</code></strong>指定范围的实体内容。</p><h4 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h4><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求</p><h5 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h5><p><strong>永久性重定向</strong>，表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI，若已经把资源对应的URI保存为书签，这时应按Location首部字段提示的URI重新保存。</p><h5 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h5><p><strong>临时性重定向</strong>，表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问，代表的资源不是被永久移动， 只是临时性质的。 已移动的资源对应的URI将来还有可能发生改变，用户把URI保存成书签， 但不会像301状态码那样去更新书签， 而是仍旧保留返回 302状态码的页面对应的URI。</p><h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><p>表示由于<strong>请求对应的资源存在着另一个URI</strong>，应使用GET方法定向获取请求的资源，303状态码和302状态码有着相同的功能，但<strong>303状态码明确表示客户端应当采用GET方法获取资源</strong>。</p><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><p>表示<strong>客户端发送附带条件的请求时</strong>，如GET方法请求报文中包含<strong><code>If-Match</code></strong>、<strong><code>If-ModifiedSince</code></strong>、<strong><code>If-None-Match</code></strong>、<strong><code>If-Range</code></strong>、<strong><code>If-Unmodified-Since</code></strong>中任一首部，服务器端允许请求访问资源，但<strong>未满足条件</strong>的情况，<strong>返回不包含任何响应的主体部分</strong>，和重定向没有关系。</p><h5 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h5><p><strong>临时重定向</strong>，<strong>与<code>302</code>有着相同的含义</strong>，尽管<strong><code>302</code>标准禁止<code>POST</code>变换成<code>GET</code></strong>，但实际使用时大家并不遵守，<strong><code>307</code>会遵照浏览器标准</strong>，不会从POST变成GET，但对于处理响应时的行为，每种浏览器有可能出现不同的情况。  </p><h4 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h4><p>4XX响应结果表明<strong>客户端是发生错误的原因所在</strong></p><h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><p>表示<strong>请求报文中存在语法错误</strong>，需修改请求的内容后再次发送请求，浏览器会像200 OK一样对待该状态码。</p><h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><p>表示<strong>发送的请求需要有通过<code>HTTP</code>认证</strong>，如<strong><code>BASIC</code></strong>认证、<strong><code>DIGEST</code></strong>认证等认证信息，若<strong>之前已进行过1次请求，则表示用户认证失败</strong>，返回含有401的响应<strong>必须包含一个适用于被请求资源</strong>的<strong><code>WWW-Authenticate</code></strong>首部用以<strong>质询用户信息</strong>。当<strong>浏览器初次接收到<code>401</code>响应</strong>，会<strong>弹出认证对话窗口</strong>。  </p><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>表示对<strong>请求资源的访问被服务器拒绝</strong>，服务器端没有必要给出拒绝的详细理由，也可在实体的主体部分对原因进行描述，如<strong>未获得文件系统的访问授权</strong>， <strong>访问权限出现某些问题</strong>等情况。</p><p>404 Not Found</p><p>表示<strong>服务器上无法找到请求的资源</strong>，也可在<strong>服务器端拒绝请求且不想说明理由时使用</strong>。</p><h4 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h4><p>5XX的响应结果表示<strong>服务器本身发生错误</strong></p><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>表示服务器端在<strong>执行请求时发生了错误</strong>，也可能是Web应用存在的bug或某些临时的故障</p><h5 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h5><p>表示服务器端<strong>不支持</strong>当前请求所需要的某个功能，当服务器<strong>无法识别请求的方法</strong>，且无法支持其对任何资源的请求</p><h5 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h5><p>表示作为网关或代理服务器尝试执行请求时，从上游服务器接收到无效的响应，表示服务器端脚本解释器或代理端脚本语言端未启动或无响应，以及反向代理端无响应。</p><h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p><strong>服务器暂时处于超负载或正在进行停机维护</strong>，现在无法处理请求，若事先得知<strong>解除以上状况需要的时间</strong>，最好写入<strong><code>Retry-After</code></strong>首部字段再返回给客户端。</p><h5 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h5><p>表示作为<strong>网关</strong>或<strong>代理服务器</strong>尝试<strong>执行请求时</strong>，未能<strong>及时</strong>从上游服务器或者辅助服务器<strong>收到响应</strong>，即<strong>响应超时</strong>。</p><h5 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h5><p>表示服务器<strong>不支持</strong>或拒绝支持在<strong>请求中使用的HTTP版本</strong></p><h5 id="511-Network-Authentication-Required"><a href="#511-Network-Authentication-Required" class="headerlink" title="511 Network Authentication Required"></a>511 Network Authentication Required</h5><p>表示客户端需要经过验证以获得网络连接许可</p><h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><p>使用首部字段是为了给浏览器和服务器提供<strong>报文主体大小</strong>、 <strong>使用的语言</strong>、<strong>认证信息等内容</strong>，HTTP首部字段是由<strong>首部字段名</strong>和<strong>字段值</strong>构成的，中间用<strong>冒号<code>:</code>分隔</strong>，对于重复的HTTP首部字段，在规范内尚未明确，不同的浏览器内部处理逻辑不同；<strong>字段值</strong>对应单个HTTP首部字段<strong>可有多个值</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Keep-Alive</span>: timeout=15, max=100</span><br></pre></td></tr></table></figure><p>HTTP首部字段根据<strong>实际用途</strong>被分为以下<strong><code>4</code>种</strong>类型：</p><ul><li><strong>通用首部字段</strong>：请求报文和响应报文两方都会使用的首部</li><li><strong>请求首部字段</strong>：从客户端向服务器端发送请求报文时使用的首部，补充了请求附加内容、客户端信息、响应内容相关优先级等信息</li><li><strong>响应首部字段</strong>：从服务器端向客户端返回响应报文时使用的首部，补充了响应附加内容，也会要求客户端附加额外的内容信息</li><li><strong>实体首部字段</strong>：针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息</li></ul><p>HTTP首部字段将定义成<strong>缓存代理</strong>和<strong>非缓存代理</strong>的行为，分成2种类型：</p><ul><li><strong>端到端首部</strong>：此类别中的首部会转发给<strong>请求</strong>或<strong>响应</strong>对应<strong>最终接收目标</strong>，且<strong>必须保存在由缓存生成的响应中</strong>，且规定它必须被转发</li><li><strong>逐跳首部</strong>：此类别中的首部<strong>只对单次转发有效</strong>，会因通过缓存或代理而不再转发，HTTP/1.1和之后版本，若要使用逐跳首部需提供 Connection首部字段，只有以下8个字段属于逐跳首部：<ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade  </li></ul></li></ul><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><p>请求报文和响应报文双方都会使用的首部</p><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">控制缓存的行为</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Connection</td><td style="text-align:center">逐跳首部、连接的管理</td><td style="text-align:center">逐跳首部</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">创建报文的日期时间</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">报文指令</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Trailer</td><td style="text-align:center">报文末端的首部一览</td><td style="text-align:center">逐跳首部</td></tr><tr><td style="text-align:center">Transfer-Encoding</td><td style="text-align:center">指定报文主体的传输编码方式</td><td style="text-align:center">逐跳首部</td></tr><tr><td style="text-align:center">Upgrade</td><td style="text-align:center">升级为其他协议</td><td style="text-align:center">逐跳首部</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">代理服务器的相关信息</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">错误通知</td></tr></tbody></table><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>操作缓存的工作机制，多个指令之间通过<strong>逗号<code>,</code>分隔</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: private, max-age=0, no-cache</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">缓存请求指令</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">no-cache</td><td style="text-align:center">无</td><td style="text-align:center">强制向源服务器再次验证</td></tr><tr><td style="text-align:center">no-store</td><td style="text-align:center">无</td><td style="text-align:center">不缓存请求或响应的任何内容</td></tr><tr><td style="text-align:center">max-age = [ 秒]</td><td style="text-align:center">必需</td><td style="text-align:center">响应的最大Age值</td></tr><tr><td style="text-align:center">max-stale( = [ 秒])</td><td style="text-align:center">可省略</td><td style="text-align:center">接收已过期的响应</td></tr><tr><td style="text-align:center">min-fresh = [ 秒]</td><td style="text-align:center">必需</td><td style="text-align:center">期望在指定时间内的响应仍有效</td></tr><tr><td style="text-align:center">no-transform</td><td style="text-align:center">无</td><td style="text-align:center">代理不可更改媒体类型</td></tr><tr><td style="text-align:center">only-if-cached</td><td style="text-align:center">无</td><td style="text-align:center">从缓存获取资源</td></tr><tr><td style="text-align:center">cache-extension</td><td style="text-align:center">-</td><td style="text-align:center">新指令标记（token）</td></tr></tbody></table><table><thead><tr><th style="text-align:center">缓存响应指令</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">无</td><td style="text-align:center">可向任意方提供响应的缓存</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">可省略</td><td style="text-align:center">仅向特定用户返回响应</td></tr><tr><td style="text-align:center">no-cache</td><td style="text-align:center">可省略</td><td style="text-align:center">缓存前必须先确认其有效性</td></tr><tr><td style="text-align:center">no-store</td><td style="text-align:center">无</td><td style="text-align:center">不缓存请求或响应的任何内容</td></tr><tr><td style="text-align:center">no-transform</td><td style="text-align:center">无</td><td style="text-align:center">代理不可更改媒体类型</td></tr><tr><td style="text-align:center">must-revalidate</td><td style="text-align:center">无</td><td style="text-align:center">可缓存但必须再向源服务器进行确认</td></tr><tr><td style="text-align:center">proxy-revalidate</td><td style="text-align:center">无</td><td style="text-align:center">要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td style="text-align:center">max-age = [ 秒]</td><td style="text-align:center">必需</td><td style="text-align:center">响应的最大Age值</td></tr><tr><td style="text-align:center">s-maxage = [ 秒]</td><td style="text-align:center">必需</td><td style="text-align:center">公共缓存服务器响应的最大Age值</td></tr><tr><td style="text-align:center">cache-extension</td><td style="text-align:center">-</td><td style="text-align:center">新指令标记（token）</td></tr></tbody></table><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 使用public指令时，明确表明其他用户也可利用缓存</span><br><span class="line"><span class="attribute">Cache-Control</span>: public</span><br><span class="line"># 当指定private指令后，响应只以特定的用户作为对象，缓存服务器会对该特定用户提供资源缓存服务，对于其他用户发送的请求，代理服务器不会返回缓存</span><br><span class="line"><span class="attribute">Cache-Control</span>: private</span><br><span class="line"># no-cache指令的目的是为了防止从缓存中返回过期的资源，客户端将不会接收缓存过的响应，缓存服务器必须把客户端请求转发</span><br><span class="line">给源服务器，服务器返回响应中包含no-cache指令，则缓存服务器不能对资源进行缓存</span><br><span class="line"># 不缓存过期资源</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"># 由服务器返回的响应中，若对no-cache字段名具体指定参数值，客户端在接收到该被指定参数值的首部字段对应的响应报文后不能使用缓存，无参数值的首部字段可使用缓存，且只能在响应指令中指定该参数</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache=Location</span><br><span class="line"># 暗示请求或响应中包含机密信息，该指令规定缓存不能在本地存储请求或响应的任一部分，真正的不进行缓存</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"># 当客户端发送请求包含max-age指令时，若判定缓存资源的缓存时间数值比指定时间的数值更小，则客户端接收缓存的资源，当指定max-age值为0则缓存服务器通常需要将请求转发给源服务器</span><br><span class="line"># 当服务器返回响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长时间</span><br><span class="line"># HTTP/1.1在同时存在Expires首部字段时，会优先处理max-age指令，而忽略Expires首部字段，HTTP/1.0相反</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=604800（单位 ：秒）</span><br><span class="line"># 和max-age指令相同，s-maxage指令只适用于供多位用户使用的公共缓存服务器，使用s-maxage指令后，则直接忽略对Expires首部字段及</span><br><span class="line"><span class="attribute">max-age指令的处理</span></span><br><span class="line"><span class="attribute">Cache-Control</span>: s-maxage=604800（单位 ：秒）</span><br><span class="line"># 要求缓存服务器返回至少还未过指定时间的缓存资源，若min-fresh=60秒，则60秒后的资源无法作为响应返回</span><br><span class="line"><span class="attribute">Cache-Control</span>: min-fresh=60（单位 ：秒）</span><br><span class="line"># 指示缓存资源即使过期也照常接收，未指定参数值表示无论经过多久客户端都会接收响应，若指定了具体数值即使过期，只要仍处于max-stale指定时间内，仍旧会被客户端接收</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-stale=3600（单位 ：秒）</span><br><span class="line"># 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性</span><br><span class="line"># 若发生请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout</span><br><span class="line"><span class="attribute">Cache-Control</span>: only-if-cached</span><br><span class="line"># 代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效，若代理无法连通源服务器再次获取有效资源，则缓存必须给客户端一条 504状态码，且会忽略请求max-stale指令</span><br><span class="line"><span class="attribute">Cache-Control</span>: must-revalidate</span><br><span class="line"># 所有缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性</span><br><span class="line"><span class="attribute">Cache-Control</span>: proxy-revalidate</span><br><span class="line"># 无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型，可防止缓存或代理压缩图片等类似操作</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-transform</span><br><span class="line"># 通过cache-extension标记（token），可扩展Cache-Control首部字段内的指令，若缓存服务器不能理解community这个新指令，则会直接忽略，extension tokens仅对能理解它的缓存服务器有意义</span><br><span class="line"><span class="attribute">Cache-Control</span>: private, community="UCI"</span><br></pre></td></tr></table></figure><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p>Connection首部字段具备：<strong>控制不再转发给代理的首部字段</strong>，<strong>管理持久连接</strong>，<strong><code>HTTP/1.1</code></strong>版本的<strong>默认连接都是持久连接</strong>  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段</span><br><span class="line"><span class="attribute">Connection</span>: 不再转发的首部字段名</span><br><span class="line"># HTTP/1.1版本的默认连接都是持久连接，当服务器端想明确断开连接时，则指定Connection首部字段的值为Close</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"># HTTP/1.1之前的HTTP版本的默认连接都是非持久连接，若旧版本HTTP协议上维持持续连接，则需要指定Connection首部字段的值为Keep-Alive</span><br><span class="line"># 服务端加上首部字段Keep-Alive及首部字段Connection后返回响应</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br></pre></td></tr></table></figure><p><img src="../../../../../images/网络/HTTP/Connection_delete.png" alt></p><p><img src="../../../../../images/网络/HTTP/Connection_keep_alive.png" alt></p><h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><p>表明<strong>创建<code>HTTP</code>报文的日期和时间</strong>，HTTP/1.1协议使用在RFC1123中规定的日期时间的格式，之前的HTTP协议版本中使用在RFC850中定义的格式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HTTP/1.1</span><br><span class="line"><span class="attribute">Date</span>: Tue, 03 Jul 2012 04:40:59 GMT</span><br><span class="line"># 之前的HTTP协议版本</span><br><span class="line"><span class="attribute">Date</span>: Tue, 03-Jul-12 04:40:59 GMT</span><br><span class="line"># 还有一种格式，它与C标准库内的asctime()函数的输出格式一致</span><br><span class="line"><span class="attribute">Date</span>: Tue Jul 03 04:40:59 2012</span><br></pre></td></tr></table></figure><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma属于<strong>通用首部字段</strong>，只用在客户端发送的请求中，是<strong><code>HTTP/1.1</code></strong>之前版本的历史遗留字段，仅作为与HTTP/1.0的<strong>向后兼容而定义</strong>，<strong>客户端会要求所有的中间服务器不返回缓存的资源</strong>。</p><p>所有中间服务器若都能以HTTP/1.1为基准，那直接采用Cache-Control: no-cache指定缓存的处理方式即可，但要整体掌握全部中间服务器使用的HTTP协议版本是不现实的，因此发送的请求会同时含有下面两个首部字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><h5 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h5><p>事先说明<strong>在报文主体后记录了哪些首部字段</strong>，该首部字段可应用在<strong><code>HTTP/1.1</code></strong>版本<strong>分块传输编码时</strong>，如下指定首部字段Trailer的值为Expires，在报文主体之后即分块长度0之后出现了首部字段Expires：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Tue, 03 Jul 2012 04:40:56 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Trailer</span>: Expires</span><br><span class="line">...(报文主体)...</span><br><span class="line"><span class="attribute">0</span></span><br><span class="line"><span class="attribute">Expires</span>: Tue, 28 Sep 2004 23:59:59 GMT</span><br></pre></td></tr></table></figure><h5 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h5><p>规定了<strong>传输报文主体时采用的编码方式</strong>，<strong><code>HTTP/1.1</code></strong>的传输编码方式<strong>仅对分块传输编码有效</strong></p><h5 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h5><p><strong>用于检测HTTP协议及其他协议是否可使用更高的版本进行通信</strong>，其参数值<strong>可用来指定一个完全不同的通信协议</strong>，如下Connection的值被指定为Upgrade，则产生作用的Upgrade对象仅限于客户端和邻接服务器，使用Upgrade时还需额外指定<strong><code>Connection:Upgrade</code></strong>，对于附有Upgrade的请求，服务器可用<strong><code>101 Switching Protocols</code></strong>状态码作为响应返回：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.htm</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Upgrade</span>: TLS/1.0</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br></pre></td></tr></table></figure><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><p>用于<strong>追踪客户端与服务器之间</strong>请求和响应<strong>报文的传输路径</strong>，报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发，<strong>还可避免请求回环</strong>，也可增加1个新的Via首部写入服务器信息，<strong>经常会和<code>TRACE</code>方法一起使用</strong>，代理服务器接收到由TRACE方法发送过来的请求，当Max-Forwards为0时，代理服务器会将自身的信息附加到Via首部后，返回该请求的响应。</p><p><img src="../../../../../images/网络/HTTP/Via.png" alt></p><h5 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h5><p>HTTP/1.1的Warning首部是从HTTP/1.0的响应首部Retry-After演变过来的，该首部通常<strong>会告知用户一些与缓存相关的问题的警告</strong>，HTTP/1.1中定义了7种警告，且警告码具备扩展性</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 时间部分可省略</span><br><span class="line"><span class="attribute">Warning</span>: 113 gw.hackr.jp:8080 "Heuristic expiration" Tue, 03 Jul 2012 05:09:44 GMT</span><br><span class="line"><span class="attribute">Warning</span>: [警告码][警告的主机:端口号]"[警告内容]" ([日期时间])</span><br></pre></td></tr></table></figure><table><thead><tr><th>警告码</th><th>警告内容</th><th>说明</th></tr></thead><tbody><tr><td>110</td><td>Response is stale（响应已过期）</td><td>代理返回已过期的资源</td></tr><tr><td>111</td><td>Revalidation failed（再验证失败）</td><td>代理再验证资源有效性时失败（服务器无法到达等原因）</td></tr><tr><td>112</td><td>Disconnection operation（断开连接 操作）</td><td>代理与互联网连接被故意切断</td></tr><tr><td>113</td><td>Heuristic expiration（试探性过期）</td><td>响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</td></tr><tr><td>199</td><td>Miscellaneous warning（杂项警告）</td><td>任意的警告内容</td></tr><tr><td>214</td><td>Transformation applied（使用了转换）</td><td>代理对内容编码或媒体类型等执行了某些处理时</td></tr><tr><td>299</td><td>Miscellaneous persistent warning（持久杂项警告）</td><td>任意的警告内容</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><p>客户端往服务器端发送请求报文中所使用的字段，用于补充请求的<strong>附加信息</strong>、<strong>客户端信息</strong>、<strong>对响应内容相关的优先级</strong>等内容</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td><td></td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td><td></td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td><td></td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td><td></td></tr><tr><td>Authorization</td><td>Web认证信息</td><td></td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td><td></td></tr><tr><td>From</td><td>用户的电子邮箱地址</td><td></td></tr><tr><td>Host</td><td>请求资源所在服务器</td><td></td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td><td></td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td><td></td></tr><tr><td>If-None-Match</td><td>比较实体标记（与If-Match相反）</td><td></td></tr><tr><td>If-Range</td><td>资源未更新时发送实体Byte的范围请求</td><td></td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间（与If-Modified-Since相反）</td><td></td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td><td></td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td><td>逐跳首部</td></tr><tr><td>Range</td><td>实体的字节范围请求</td><td></td></tr><tr><td>Referer</td><td>对请求中URI的原始获取方</td><td></td></tr><tr><td>TE</td><td>传输编码的优先级</td><td>逐跳首部</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p>可通知服务器用户代理<strong>能够处理的媒体类型及媒体类型的相对优先级</strong>。 可使用<strong><code>type/subtype</code></strong>这种形式，一次指定多种媒体类型，若想要给显示的媒体类型增加优先级，则使用<strong><code>q=</code></strong>来额外表示<strong>权重</strong>值，用<strong>分号<code>;</code></strong>进行分隔，权重值<code>q</code>的范围是<strong><code>0~1</code></strong>，可精确到<strong>小数点后<code>3</code>位</strong>，<strong>默认权重为<code>q=1.0</code></strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure><ul><li>文本文件：text/html、text/plain、text/css等、application/xhtml+xml、application/xml等</li><li>图片文件：image/jpeg、image/gif、image/png等</li><li>视频文件：video/mpeg、video/quicktime等</li><li>应用程序使用的二进制文件：application/octet-stream、application/zip等</li></ul><h5 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h5><p>用来通知服务器用户代理支持的<strong>字符集</strong>及字符集的相对<strong>优先顺序</strong>，<strong>可一次性指定多种字符集</strong>，可用<strong>权重q值</strong>来表示<strong>相对优先级</strong>，该首部字段应用于<strong>内容协商机制</strong>的服务器驱动协商。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Charset</span>: iso-8859-5, unicode-1-1;q=0.8</span><br></pre></td></tr></table></figure><h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><p>用来告知服务器<strong>用户代理支持的内容编码及内容编码的优先级顺序</strong>，<strong>可一次性指定多种内容编码</strong>，采用<strong>权重q</strong>值来表示<strong>相对优先级</strong>，也可使用<strong>星号<code>*</code>作为通配符</strong>，指定<strong>任意</strong>的编码格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br></pre></td></tr></table></figure><ul><li><strong><code>gzip</code></strong>：由<strong>文件压缩程序<code>gzip</code>即<code>GNU zip</code></strong>生成的编码格式</li><li><strong><code>compress</code></strong>：由UNIX文件压缩程序<strong><code>compress</code></strong>生成的编码格式</li><li><strong><code>deflate</code></strong>：组合使用<strong><code>zlib</code></strong>格式及由<strong><code>deflate</code>压缩算法</strong>生成的编码格式</li><li><strong><code>identity</code></strong>：<strong>不执行压缩</strong>或<strong>不会变化的默认编码格式</strong></li></ul><h5 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h5><p>告知服务器用户代理<strong>能够处理</strong>的<strong>自然语言集</strong>，指中文或英文等，以及自然语言集的<strong>相对优先级</strong>，可一次指定多种自然语言集，按权重值q表示相对优先级</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Language</span>: zh-cn,zh;q=0.7,en-us,en;q=0.3</span><br></pre></td></tr></table></figure><h5 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h5><p>告知服务器用户代理的认证信息（证书值），通常想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Basic dWVub3NlbjpwYXNzd29yZA==</span><br></pre></td></tr></table></figure><p><img src="../../../../../images/网络/HTTP/Authorization.png" alt></p><h5 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h5><p>客户端使用Expect首部字段来告知服务器，<strong>期望出现的某种特定行为</strong>，因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码<strong><code>417 Expectation Failed</code></strong>，客户端可利用该首部字段，写明所期望的扩展</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 等待状态码100响应的客户端在发生请求时，需要指定</span><br><span class="line"><span class="attribute">Expect</span>: 100-continue</span><br></pre></td></tr></table></figure><h5 id="From"><a href="#From" class="headerlink" title="From"></a>From</h5><p>告知服务器使用用户代理的用户的电子邮件地址，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式，使用代理时，应尽可能包含From首部字段</p><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><p>告知服务器请求的资源所处的互联网主机名和端口号，Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段，Host和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，请求被发送至服务器时，请求中的主机名会用IP地址直接替换解决，相同的IP地址下部署运行着多个域名，则服务器无法理解是哪个域名对应的请求。则需要使用首部字段Host来明确指出请求的主机名，若服务器<strong>未设定主机名</strong>，则直接发送一个空值即可：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host:</span></span><br></pre></td></tr></table></figure><h5 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h5><p>形如<strong><code>If-xxx</code></strong>这种样式的请求首部字段，都可称为<strong>条件请求</strong>，服务器接收到附带条件的请求后，只有<strong>判断指定条件为真时</strong>才会执行请求，告知服务器匹配资源所用的<strong>实体标记<code>ETag</code></strong>值，此时服务器<strong>无法使用弱<code>ETag</code>值</strong>，服务器会比对If-Match字段值和资源ETag值，仅当两者一致才会执行请求，否则返回状态码<strong><code>412 Precondition Failed</code></strong>，还可用<strong>星号<code>*</code></strong>指定If-Match的字段值，此时服务器将会<strong>忽略<code>ETag</code>值</strong>，只要资源存在就处理请求。</p><p><img src="../../../../../images/网络/HTTP/If-Match.png" alt></p><h5 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h5><p><strong>用于确认代理或客户端拥有的本地资源的有效性</strong>，获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定，在If-Modified-Since字段指定的日期时间后资源发生了更新，服务器会接受请求，告知服务器<strong>若<code>If-Modified-Since</code>字段值早于资源的更新时间</strong>， 则希望能处理该请求，若在指定If-Modified-Since字段值的日期时间之后请求的资源都没有过更新，则返回状态码<strong><code>304 Not Modified</code></strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Modified-Since</span>: Thu, 15 Apr 2004 00:00:00 GMT</span><br></pre></td></tr></table></figure><h5 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h5><p><strong>与首部字段<code>If-Match</code>作用相反</strong>，用于指定If-None-Match字段值的实体标记ETag值与请求资源的ETag不一致时告知服务器处理该请求，在GET或HEAD方法中使用首部字段If-None-Match可获取最新的资源，这与使用首部字段<strong><code>If-Modified-Since</code></strong>时有些类似</p><h5 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h5><p>告知服务器若指定的If-Range字段值ETag值或者时间和请求资源的ETag值或时间一致时，则作为范围请求处理，反之则返回全体资源</p><h5 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h5><p>与首部字段If-Modified-Since的作用相反，告知服务器指定的请求资源只有在字段值内<strong>指定的日期时间之后未发生更新</strong>的情况下，才能处理请求，若在指定日期时间后发生了更新，则返回状态码<strong><code>412 Precondition Failed</code></strong>  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Unmodified-Since</span>: Thu, 03 Jul 2012 00:00:00 GMT</span><br></pre></td></tr></table></figure><h5 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h5><p><img src="../../../../../images/网络/HTTP/Max-Forwards.png" alt></p><p>通过TRACE方法或OPTIONS方 法，发送包含首部字段MaxForwards的请求时，该字段以十进制整数形式指定<strong>可经过的服务器最大数目</strong>，服务器在往下一个服务器转发请求之前<strong><code>Max-Forwards</code>值减<code>1</code>后重新赋值</strong>，当服务器接收到<strong>Max-Forwards值为<code>0</code></strong>的请求时，则不再进行转发，而是直接返回响应</p><h5 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h5><p>接收到从<strong>代理服务器</strong>发来的认证质询时，<strong>客户端</strong>会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息，该行为与客户端和服务器之间HTTP访问认证类似</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authorization</span>: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure><h5 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h5><p>只需获取部分资源的范围请求，告知服务器资源的指定范围，接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码为<strong><code>206 Partial Content</code></strong>，无法处理该范围请求时，则会返回状态码<strong><code>200 OK</code></strong>及<strong>全部资源</strong>。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Range</span>: bytes=5001-10000</span><br></pre></td></tr></table></figure><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><p>告知服务器请求的原始资源的URI，客户端一般都会发送Referer首部字段给服务器，但当直接在浏览器地址栏输入URI或出于安全性的考虑时，也可不发送该首部字段，因为原始资源的URI中查询字符串可能含有ID和密码等保密信息，写进Referer转发给其他服务器，可能导致保密信息泄露。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Referer</span>: http://www.hackr.jp/index.htm</span><br></pre></td></tr></table></figure><h5 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h5><p>告知服务器客户端能够处理响应的<strong>传输编码方式及相对优先级</strong>，与<strong>首部字段<code>Accept-Encoding</code>功能相似</strong>，但用于<strong>传输编码</strong>，还可指定伴随<strong><code>trailer</code>字段的分块传输编码的方式</strong>，应用后者时只需把trailers赋值给该字段值  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">TE</span>: gzip, deflate;q=0.5</span><br><span class="line"><span class="attribute">TE</span>: trailers</span><br></pre></td></tr></table></figure><h5 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h5><p>将创建请求的<strong>浏览器</strong>和<strong>用户代理名称</strong>等信息传达给服务器</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1</span><br></pre></td></tr></table></figure><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的<strong>附加信息</strong>、<strong>服务器信息</strong>，以及<strong>对客户端的附加要求</strong>等信息</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td><td></td></tr><tr><td>Age</td><td>推算资源创建经过时间</td><td></td></tr><tr><td>ETag</td><td>资源的匹配信息</td><td></td></tr><tr><td>Location</td><td>令客户端重定向至指定URI</td><td></td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td><td>逐跳首部</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td><td></td></tr><tr><td>Server</td><td>HTTP服务器的安装信息</td><td></td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td><td></td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h5 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h5><p><strong>告知客户端服务器是否能处理范围请求</strong>，以指定获取服务器端某个部分的资源</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 不能处理范围请求时</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: none</span><br><span class="line"># 能处理范围请求时</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br></pre></td></tr></table></figure><h5 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h5><p><strong>告知客户端源服务器在多久前创建了响应</strong>，若创建该响应的服务器是缓存服务器，则Age值是指缓存后的响应再次发起认证到认证完成的时间值，代理创建响应时必须加上首部字段Age</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 单位为秒</span><br><span class="line"><span class="attribute">Age</span>: 600</span><br></pre></td></tr></table></figure><h5 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h5><p><strong>告知客户端实体标识</strong>，它是一种可将资源以字符串形式做唯一性标识的方式，服务器会为每份资源分配对应的ETag值，当资源更新时ETag值也需要更新，生成ETag值时并没有统一算法规则，而仅仅是由服务器来分配</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: "82e22293907ce725faf67773957acd12"</span><br><span class="line"><span class="attribute">ETag</span>: W/"usagi-1234"</span><br></pre></td></tr></table></figure><p>资源被缓存时，就会被分配唯一标识，对于同一URI资源中文版和英文版对应资源是不同的，但两者的URI相同仅凭URI指定缓存资源相当困难，若下载过程中出现连接中断、再连接的情况，都会依照ETag值来指定资源，且<strong><code>ETag</code>值有强弱之分</strong>，<strong>强<code>ETag</code>值</strong>不论实体发生多么细微的变化都会改变其值，<strong>弱<code>ETag</code>值</strong>只用于提示资源是否相同，只有资源发生了根本改变，产生差异时才会改变ETag值，此时会在字段值最开始处附加<strong><code>W/</code></strong>。</p><h5 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h5><p><strong>将响应接收方引导至某个与请求URI位置不同的资源</strong>，该字段会配合<strong><code>3xx：Redirection</code></strong>响应提供重定向URI，几乎所有浏览器在接收到包含Location首部字段的响应后，都会强制性地尝试对已提示的重定向资源的访问</p><p><img src="../../../../../images/网络/HTTP/Location.png" alt></p><h5 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h5><p><strong>把由代理服务器所要求的认证信息发送给客户端</strong>，与客户端和服务器之间的HTTP访问认证行为相似，不同之处在于其认证行为是在客户端与代理之间进行的，客户端与服务器之间进行认证时，首部字段WWW-Authorization有着相同的作用</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authenticate</span>: Basic realm="Usagidesign Auth"</span><br></pre></td></tr></table></figure><h5 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h5><p><strong>告知客户端应该在多久之后再次发送请求</strong>，主要配合状态码<strong><code>503 Service Unavailable</code></strong>、<strong><code>3xx Redirec</code></strong>t响应一起使用</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 120秒后再发起请求</span><br><span class="line"><span class="attribute">Retry-After</span>: 120</span><br><span class="line"># 指定为具体的日期时间</span><br><span class="line"><span class="attribute">Retry-After</span>: Wed,04 Jul 2022 06:34:24 GMT</span><br></pre></td></tr></table></figure><h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p>告知客户端当前服务器上安装的HTTP服务器应用程序的信息，还有可能包括版本号和安装时启用的可选项</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Server</span>: Apache/2.2.17 (Unix)</span><br></pre></td></tr></table></figure><h5 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h5><p><strong>可对缓存进行控制</strong>，源服务器会向代理服务器传达关于本地缓存使用方法的命令，从代理服务器接收到源服务器返回包含Vary指定项的响应后，若再要进行缓存，仅对请求中含有相同Vary指定首部字段的请求返回缓存，即使对相同资源发起请求，但由于Vary指定的首部字段不相同，也必须要从源服务器重新获取资源</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Vary</span>: Accept-Language</span><br></pre></td></tr></table></figure><p><img src="../../../../../images/网络/HTTP/Vary.png" alt></p><h5 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h5><p>用于HTTP访问认证，告知客户端适用于访问请求URI所指定资源的认证方案如<strong><code>Basic</code></strong>、<strong><code>Digest</code></strong>、带参数提示的质询<strong><code>challenge</code></strong>等，状态码<strong><code>401 Unauthorized</code></strong>响应中肯定带有首部字段<strong><code>WWW-Authenticate</code></strong>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># realm字段的字符串是为了辨别请求URI指定资源所受到的保护策略</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm="Usagidesign Auth"</span><br></pre></td></tr></table></figure><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><p>包含在<strong>请求报文</strong>和<strong>响应报文</strong>中的<strong>实体部分</strong>所使用的首部，用于补充<strong>内容的更新时间</strong>等与实体相关的信息</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的HTTP方法</td><td></td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td><td></td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td><td></td></tr><tr><td>Content-Length</td><td>实体主体的大小（单位 ：字节）</td><td></td></tr><tr><td>Content-Location</td><td>替代对应资源的URI</td><td></td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td><td></td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td><td></td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td><td></td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td><td></td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h5 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h5><p>用于通知客户端能够支持Request-URI指定资源的所有HTTP方法，当服务器接收到不支持的HTTP方法时，会以状态码<strong><code>405 Method Not Allowed</code></strong>作为响应返回，同时把所有能支持的HTTP方法写入首部字段Allow后返回</p><p><img src="../../../../../images/网络/HTTP/Allow.png" alt></p><h5 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h5><p>告知客户端服务器<strong>对实体的主体部分选用的内容编码方式</strong>，指在不丢失实体信息的前提下所进行的压缩，支持的四种编码方式：<strong><code>gzip</code></strong>、<strong><code>compress</code></strong>、<strong><code>deflate</code></strong>、<strong><code>identity</code></strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br></pre></td></tr></table></figure><h5 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h5><p>告知客户端<strong>实体主体使用的自然语言</strong>，如中文、英语等</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Language</span>: zh-CN</span><br></pre></td></tr></table></figure><h5 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h5><p><strong>表明实体主体部分的大小</strong>，单位是<strong>字节</strong>，对实体主体进行内<strong>容编码传输时</strong>，<strong>不能</strong>再使用<strong><code>Content-Length</code></strong>首部字段，因为实体主体大小的<strong>计算方法略微复杂</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span>: 15000</span><br></pre></td></tr></table></figure><h5 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h5><p>给出与<strong>报文主体部分相对应的URI</strong>，和首部字段Location不同，Content-Location表示的是报文主体返回资源对应的URI，如使用<strong><code>Accept-Language</code></strong>的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段<strong><code>Content-Location</code></strong>内会写明URI</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Location</span>: http://www.hackr.jp/index-ja.html</span><br></pre></td></tr></table></figure><h5 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h5><p>客户端会对接收的报文主体执行相同的MD5算法，然后与首部字段Content-MD5的字段值比较，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 对报文主体执行MD5算法获得的128位二进制数，再通过Base64编码后将结果写入Content-MD5字段值</span><br><span class="line"><span class="attribute">Content-MD5</span>: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure><h5 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h5><p><strong>针对范围请求</strong>返回响应时使用的首部字段Content-Range告知客户端作为响应返回的实体的哪个部分符合范围请求，<strong>单位字节</strong>，表示<strong>当前发送部分及整个实体大小</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p>说明<strong>实体主体内对象的媒体类型</strong>，和首部字段Accept一样，字段值用type/subtype形式赋值，charset使用iso-8859-1或euc-jp等字符集进行赋值</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><strong>将资源失效的日期告知客户端</strong>，Expires字段值指定的时间之前，响应的副本会一直被缓存服务器保存，当超过指定时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。源服务器<strong>不希望缓存服务器对资源缓存</strong>时，最好<strong>在Expires字段内写入与首部字段Date相同的时间值</strong>，当首部字段<strong><code>Cache-Control</code></strong>有指定<strong><code>max-age</code></strong>指令时，会<strong>优先处理<code>max-age</code>指令</strong>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><h5 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h5><p><strong>指明资源最终修改的时间</strong>，一般该值是Request-URI指定资源被修改的时间，但类似使用CGI脚本进行动态数据处理时，该值可能会变成数据最终修改时的时间</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span>: Wed, 23 May 2012 09:59:55 GMT</span><br></pre></td></tr></table></figure><h5 id="Cookie首部字段"><a href="#Cookie首部字段" class="headerlink" title="Cookie首部字段"></a>Cookie首部字段</h5><p>Cookie的工作机制是<strong>用户识别及状态管理</strong>，Web 网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内，当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie，调用Cookie时，可校验Cookie的有效期、发送方的域、路径、协议等信息</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的Cookie信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的Cookie信息</td><td>请求首部字段</td></tr></tbody></table><h5 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h5><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息，一旦Cookie从服务器端发送至客户端，服务器端就不存在可显式删除Cookie的方法，但可通过覆盖已过期Cookie实现对客户端Cookie的实质性删除操作</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;</span><br><span class="line"><span class="attribute">Set-Cookie</span>: name=value; secure</span><br><span class="line"><span class="attribute">Set-Cookie</span>: name=value; HttpOnly</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予Cookie的名称和其值（必需项）</td><td></td></tr><tr><td>expires=DATE</td><td>Cookie的有效期（若不明确指定则<strong>默认为浏览器关闭前为止</strong>）</td><td>浏览器可发送Cookie的有效期</td></tr><tr><td>path=PATH</td><td>将<strong>服务器上的文件目录</strong>作为Cookie的适用对象（若不指定则<strong>默认为文档所在的文件目录</strong>）</td><td>用于限制指定Cookie发送范围的文件目录</td></tr><tr><td>domain=域名</td><td>作为Cookie适用对象的域名 （若不指定则<strong>默认为创建Cookie的服务器的域名</strong>）</td><td>不指定domain属性显得更安全</td></tr><tr><td>Secure</td><td><strong>仅在HTTPS安全通信时才会发送Cookie</strong></td><td></td></tr><tr><td>HttpOnly</td><td>加以限制，<strong>使Cookie不能被JavaScript脚本访问</strong></td><td>为防止跨站脚本攻击对Cookie信息窃取</td></tr></tbody></table><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>告知服务器当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie，接收到多个Cookie时，同样可以多个Cookie形式发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: status=enable</span><br></pre></td></tr></table></figure><h4 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h4><h5 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h5><p>属于HTTP响应首部，<strong>用于控制网站内容在其他Web网站的<code>Frame</code>标签内的显示问题</strong>，其主要目的是为了<strong>防止点击劫持<code>clickjacking</code>攻击</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># DENY：拒绝</span><br><span class="line"><span class="attribute">X-Frame-Options</span>: DENY</span><br><span class="line"># SAMEORIGIN：仅同源域名下的页面匹配时许可</span><br><span class="line"><span class="attribute">X-Frame-Options</span>: SAMEORIGIN</span><br></pre></td></tr></table></figure><h5 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h5><p>属于HTTP响应首部，<strong>针对跨站脚本攻击<code>XSS</code>的一种对策</strong>，用于控制浏览器XSS防护机制的开关</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 0：将XSS过滤设置成无效状态</span><br><span class="line"># 1：将XSS过滤设置成有效状态</span><br><span class="line"><span class="attribute">X-XSS-Protection</span>: 1</span><br></pre></td></tr></table></figure><h5 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h5><p>属于HTTP请求首部，<strong>拒绝个人信息被收集</strong>，是表示拒绝被精准广告追踪的一种方法</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 0：同意被追踪；1：拒绝被追踪</span><br><span class="line"><span class="attribute">DNT</span>: 1</span><br></pre></td></tr></table></figure><h5 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h5><p>属于HTTP响应首部，通过利用P3P在线隐私偏好平台技术，让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私目的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P3P</span>: CP="CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND UNI COM NAV INT"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由&lt;strong&gt;欧洲孩子研究组织CERN&lt;/strong&gt;的&lt;strong&gt;蒂姆伯纳斯李&lt;/strong&gt;博士提出的一种能让远隔两地的研究者们共享知识的设想，最初设想的基本理念是，&lt;strong&gt;借助多文档之间的相互关联形成的超文本&lt;/strong&gt;，连成可相互参阅的WW
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="协议族" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="网络" scheme="https://yaoyinglong.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Nacos问题总结</title>
    <link href="https://yaoyinglong.github.io/Blog/Cloud/Nacos/Nacos%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Cloud/Nacos/Nacos问题总结/</id>
    <published>2022-05-15T16:00:00.000Z</published>
    <updated>2022-05-17T13:20:18.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务启动注册成功隔段时间被踢掉"><a href="#服务启动注册成功隔段时间被踢掉" class="headerlink" title="服务启动注册成功隔段时间被踢掉"></a>服务启动注册成功隔段时间被踢掉</h3><p>使用的Nacos版本为1.2.1，服务启动时能正常注册到Nacos上，说明服务是能连上Nacos的，隔段时间被踢掉，很明显是因为Nacos的心跳机制，说明Nacos服务端未收到客户端发送的心跳</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nacos客户端心跳任务的创建是通过服务启动时，调用<strong><code>NamingService</code></strong>的<strong><code>registerInstance</code></strong>注册服务时调用BeatReactor的addBeatInfo方法完成的心跳任务创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosNamingService</span> <span class="keyword">implements</span> <span class="title">NamingService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            BeatInfo beatInfo = <span class="keyword">new</span> BeatInfo();</span><br><span class="line">            beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));</span><br><span class="line">            beatInfo.setIp(instance.getIp());</span><br><span class="line">            beatInfo.setPort(instance.getPort());</span><br><span class="line">            beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">            beatInfo.setWeight(instance.getWeight());</span><br><span class="line">            beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">            beatInfo.setScheduled(<span class="keyword">false</span>);</span><br><span class="line">            beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line">            <span class="keyword">this</span>.beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.serverProxy.registerService(NamingUtils.getGroupedName(serviceName, groupName), groupName, instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeatReactor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeatInfo</span><span class="params">(String serviceName, BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">        LogUtils.NAMING_LOGGER.info(<span class="string">"[BEAT] adding beat: &#123;&#125; to beat map."</span>, beatInfo);</span><br><span class="line">        String key = <span class="keyword">this</span>.buildKey(serviceName, beatInfo.getIp(), beatInfo.getPort());</span><br><span class="line">        BeatInfo existBeat = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((existBeat = (BeatInfo)<span class="keyword">this</span>.dom2Beat.remove(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            existBeat.setStopped(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dom2Beat.put(key, beatInfo);</span><br><span class="line">        <span class="keyword">this</span>.executorService.schedule(<span class="keyword">new</span> BeatReactor.BeatTask(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">        MetricsMonitor.getDom2BeatSizeMonitor().set((<span class="keyword">double</span>)<span class="keyword">this</span>.dom2Beat.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终周期执行BeatTask心跳任务从而完成客户端向Nacos服务端发送心跳任务，该问题是因为在解析服务端响应的心跳内容时报错了，是由于这里使用的<strong><code>FastJson</code></strong>报错从而导致的该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeatReactor</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        BeatInfo beatInfo;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BeatTask</span><span class="params">(BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beatInfo = beatInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.beatInfo.isStopped()) &#123;</span><br><span class="line">                <span class="keyword">long</span> nextTime = <span class="keyword">this</span>.beatInfo.getPeriod();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    JSONObject result = BeatReactor.<span class="keyword">this</span>.serverProxy.sendBeat(<span class="keyword">this</span>.beatInfo, BeatReactor.<span class="keyword">this</span>.lightBeatEnabled);</span><br><span class="line">                    <span class="keyword">long</span> interval = (<span class="keyword">long</span>)result.getIntValue(<span class="string">"clientBeatInterval"</span>);</span><br><span class="line">                    <span class="keyword">boolean</span> lightBeatEnabled = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (result.containsKey(<span class="string">"lightBeatEnabled"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 报错行</span></span><br><span class="line">                        lightBeatEnabled = result.getBooleanValue(<span class="string">"lightBeatEnabled"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeatReactor.<span class="keyword">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">                    <span class="keyword">if</span> (interval &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                        nextTime = interval;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> code = <span class="number">10200</span>;</span><br><span class="line">                    <span class="keyword">if</span> (result.containsKey(<span class="string">"code"</span>)) &#123;</span><br><span class="line">                        code = result.getIntValue(<span class="string">"code"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (code == <span class="number">20404</span>) &#123;</span><br><span class="line">                        Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                        instance.setPort(<span class="keyword">this</span>.beatInfo.getPort());</span><br><span class="line">                        instance.setIp(<span class="keyword">this</span>.beatInfo.getIp());</span><br><span class="line">                        instance.setWeight(<span class="keyword">this</span>.beatInfo.getWeight());</span><br><span class="line">                        instance.setMetadata(<span class="keyword">this</span>.beatInfo.getMetadata());</span><br><span class="line">                        instance.setClusterName(<span class="keyword">this</span>.beatInfo.getCluster());</span><br><span class="line">                        instance.setServiceName(<span class="keyword">this</span>.beatInfo.getServiceName());</span><br><span class="line">                        instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                        instance.setEphemeral(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            BeatReactor.<span class="keyword">this</span>.serverProxy.registerService(<span class="keyword">this</span>.beatInfo.getServiceName(), NamingUtils.getGroupName(<span class="keyword">this</span>.beatInfo.getServiceName()), instance);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException var11) &#123;</span><br><span class="line">                    LogUtils.NAMING_LOGGER.error(<span class="string">"[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;"</span>, <span class="keyword">new</span> Object[]&#123;JSON.toJSONString(<span class="keyword">this</span>.beatInfo), var11.getErrCode(), var11.getErrMsg()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                BeatReactor.<span class="keyword">this</span>.executorService.schedule(BeatReactor.<span class="keyword">this</span>.<span class="keyword">new</span> BeatTask(<span class="keyword">this</span>.beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Debug可以很明显的看到是因为FastJson在初始化的时候找不到<strong><code>IdentityHashMap</code></strong>类导致的</p><p><img src="../../../../../images/Cloud/Nacos/Nacos问题-FastJson导致的心跳异常.png" alt="FastJson导致的心跳异常"></p><p>经排查发现，由于<strong><code>IdentityHashMap</code></strong>存在漏洞，在FastJson高版本中将该类移除掉了，这里使用的是<strong><code>FastJson 2.0.2</code></strong>版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决办法：一可以<strong>降低FastJson的版本</strong>，二<strong>升级Nacos版本</strong>，在<strong><code>Nacos 1.3.1</code></strong>及之后的版本中为了解决该bug，在心跳检测任务这里未再使用<strong><code>FastJson</code></strong>，而是使用的而<strong><code>jackson</code></strong>，从而避免了该bug的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeatReactor</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        BeatInfo beatInfo;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BeatTask</span><span class="params">(BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beatInfo = beatInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> nextTime = beatInfo.getPeriod();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JsonNode result = serverProxy.sendBeat(beatInfo, BeatReactor.<span class="keyword">this</span>.lightBeatEnabled);</span><br><span class="line">                <span class="keyword">long</span> interval = result.get(<span class="string">"clientBeatInterval"</span>).asLong();</span><br><span class="line">                <span class="keyword">boolean</span> lightBeatEnabled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                    lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">                &#125;</span><br><span class="line">                BeatReactor.<span class="keyword">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">                <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nextTime = interval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> code = NamingResponseCode.OK;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                    code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                    Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                    instance.setPort(beatInfo.getPort());</span><br><span class="line">                    instance.setIp(beatInfo.getIp());</span><br><span class="line">                    instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                    instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                    instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                    instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                    instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                    instance.setEphemeral(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                                                    NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">"[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;"</span>,</span><br><span class="line">                                    JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line">            &#125;</span><br><span class="line">            executorService.schedule(<span class="keyword">new</span> BeatTask(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务启动注册成功隔段时间被踢掉&quot;&gt;&lt;a href=&quot;#服务启动注册成功隔段时间被踢掉&quot; class=&quot;headerlink&quot; title=&quot;服务启动注册成功隔段时间被踢掉&quot;&gt;&lt;/a&gt;服务启动注册成功隔段时间被踢掉&lt;/h3&gt;&lt;p&gt;使用的Nacos版本为1.2.1，服
      
    
    </summary>
    
      <category term="Cloud" scheme="https://yaoyinglong.github.io/categories/Cloud/"/>
    
      <category term="Nacos" scheme="https://yaoyinglong.github.io/categories/Cloud/Nacos/"/>
    
    
      <category term="SpringCloud" scheme="https://yaoyinglong.github.io/tags/SpringCloud/"/>
    
      <category term="Nacos" scheme="https://yaoyinglong.github.io/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>面试要点精简</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E7%B2%BE%E7%AE%80/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/面试要点精简/</id>
    <published>2022-03-31T16:00:00.000Z</published>
    <updated>2022-04-01T15:29:05.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><strong>快</strong>：完全基于内存操作，C语言实现对几种基础数据结构做了大量的优化，使用单线程无上下文的切换成本，基于非阻塞的IO多路复用机制，内存预分配，渐进式rehash，记录长度<br><strong>单线程</strong>：网络IO和键值对读写，耗时的指令如keys可能会导致Redis卡顿<br><strong>多线程</strong>：持久化、异步删除、集群数据同步<br><strong>IO多路复用</strong>：连接信息和事件，依次放到文件事件分派器，再将事件分发给事件处理器<br><strong><code>6.0+</code></strong>：多线程来处理数据读写和协议解析，性能瓶颈在于网络IO而非CPU<br><strong>应用场景</strong>：计数器、分布式ID生成、海量数据统计、Session共享、分布式队列、阻塞队列、分布式锁、热点数据存储、社交需求（共同好友、好友推荐）、排行榜、ZSet延迟队列</p><p>RedisDB、dict、dictht、dictEntity、redisObject<br><strong>动态简单字符串SDS</strong>：记录长度、内存预分配两倍扩容（&lt;1M）、兼容\0</p><p><strong>字符串</strong>：int（利用redisObject ptr指针）、embstr（利用缓存行64-16-4=44）、row（普通SDS）<br><strong>list</strong>：quicklist双向无环链表结构（节点为ziplist、单个ziplist节点最大能存储8kb，超过将分裂）<br><strong>hash</strong>：ziplist（个数&lt;255，单个小于64byte）、hashtable<br><strong>set</strong>：intset（能用int表示，且个数小于512）、hashtable<br><strong>zset</strong>：ziplist（个数小于128，单个小于64byte）、skiplist（头结点ziplist、zskiplistNode跳表节点）；不用红黑树因为跳表实现更简单、红黑树插入删除时需要rebalance，红黑树在查找区间元素的效率没有跳表高<br>GeoHash、BitMap</p><p><strong>持久化</strong>：RDB快照、AOF、混合持久化<br><strong>RDB快照</strong>：N秒内数据集至少有M个改动，可手动bgsave或save、体积小、恢复快、容易丢数据<br><strong>AOF</strong>：修改的每一条指令、appendonly yes开启AOF、appendfsync（always每次、everysec每秒）,可配置达到64M重写或增长100%重写，从节点和主节点间会建立Socket长连接</p><p>min-replicas-to-write 1 写数据成功最少同步的slave数量<br>maxclients 10000 最大连接数<br>maxmemory 0 最大可使用内存值byte，默认0不限制</p><p><strong>maxmemory_policy noeviction</strong> 当达到maxmemory时的淘汰策略<br><strong>volatile-lru</strong>：从已设置过期时间的key中，移出最久未被使用的key进行淘汰<br><strong>volatile-ttl</strong>：从已设置过期时间的key中，根据过期时间的先后进行删除，越早过期的越先被删除<br><strong>volatile-random</strong>：从已设置过期时间的key中，随机选择key淘汰<br><strong>volatile-lfu</strong>：设置了过期时间的键值对删除最近一段时间被访问次数最少的数据<br><strong>allkeys-lru</strong>：从所有key中选择最近最少使用的进行淘汰<br><strong>allkeys-random</strong>：从所有key中随机选择key进行淘汰<br><strong>allkeys-lfu</strong>：所有数据中进行筛选删除最近一段时间被访问次数最少的数据<br><strong>noeviction</strong>：当内存达到阈值的时候，新写入操作报错</p><p><strong>缓存击穿</strong>：空对象，缓存空对象或Bloom过滤器+白名单+黑名单<br><strong>缓存失效</strong>：大批量缓存在同一时间失效，在一个基础时间上加一个随机时间<br><strong>缓存雪崩</strong>：事前：保证缓存层服务高可用性、事中：后端限流熔断并降级，事后：开启Redis持久化机制</p><p><strong>红锁</strong>：一般5个</p><p><strong>哨兵</strong>：监控redis实例节点，client第一次从哨兵找出redis的主节点，后续直接访问主节点，主节点发生变化将新的redis主节点通知给client端，但有一定延时，性能和高可用性等各方面表现一般，主从切换瞬间存在访问瞬断情况</p><p><strong>集群</strong>：复制、高可用和分片特性，至少三个master主节点，没有中心节点可水平扩展，性能和高可用性均优于哨兵模式，16384个slots槽位，槽位的信息可能存在客户端与服务器不一致跳转重定向，key前面加上{XX}</p><p><strong>数据丢失</strong>：min-replicas-to-write 1 写数据成功最少同步的slave数量</p><p>若master收到了多个slave从节点并发连接请求，它只会进行一次持久化，master中缓存队列，缓存最近一段时间的数据，主节点和它所有从节点都维护了复制数据下标offset和master进程id，当网络连接断开后，slave从节点会请求master主节点从所记录的数据下标开始继续进行未完成的复制。若master主节点进程id变化，或slave从节点数据下标offset太旧超出master主节点缓存队列，则将进行一次全量数据复制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;快&lt;/strong&gt;：完全基于内存操作，C语言实现对几种基础数据结构做了大量的优化，使用单线程无上下
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>经典算法-动态规划</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/经典算法-动态规划/</id>
    <published>2022-03-28T16:00:00.000Z</published>
    <updated>2022-03-29T11:07:48.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p>非负整数数组nums，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度，使用最少的跳跃次数到达数组的最后一个位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxPosition = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        maxPosition = Math.max(maxPosition, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            end = maxPosition;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>整数数组coins表示不同面额的硬币，整数amount表示总金额，计算并返回可凑成总金额所需最少的硬币个数，若没有任何一种硬币组合能组成总金额返回-1，可认为每种硬币的数量是无限的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>], prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        prevMax = Math.max(nums[i], prevMax + nums[i]);</span><br><span class="line">        max = Math.max(max, prevMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><h5 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> leftIndex = <span class="number">1</span>, rightIndex = height.length - <span class="number">2</span>; leftIndex &lt; height.length &amp;&amp; rightIndex &gt; -<span class="number">1</span>; leftIndex++, rightIndex--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[leftIndex]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = left + <span class="number">1</span>; k &lt; leftIndex; k++) &#123;</span><br><span class="line">                res += height[left] - height[k];</span><br><span class="line">            &#125;</span><br><span class="line">            left = leftIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height[right] &lt; height[rightIndex]) &#123; <span class="comment">// 等于的情况只能有一个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = right - <span class="number">1</span>; k &gt; rightIndex; k--) &#123;</span><br><span class="line">                res += height[right] - height[k];</span><br><span class="line">            &#125;</span><br><span class="line">            right = rightIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap2</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    rightMax[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">1</span>, right = len - <span class="number">2</span>; left &lt; len || right &gt; -<span class="number">1</span>; left++, right--) &#123;</span><br><span class="line">        leftMax[left] = Math.max(leftMax[left - <span class="number">1</span>], height[left]);</span><br><span class="line">        rightMax[right] = Math.max(rightMax[right + <span class="number">1</span>], height[right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap3</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            res += leftMax - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += rightMax - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h3><p>未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度</p><h5 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, i - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] minF = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] maxF = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    minF[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    maxF[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        maxF[i] = Math.max(maxF[i - <span class="number">1</span>] * nums[i], Math.max(minF[i - <span class="number">1</span>] * nums[i], nums[i]));</span><br><span class="line">        minF[i] = Math.min(minF[i - <span class="number">1</span>] * nums[i], Math.min(maxF[i - <span class="number">1</span>] * nums[i], nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        max = Math.max(maxF[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;跳跃游戏&quot;&gt;&lt;a href=&quot;#跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;跳跃游戏&quot;&gt;&lt;/a&gt;跳跃游戏&lt;/h3&gt;&lt;p&gt;非负整数数组nums，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度，使用最少的跳跃次数到达数组的
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法-栈</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E6%A0%88/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/经典算法-栈/</id>
    <published>2022-03-28T16:00:00.000Z</published>
    <updated>2022-03-29T06:09:47.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h5 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h5><p>给定整数数组temperatures表示每天温度，返回一个数组answer，answer[i]是指在第i天之后，才会有更高的温度。若气温在这之后都不会升高，则在该位置用0来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temperature = temperatures[i];</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">            res[prevIndex] = i - prevIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, i - stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单调栈&quot;&gt;&lt;a href=&quot;#单调栈&quot; class=&quot;headerlink&quot; title=&quot;单调栈&quot;&gt;&lt;/a&gt;单调栈&lt;/h3&gt;&lt;h5 id=&quot;每日温度&quot;&gt;&lt;a href=&quot;#每日温度&quot; class=&quot;headerlink&quot; title=&quot;每日温度&quot;&gt;&lt;/a&gt;每日温
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法-链表</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/经典算法-链表/</id>
    <published>2022-03-28T16:00:00.000Z</published>
    <updated>2022-03-29T06:06:56.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pA = headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123; <span class="comment">// 链表遍历两次长度是一样的</span></span><br><span class="line">        pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表两辆交换"><a href="#链表两辆交换" class="headerlink" title="链表两辆交换"></a>链表两辆交换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode preHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), curr = preHead;</span><br><span class="line">    preHead.next = head;</span><br><span class="line">    <span class="keyword">while</span> (curr.next != <span class="keyword">null</span> &amp;&amp; curr.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node1 = curr.next;</span><br><span class="line">        ListNode node2 = curr.next.next;</span><br><span class="line">        curr.next = node2;</span><br><span class="line">        node1.next = node2.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        curr = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairsV2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = head.next;</span><br><span class="line">    head.next = swapPairsV2(newHead.next);</span><br><span class="line">    newHead.next = head;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表倒数第N个节点"><a href="#删除链表倒数第N个节点" class="headerlink" title="删除链表倒数第N个节点"></a>删除链表倒数第N个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    ListNode ans = dummy.next;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nth = removeNthFromEndDfs(head, head.next, n);</span><br><span class="line">    <span class="keyword">return</span> nth &gt; <span class="number">1</span> ? head.next : head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeNthFromEndDfs</span><span class="params">(ListNode before, ListNode curr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nth = removeNthFromEndDfs(curr, curr.next, n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nth == <span class="number">1</span>) &#123;</span><br><span class="line">        before.next = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">iterate</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>, curr, next;</span><br><span class="line">    curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = curr.next; <span class="comment">// 将下一个节点指针保存到next变量 next = curr.next</span></span><br><span class="line">        curr.next = prev; <span class="comment">// 将下一个节点的指针指向prev，curr.next = prev</span></span><br><span class="line">        prev = curr;<span class="comment">// 准备处理下一个节点，将curr赋值给prev</span></span><br><span class="line">        curr = next;<span class="comment">// 将下一个节点赋值为curr，处理一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">recursion</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为了保证链不断，必须从最后一个元素开始</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = recursion(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>判断链表中是否有环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; seen = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!seen.add(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相交链表&quot;&gt;&lt;a href=&quot;#相交链表&quot; class=&quot;headerlink&quot; title=&quot;相交链表&quot;&gt;&lt;/a&gt;相交链表&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/经典算法/</id>
    <published>2022-02-25T16:00:00.000Z</published>
    <updated>2022-03-29T06:11:05.076Z</updated>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>给定一个字符串<code>s</code> 、一个字符串<code>t</code>，返回<code>s</code>中涵盖<code>t</code>所有字符的最小子串，若<code>s</code>中不存在涵盖<code>t</code>所有字符的子串，则返回空字符串<code>&quot;&quot;</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;Character, Integer&gt; has = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        need.put(t.charAt(i), need.getOrDefault(t.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ansLen = Integer.MAX_VALUE, ansL = -<span class="number">1</span>, ansR = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; s.length() &amp;&amp; need.containsKey(s.charAt(r))) &#123;</span><br><span class="line">            has.put(s.charAt(r), has.getOrDefault(s.charAt(r), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; ansLen) &#123;</span><br><span class="line">                ansLen = r - l + <span class="number">1</span>;</span><br><span class="line">                ansL = l;</span><br><span class="line">                ansR = l + ansLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(s.charAt(l))) &#123;</span><br><span class="line">                has.put(s.charAt(l), has.getOrDefault(s.charAt(l), <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansL == -<span class="number">1</span> ? <span class="string">""</span> : s.substring(ansL, ansR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Character key : need.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (has.getOrDefault(key, <span class="number">0</span>) &lt; need.get(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h3><p>对于一个长度为N的数组，其中没有出现的最小正整数只能在1到N+1中，若1到N都出现了则答案是N+1，否则答案在1到N中，首先对数组进行遍历，将出现过的且在1到N范围内的数全部打上标记，<strong>这里打的标记是将其置为负数</strong>，若全部被打过标记了最终返回N + 1，否则返回第一个未出现负数的下标加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123; <span class="comment">// 将数组中小于0的数走置为N + 1</span></span><br><span class="line">            nums[i] = len + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 将出现过的数标记为负数</span></span><br><span class="line">        <span class="keyword">int</span> num = Math.abs(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= len) &#123;</span><br><span class="line">            nums[num - <span class="number">1</span>] = -Math.abs(nums[num - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 找出第一个不为负数的数的下标，即为未出现的数</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>数字<code>n</code>代表生成括号的对数，生成所有可能的并且<strong>有效的</strong>括号组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(res, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sb.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">        sb.append(<span class="string">"("</span>);</span><br><span class="line">        backtrack(res, sb, open + <span class="number">1</span>, close, max);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">        sb.append(<span class="string">")"</span>);</span><br><span class="line">        backtrack(res, sb, open, close + <span class="number">1</span>, max);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>给定一个不含重复数字的数组<code>nums</code> ，返回其所有可能的全排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; markList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        markList.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(nums.length, res, markList, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; markList, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(markList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">        Collections.swap(markList, first, i);</span><br><span class="line">        backtrack(n, res, markList, first + <span class="number">1</span>);</span><br><span class="line">        Collections.swap(markList, first, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><h5 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i若能被x整除，则x/i肯定能被x整除，因此只需判断i和根号x之中较小的即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eratosthenes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">// false表示是一个素数，true表示合数</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPrime[i]) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 将合数标记为true，j = i * i 从 2 * i 优化而来，系数2会随着遍历递增（j += i，相当于递增了系数2），</span></span><br><span class="line">            <span class="comment">// 每一个合数都会有两个比本身要小的因子(0,1除外)，2 * i必然会遍历到这两个因子，当2递增到大于根号n时，</span></span><br><span class="line">            <span class="comment">// 其实后面的已经无需再判断（或者只需判断后面一段），而2到根号n、实际上在 i 递增的过程中已经计算过了，i实际上就相当于根</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                isPrime[j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除有序数组中重复项"><a href="#删除有序数组中重复项" class="headerlink" title="删除有序数组中重复项"></a>删除有序数组中重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的中心索引"><a href="#数组的中心索引" class="headerlink" title="数组的中心索引"></a>数组的中心索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中某一个下标，左右两边的元素之和相等，该下标即为中心索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum1 = Arrays.stream(nums).sum();</span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum2 += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum1 == sum2) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum1 = sum1 - nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h3><p>不使用<strong><code>sqrt(x)</code></strong>函数的情况下，得到x的平方根的整数部分</p><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = x, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &lt;= x) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h5><p>假设平方根为<strong><code>i</code></strong>，则i和<strong><code>x/i</code></strong>必然都是<strong><code>x</code></strong>的因子，而<strong><code>x/i</code></strong>必然等于<strong><code>i</code></strong> ，推导出<strong><code>i + x / i = 2 * i</code></strong>，得出<strong><code>i = (i + x / i) / 2</code></strong>，由此得出解法，<strong><code>i</code></strong>可以任选一个值，只要上述公式成立，<strong><code>i</code></strong>必然就是x的平方根，若不成立<strong><code>(i + x / i) / 2</code></strong>得出的值进行递归，直至得出正确解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">newton</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) sqrts(x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrts</span><span class="params">(<span class="keyword">double</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = (i + x / i) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (res == i) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrts(res, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三个数的最大乘积"><a href="#三个数的最大乘积" class="headerlink" title="三个数的最大乘积"></a>三个数的最大乘积</h3><p>一个整型数组nums ，在数组中找出由三个数字组成的最大乘积，分三种情况，<strong>最大的三个正数相乘、最小的两个负数和最大的一个正数相乘</strong></p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[n - <span class="number">1</span>], nums[n - <span class="number">3</span>] * nums[n - <span class="number">2</span>] * nums[n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小的和第二小的</span></span><br><span class="line">    <span class="keyword">int</span> min1 = <span class="number">0</span>, min2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最大的、第二大的和第三大的</span></span><br><span class="line">    <span class="keyword">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>, max3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; min1) &#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; min2) &#123;</span><br><span class="line">            min2 = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; max1) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = max1;</span><br><span class="line">            max1 = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max2) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max3) &#123;</span><br><span class="line">            max3 = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(min1 * min2 * max1, max1 * max2 * max3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>从数组中找出两个数满足相加之和等于目标数target</p><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分查找（有序）"><a href="#二分查找（有序）" class="headerlink" title="二分查找（有序）"></a>二分查找（有序）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSearch(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = i, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, mid&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针（有序）"><a href="#双指针（有序）" class="headerlink" title="双指针（有序）"></a>双指针（有序）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoPoint(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序硬币"><a href="#排序硬币" class="headerlink" title="排序硬币"></a>排序硬币</h3><p>总共有n枚硬币，将它们摆成一个阶梯形状，第k行必须正好有k枚硬币，找出可形成完整阶梯行的总行数</p><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        n = n - i;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">int</span> cost = ((mid + <span class="number">1</span>) * mid) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cost == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cost &gt; n) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="牛顿迭代-1"><a href="#牛顿迭代-1" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h5><p>使用牛顿迭代求平方根<strong><code>(x + n/x)/2</code></strong>，<strong><code>1 + 2 + 3 + ...+ x = n</code></strong>即<strong><code>x(x+1)/2 = n</code></strong>推导出<strong><code>x = 2n - x</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrts</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = (x + (<span class="number">2</span> * n - x) / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (res == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrts(res, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并有序数组"><a href="#合并有序数组" class="headerlink" title="合并有序数组"></a>合并有序数组</h3><h5 id="合并后排序"><a href="#合并后排序" class="headerlink" title="合并后排序"></a>合并后排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, m, n);</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针（从前往后）"><a href="#双指针（从前往后）" class="headerlink" title="双指针（从前往后）"></a>双指针（从前往后）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums1_copy = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    System.arraycopy(nums1, <span class="number">0</span>, nums1_copy, <span class="number">0</span>, m); <span class="comment">//拷贝数组1</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>; <span class="comment">// 指向数组1的拷贝</span></span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>; <span class="comment">// 指向数组2</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">// 指向数组1</span></span><br><span class="line">    <span class="comment">// 将数组1当成空数组，比较数组1的拷贝和数组2，将较小的放入空数组</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &lt; m) &amp;&amp; (p2 &lt; n))</span><br><span class="line">        nums1[p++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];</span><br><span class="line">    <span class="comment">// 数组2和数组1不等长，将多出的元素拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; m) System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">    <span class="keyword">if</span> (p2 &lt; n) System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针（从后往前）"><a href="#双指针（从后往前）" class="headerlink" title="双指针（从后往前）"></a>双指针（从后往前）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge3</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>))</span><br><span class="line">        nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子数组最大平均数（滑动窗口）"><a href="#子数组最大平均数（滑动窗口）" class="headerlink" title="子数组最大平均数（滑动窗口）"></a>子数组最大平均数（滑动窗口）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">        sum = sum - nums[i - k] + nums[i];</span><br><span class="line">        maxSum = Math.max(maxSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * maxSum / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找零"><a href="#找零" class="headerlink" title="找零"></a>找零</h3><p>每位顾客只买一杯柠檬水，向你付5元、10元或20元，必须给每个顾客正确找零，每一杯柠檬水的售价为5元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> bill : bills) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bill == <span class="number">5</span>) &#123;</span><br><span class="line">            five++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (five == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            five--;</span><br><span class="line">            ten++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                five--;</span><br><span class="line">                ten--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                five -= <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三角形最大周长"><a href="#三角形最大周长" class="headerlink" title="三角形最大周长"></a>三角形最大周长</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复最长子串"><a href="#无重复最长子串" class="headerlink" title="无重复最长子串"></a>无重复最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>, rightIndex = -<span class="number">1</span>;</span><br><span class="line">    Set&lt;Character&gt; window = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            window.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightIndex + <span class="number">1</span> &lt; s.length() &amp;&amp; !window.contains(s.charAt(rightIndex + <span class="number">1</span>))) &#123;</span><br><span class="line">            window.add(s.charAt(rightIndex + <span class="number">1</span>));</span><br><span class="line">            rightIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(rightIndex - i + <span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>一个包含n个整数的数组nums，判断nums中是否存在三个元素<strong><code>a，b，c</code></strong> ，使得<strong><code>a + b + c = 0</code></strong>，找出所有和为0且不重复的三元组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">// 枚举 a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">        <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">        <span class="keyword">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = -nums[first];</span><br><span class="line">        <span class="comment">// 枚举 b</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                --third;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">            <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                list.add(nums[first]);</span><br><span class="line">                list.add(nums[second]);</span><br><span class="line">                list.add(nums[third]);</span><br><span class="line">                ans.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h3&gt;&lt;p&gt;给定一个字符串&lt;code&gt;s&lt;/code&gt; 、一个字符串&lt;code&gt;t&lt;/code&gt;，返回&lt;code&gt;s&lt;/code&gt;中涵盖
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝技术</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%9D%82%E8%AE%B0/Linux/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
    <id>https://yaoyinglong.github.io/Blog/杂记/Linux/零拷贝技术/</id>
    <published>2022-02-21T16:00:00.000Z</published>
    <updated>2022-08-14T12:39:25.163Z</updated>
    
    <content type="html"><![CDATA[<p><strong>传统文件读写</strong>有三个步骤：把文件内容读入到内存中、修改内存中的内容、把内存的数据写入到文件中，<strong><code>page cache</code>页缓存</strong>是读写文件时的中间层，<strong>内核</strong>使用<strong>页缓存</strong>与<strong>文件的数据块关联起来</strong>，所以应用程序读写文件时，实际操作的是页缓存。</p><p><img src="../../../../../images/操作系统/传统文件读写.jpg" alt></p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><strong><code>mmap</code></strong>即<strong><code>memory map</code>内存映射</strong>，是一种<strong>内存映射文件</strong>的方法，即将一个<strong>文件</strong>或<strong>其它对象</strong>映射到<strong>进程的地址空间</strong>，实现<strong>文件磁盘地址</strong>和<strong>进程虚拟地址空间</strong>中<strong>一段虚拟地址的一一对映关系</strong>。实现这样的映射关系后，进程就可<strong>采用指针</strong>的方式<strong>读写操作</strong>这一段内存，而<strong>系统会自动回写脏页面</strong>到对应的文件磁盘上，即完成了对文件的操作而不必再调用read、write等系统调用函数。<strong>内存映射服务的地址空间处在堆栈之间的空余部分。</strong></p><p><img src="../../../../../images/操作系统/mmap文件磁盘地址与进程虚拟地址映射.png" alt></p><p>读写文件都需要经过页缓存，<strong><code>mmap</code></strong>映射的正是文件的<strong>页缓存</strong>，而非磁盘中的文件本身，Linux内核并不会主动把<code>mmap</code>映射的<code>页缓存</code>同步到磁盘，而是需要用户主动触发，同步<code>mmap</code>映射的内存到磁盘有4个时机：</p><ul><li><strong>调用<code>msync</code>函数</strong>主动进行<strong>数据同步</strong>（<strong>主动</strong>）</li><li><strong>调用<code>munmap</code>函数</strong>对文件进行<strong>解除映射关系</strong>时（<strong>主动</strong>）</li><li><strong>进程退出</strong>时（<strong>被动</strong>）</li><li><strong>系统关机</strong>时（<strong>被动</strong>）</li></ul><p><strong>基于磁盘的读写</strong>单位是<strong>block</strong>，一般大小为<strong><code>4KB</code></strong>，而<strong>基于内存的读写</strong>单位是<strong>地址</strong>，即<strong><code>CPU</code></strong>进行一次<strong>磁盘读写操作</strong>涉及的<strong>数据量至少</strong>是<strong><code>4KB</code></strong>，但进行一次<strong>内存操作</strong>涉及的<strong>数据量是基于地址</strong>的，<strong><code>64</code></strong>位操作系统通常是<strong><code>64bit</code></strong>，<strong><code>mmap</code></strong>下进程可采用<strong>指针</strong>的方式进行读写操作。</p><p><strong><code>mmap</code></strong>向<strong>应用程序</strong>提供的<strong>内存访问接口</strong>是<strong>内存地址连续</strong>的，但对应<strong>磁盘文件</strong>的<strong><code>block</code></strong>可以<strong>不是地址连续</strong>的；<strong><code>mmap</code></strong>提供的<strong>内存空间</strong>是<strong>虚拟内存</strong>，而<strong>不是物理内存</strong>，因此<strong>可分配远远大于物理内存大小的虚拟内存</strong>，如16G内存主机分配1000G的mmap内存空间；mmap负责<strong>映射文件逻辑上一段连续</strong>的数据映射为<strong>连续内存</strong>，物理上可以不连续存储，而这里的文件可以是<strong>磁盘文件</strong>以及设备；mmap由<strong>操作系统负责管理</strong>，对<strong>同一个文件地址</strong>的映射将<strong>被所有线程共享</strong>，<strong>操作系统确保线程安全以及线程可见性</strong>；</p><p>内核<strong><code>mmap</code></strong>函数通过<strong>虚拟文件系统<code>inode</code>模块</strong>定位到<strong>文件磁盘物理地址</strong>，<strong><code>mmap</code>库函数原型</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start: 映射区的开始地址</span></span><br><span class="line"><span class="comment">// length: 映射区的长度</span></span><br><span class="line"><span class="comment">// prot: 期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起</span></span><br><span class="line"><span class="comment">//   PROT_EXEC: 页内容可以被执行</span></span><br><span class="line"><span class="comment">//    PROT_READ: 页内容可以被读取</span></span><br><span class="line"><span class="comment">//    PROT_WRITE: 页可以被写入</span></span><br><span class="line"><span class="comment">//    PROT_NONE: 页不可访问</span></span><br><span class="line"><span class="comment">// flags: 指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体</span></span><br><span class="line"><span class="comment">//    MAP_FIXED: 使用指定的映射起始地址，若由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。若指定起始地址不可用，操作将会失败，且起始地址必须落在页的边界上</span></span><br><span class="line"><span class="comment">//    MAP_SHARED: 与其它所有映射该对象的进程共享映射空间，对共享区的写入相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新</span></span><br><span class="line"><span class="comment">//    MAP_PRIVATE: 建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。该标志和MAP_SHARED是互斥的</span></span><br><span class="line"><span class="comment">//    MAP_DENYWRITE: 该志被忽略</span></span><br><span class="line"><span class="comment">//    MAP_EXECUTABLE: 同上</span></span><br><span class="line"><span class="comment">//    MAP_NORESERVE: 不要为该射保留交换空间，当交换空间被保留，对映射区修改的可能会得到保证，当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号</span></span><br><span class="line"><span class="comment">//    MAP_LOCKED: 锁定映射区的页面，从而防止页面被交换出内存</span></span><br><span class="line"><span class="comment">//    MAP_GROWSDOWN: 用于堆栈，告诉内核VM系统，映射区可以向下扩展</span></span><br><span class="line"><span class="comment">//    MAP_ANONYMOUS: 匿名映射，映射区不与任何文件关联</span></span><br><span class="line"><span class="comment">//    MAP_ANON: MAP_ANONYMOUS的别称，不再被使用</span></span><br><span class="line"><span class="comment">//    MAP_FILE: 兼容标志，被忽略</span></span><br><span class="line"><span class="comment">//    MAP_32BIT: 将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略，当前该志只在x86-64平台上得到支持</span></span><br><span class="line"><span class="comment">//    MAP_POPULATE: 为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞</span></span><br><span class="line"><span class="comment">//    MAP_NONBLOCK: 仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口</span></span><br><span class="line"><span class="comment">// fd: 有效的文件描述符，若MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1</span></span><br><span class="line"><span class="comment">// offset: 被映射对象内容的起点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p><strong><code>mmap</code></strong>是一种零拷贝技术，，其 I/O 模型如下：</p><p><img src="../../../../../images/操作系统/mmap IO模型.png" alt></p><p>mmap也有其缺陷，在相关场景下的性能存在缺陷：</p><ul><li>由于<strong><code>mmap</code></strong>使用时必须实现<strong>指定好内存映射的大小</strong>，因此<strong><code>mmap</code>并不适合变长文件</strong>；</li><li>若<strong>更新文件的操作很多</strong>，<strong><code>mmap</code></strong>避免<strong>两态拷贝</strong>的优势就被冲没了，最终还是落在了<strong>大量的脏页回写</strong>及由此<strong>引发的随机<code>I/O</code>上</strong>，故在随机写很多的情况下，mmap方式在效率上不一定会比带缓冲区的一般写快；</li><li><strong>读/写小文件</strong>，如<strong><code>16K</code>以下</strong>的文件，mmap与通过read系统调用相比有着<strong>更高的开销与延迟</strong>；同时mmap的<strong>刷盘由系统全权控制</strong>，但在<strong>小数据量</strong>的情况下<strong>由应用本身手动控制更好</strong>；</li><li><strong><code>mmap</code></strong>受限于<strong>操作系统内存大小</strong>，如<strong><code>32bits</code></strong>操作系统上，虚拟内存总大小也就<strong><code>2GB</code></strong>，但由于mmap必须要在内存中找到一块<strong>连续的地址块</strong>，此时就无法对<strong><code>4GB</code></strong>大小的文件<strong>完全进行<code>mmap</code></strong>，该情况下必须<strong>分多块</strong>分别进行mmap，但此时地址内存地址已经不再连续，使用mmap的意义大打折扣，且引入了额外的复杂性；</li></ul><p>mmap的适用场景实际上非常受限，在如下场合下可选择使用mmap机制：</p><ul><li><strong>多个线程</strong>以<strong>只读</strong>的方式同时访问一个文件，因为mmap机制下<strong>多线程共享了同一物理内存空间</strong>，因此节约了内存。如多个进程可能依赖于同一个动态链接库，利用mmap可实现内存仅仅加载一份动态链接库，多个进程共享此动态链接库。</li><li><strong><code>mmap</code></strong>非常适合用于<strong>进程间通信</strong>，对同一文件对应的mmap分配的物理内存天然多线程共享，并可<strong>依赖于操作系统的同步原语</strong>；</li><li><strong><code>mmap</code></strong>虽然比<strong><code>sendfile</code></strong>等机制多了一次CPU全程参与的内存拷贝，但用户空间与内核空间并不需要数据拷贝，因此在正确使用情况下并不比<strong><code>sendfile</code></strong>效率差；</li></ul><h4 id="mmap-Java实现"><a href="#mmap-Java实现" class="headerlink" title="mmap Java实现"></a>mmap Java实现</h4><p>Java中原生读写方式大概可以被分为三种：<strong>普通IO</strong>，<strong>FileChannel文件通道</strong>，<strong>mmap内存映射</strong>；<strong><code>FileWriter</code></strong>、<strong><code>FileReader</code></strong>存在于<strong><code>java.io</code></strong>包中属于<strong>普通IO</strong>；<strong><code>FileChannel</code></strong>存在于<strong><code>java.nio</code></strong>包中，也是Java最常用的文件操作类，<strong><code>mmap</code></strong>则是由<strong><code>FileChannel</code></strong>调用map方法衍生出来的一种<strong>特殊读写文件的方式</strong>。</p><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;传统文件读写&lt;/strong&gt;有三个步骤：把文件内容读入到内存中、修改内存中的内容、把内存的数据写入到文件中，&lt;strong&gt;&lt;code&gt;page cache&lt;/code&gt;页缓存&lt;/strong&gt;是读写文件时的中间层，&lt;strong&gt;内核&lt;/strong&gt;使
      
    
    </summary>
    
      <category term="杂记" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://yaoyinglong.github.io/categories/%E6%9D%82%E8%AE%B0/Linux/"/>
    
    
      <category term="零拷贝技术" scheme="https://yaoyinglong.github.io/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
